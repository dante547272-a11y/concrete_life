# 无人拌合站硬件集成方案

## 一、硬件接入架构

### 1.1 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    硬件设备层                                │
├─────────────────────────────────────────────────────────────┤
│  智能磅房区域                                                │
│  ├─ 车牌识别摄像头 (HTTP API)                               │
│  ├─ 称重传感器 (Modbus TCP)                                 │
│  └─ 红外检测器 (GPIO/MQTT)                                  │
├─────────────────────────────────────────────────────────────┤
│  仓储区域                                                    │
│  ├─ 激光雷达 (TCP Socket)                                   │
│  ├─ 料位传感器 (4-20mA → Modbus)                           │
│  └─ 温度传感器 (RS485 → Modbus)                            │
├─────────────────────────────────────────────────────────────┤
│  装车区域                                                    │
│  ├─ AI高清摄像头 (RTSP/HTTP)                               │
│  ├─ 对位引导系统 (PLC → OPC UA)                            │
│  └─ LED显示屏 (HTTP API)                                    │
├─────────────────────────────────────────────────────────────┤
│  车载设备                                                    │
│  ├─ GPS定位模块 (4G → HTTP)                                │
│  └─ 温度传感器 (蓝牙 → 4G网关)                             │
└─────────────────────────────────────────────────────────────┘
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                    边缘计算网关                              │
│  ├─ 协议转换 (Modbus/MQTT/OPC UA → HTTP)                   │
│  ├─ 数据预处理 (滤波、校准、聚合)                          │
│  ├─ 本地缓存 (断网续传)                                     │
│  └─ 安全加密 (TLS/SSL)                                      │
└─────────────────────────────────────────────────────────────┘
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                    应用服务器                                │
│  ├─ 数据接收API (NestJS)                                   │
│  ├─ 数据存储 (PostgreSQL)                                  │
│  ├─ 实时推送 (WebSocket)                                   │
│  └─ 业务逻辑处理                                            │
└─────────────────────────────────────────────────────────────┘
```

---

## 二、智能磅房系统集成

### 2.1 车牌识别系统

**硬件型号**: 海康威视 iDS-2CD7A26FWD/LZ (800万像素)

**接入方式**: HTTP API

**数据推送接口**:
```typescript
// 后端接收接口
POST /api/weighing/plate-recognition
{
  "plateNumber": "浙A12345",
  "confidence": 0.98,
  "captureTime": "2026-02-05T10:30:00Z",
  "imageUrl": "http://camera/image/123.jpg"
}

// 后端处理逻辑
@Post('plate-recognition')
async handlePlateRecognition(@Body() data: PlateRecognitionDto) {
  // 1. 查询车辆信息
  const vehicle = await this.equipmentService.findByPlate(data.plateNumber);
  
  // 2. 创建排队记录
  const queue = await this.queueService.create({
    equipmentId: vehicle.id,
    arrivalTime: new Date(),
    status: 'waiting'
  });
  
  // 3. WebSocket推送到前端
  this.websocketService.emit('queue:new', queue);
  
  // 4. 触发称重流程
  await this.weighingService.startWeighing(queue.id);
}
```

### 2.2 称重传感器

**硬件型号**: 梅特勒-托利多 IND780 (精度±0.1%)

**通信协议**: Modbus TCP

**数据采集**:
```typescript
// 边缘网关代码 (Node.js)
import ModbusRTU from 'modbus-serial';

const client = new ModbusRTU();
await client.connectTCP('192.168.1.100', { port: 502 });

// 每秒读取一次重量
setInterval(async () => {
  const weight = await client.readHoldingRegisters(0, 2);
  const weightValue = weight.buffer.readFloatBE(0);
  
  // 推送到服务器
  await axios.post('http://server:3001/api/weighing/data', {
    weight: weightValue,
    unit: 'kg',
    timestamp: new Date().toISOString()
  });
}, 1000);
```

**后端处理**:
```typescript
@Post('weighing/data')
async handleWeighingData(@Body() data: WeighingDataDto) {
  // 1. 数据校验
  if (data.weight < 0 || data.weight > 100000) {
    throw new BadRequestException('重量数据异常');
  }
  
  // 2. 判断是否稳定
  const isStable = await this.checkWeightStable(data.weight);
  
  if (isStable) {
    // 3. 记录称重结果
    await this.materialTransactionService.create({
      weight: data.weight,
      timestamp: data.timestamp
    });
    
    // 4. 生成电子票据
    const ticket = await this.generateTicket(data);
    
    // 5. 推送到前端
    this.websocketService.emit('weighing:complete', ticket);
  }
}
```

---

## 三、智能仓储系统集成

### 3.1 激光雷达 (集料料仓)

**硬件型号**: SICK LMS511 (测量精度±5mm)

**通信协议**: TCP Socket

**点云数据处理**:
```typescript
// 边缘网关 - 点云数据采集
import net from 'net';

const client = net.connect({ host: '192.168.1.101', port: 2111 });

client.on('data', async (data) => {
  // 解析点云数据
  const pointCloud = parseLidarData(data);
  
  // 计算料堆体积
  const volume = calculateVolume(pointCloud);
  
  // 推送到服务器
  await axios.post('http://server:3001/api/materials/stock-update', {
    materialId: 1,
    volume: volume,
    pointCloud: compressPointCloud(pointCloud),
    timestamp: new Date().toISOString()
  });
});

// 体积计算算法
function calculateVolume(pointCloud: Point3D[]): number {
  // 1. 构建三维网格
  const grid = buildGrid(pointCloud);
  
  // 2. 计算每个网格的高度
  const heights = grid.map(cell => cell.maxZ - cell.minZ);
  
  // 3. 累加体积
  const cellArea = 0.1 * 0.1; // 10cm x 10cm
  const totalVolume = heights.reduce((sum, h) => sum + h * cellArea, 0);
  
  return totalVolume;
}
```

**后端处理**:
```typescript
@Post('materials/stock-update')
async handleStockUpdate(@Body() data: StockUpdateDto) {
  // 1. 更新库存
  const stock = await this.materialStockService.update(data.materialId, {
    currentStock: data.volume,
    lastUpdate: new Date()
  });
  
  // 2. 检查库存阈值
  const material = await this.materialsService.findOne(data.materialId);
  const percentage = (stock.currentStock / stock.capacity) * 100;
  
  // 3. 触发告警
  if (percentage < 10) {
    await this.alarmsService.create({
      alarmType: 'material_low',
      severity: 'warning',
      message: `${material.name}库存不足，当前${percentage.toFixed(1)}%`
    });
  } else if (percentage > 90) {
    await this.alarmsService.create({
      alarmType: 'material_overflow',
      severity: 'warning',
      message: `${material.name}库存过高，当前${percentage.toFixed(1)}%`
    });
  }
  
  // 4. WebSocket推送
  this.websocketService.emit('material:stock-update', {
    materialId: data.materialId,
    currentStock: stock.currentStock,
    percentage: percentage
  });
}
```

### 3.2 温度传感器 (粉料料仓)

**硬件型号**: 欧姆龙 E52-CA (精度±0.5℃)

**通信协议**: RS485 → Modbus RTU

**数据采集**:
```typescript
// 边缘网关 - 温度监控
import ModbusRTU from 'modbus-serial';

const client = new ModbusRTU();
await client.connectRTUBuffered('/dev/ttyUSB0', { baudRate: 9600 });

// 每30秒读取一次温度
setInterval(async () => {
  for (let siloId = 1; siloId <= 4; siloId++) {
    client.setID(siloId);
    const temp = await client.readInputRegisters(0, 1);
    const temperature = temp.data[0] / 10; // 温度值需除以10
    
    await axios.post('http://server:3001/api/materials/temperature', {
      siloId: siloId,
      temperature: temperature,
      timestamp: new Date().toISOString()
    });
  }
}, 30000);
```

**后端处理**:
```typescript
@Post('materials/temperature')
async handleTemperature(@Body() data: TemperatureDto) {
  // 1. 记录温度数据
  await this.temperatureLogService.create(data);
  
  // 2. 检查温度阈值
  if (data.temperature > 60) {
    await this.alarmsService.create({
      alarmType: 'temperature_high',
      severity: 'critical',
      message: `料仓${data.siloId}温度过高: ${data.temperature}℃`,
      source: `silo_${data.siloId}`
    });
    
    // 触发降温措施
    await this.coolingService.activate(data.siloId);
  }
  
  // 3. 实时推送
  this.websocketService.emit('temperature:update', data);
}
```

---

## 四、智能装车系统集成

### 4.1 AI摄像头 (车辆对位)

**硬件型号**: 海康威视 DS-2CD7A86G0/P-IZS (800万像素)

**AI算法**: 车辆检测 + 位置识别

**对位引导**:
```typescript
// 边缘计算 - AI推理
import * as tf from '@tensorflow/tfjs-node';

// 加载模型
const model = await tf.loadGraphModel('file://./vehicle-detection-model');

// 视频流处理
const rtspStream = 'rtsp://192.168.1.102:554/stream';
const cap = new cv.VideoCapture(rtspStream);

setInterval(async () => {
  const frame = cap.read();
  
  // AI推理
  const tensor = tf.browser.fromPixels(frame);
  const predictions = await model.predict(tensor);
  
  // 解析结果
  const vehicle = parseVehiclePosition(predictions);
  
  if (vehicle) {
    // 计算偏移量
    const offset = {
      x: vehicle.centerX - TARGET_X,
      y: vehicle.centerY - TARGET_Y
    };
    
    // 推送引导信息
    await axios.post('http://server:3001/api/loading/guidance', {
      queueId: currentQueueId,
      offset: offset,
      distance: vehicle.distance,
      aligned: Math.abs(offset.x) < 10 && Math.abs(offset.y) < 10
    });
  }
}, 100); // 10fps
```

**后端处理**:
```typescript
@Post('loading/guidance')
async handleGuidance(@Body() data: GuidanceDto) {
  // 1. 更新排队状态
  await this.queueService.update(data.queueId, {
    alignmentStatus: data.aligned ? 'aligned' : 'aligning',
    offsetX: data.offset.x,
    offsetY: data.offset.y
  });
  
  // 2. 生成引导指令
  let instruction = '';
  if (!data.aligned) {
    if (data.offset.x > 10) instruction += '向左移动 ';
    if (data.offset.x < -10) instruction += '向右移动 ';
    if (data.offset.y > 10) instruction += '向前移动 ';
    if (data.offset.y < -10) instruction += '向后移动 ';
  } else {
    instruction = '对位完成，准备装车';
    
    // 自动开始装车
    await this.loadingService.startLoading(data.queueId);
  }
  
  // 3. 推送到LED显示屏和前端
  this.websocketService.emit('guidance:update', {
    queueId: data.queueId,
    instruction: instruction,
    aligned: data.aligned
  });
  
  // 4. 控制LED显示屏
  await this.ledService.display(instruction);
}
```

### 4.2 防溢料检测

**AI算法**: 物料表面检测

**实时监控**:
```typescript
// 边缘计算 - 溢料检测
const SAFE_DISTANCE = 200; // 安全距离200mm

setInterval(async () => {
  const frame = cap.read();
  
  // 检测混凝土表面
  const surface = detectConcreteSurface(frame);
  
  if (surface) {
    // 计算距离漏斗口的距离
    const distance = FUNNEL_HEIGHT - surface.topY;
    
    if (distance < SAFE_DISTANCE) {
      // 触发报警
      await axios.post('http://server:3001/api/loading/overflow-warning', {
        queueId: currentQueueId,
        distance: distance,
        critical: distance < 100
      });
    }
  }
}, 100);
```

**后端处理**:
```typescript
@Post('loading/overflow-warning')
async handleOverflowWarning(@Body() data: OverflowWarningDto) {
  // 1. 创建告警
  await this.alarmsService.create({
    alarmType: 'overflow_risk',
    severity: data.critical ? 'critical' : 'warning',
    message: `车辆${data.queueId}即将溢料，距离${data.distance}mm`
  });
  
  // 2. 自动控制
  if (data.critical) {
    // 暂停装车
    await this.loadingService.pauseLoading(data.queueId);
  } else {
    // 降低装车速度
    await this.loadingService.reduceSpeed(data.queueId, 0.5);
  }
  
  // 3. 实时推送
  this.websocketService.emit('overflow:warning', data);
}
```

---

## 五、车载设备集成

### 5.1 GPS定位系统

**硬件型号**: 移远 EC20 4G模块 + GPS

**数据上报**:
```typescript
// 车载终端代码
import gps from 'gps';
import axios from 'axios';

const parser = new gps.Parser();

// 监听GPS数据
parser.on('data', async (data) => {
  if (data.type === 'GGA') {
    // 上报位置
    await axios.post('http://server:3001/api/vehicles/location', {
      vehicleId: VEHICLE_ID,
      latitude: data.lat,
      longitude: data.lon,
      speed: data.speed,
      timestamp: new Date().toISOString()
    }, {
      headers: {
        'Authorization': `Bearer ${TOKEN}`
      }
    });
  }
});

// 每10秒上报一次
setInterval(() => {
  const gpsData = readGPSData();
  parser.write(gpsData);
}, 10000);
```

**后端处理**:
```typescript
@Post('vehicles/location')
async handleLocation(@Body() data: LocationDto) {
  // 1. 更新车辆位置
  await this.vehicleLocationService.update(data.vehicleId, {
    latitude: data.latitude,
    longitude: data.longitude,
    speed: data.speed,
    lastUpdate: new Date()
  });
  
  // 2. 检查运输时长
  const task = await this.tasksService.findActiveByVehicle(data.vehicleId);
  if (task) {
    const duration = Date.now() - task.startedAt.getTime();
    const hours = duration / (1000 * 60 * 60);
    
    if (hours > 2) {
      await this.alarmsService.create({
        alarmType: 'transport_timeout',
        severity: 'warning',
        message: `车辆${data.vehicleId}运输超时${hours.toFixed(1)}小时`
      });
    }
  }
  
  // 3. 检查路线偏离
  const isOffRoute = await this.checkRouteDeviation(data);
  if (isOffRoute) {
    await this.alarmsService.create({
      alarmType: 'route_deviation',
      severity: 'warning',
      message: `车辆${data.vehicleId}偏离预定路线`
    });
  }
  
  // 4. 实时推送
  this.websocketService.emit('vehicle:location', data);
}
```

### 5.2 温度传感器

**硬件型号**: 蓝牙温度传感器

**数据采集**:
```typescript
// 车载终端 - 蓝牙数据采集
import noble from '@abandonware/noble';

noble.on('discover', (peripheral) => {
  if (peripheral.advertisement.localName === 'TempSensor') {
    peripheral.connect((error) => {
      peripheral.discoverServices(['180A'], (error, services) => {
        services[0].discoverCharacteristics(['2A6E'], (error, characteristics) => {
          // 订阅温度数据
          characteristics[0].on('data', async (data) => {
            const temperature = data.readInt16LE(0) / 100;
            
            // 上报温度
            await axios.post('http://server:3001/api/vehicles/temperature', {
              vehicleId: VEHICLE_ID,
              temperature: temperature,
              timestamp: new Date().toISOString()
            });
          });
          
          characteristics[0].subscribe();
        });
      });
    });
  }
});
```

**后端处理**:
```typescript
@Post('vehicles/temperature')
async handleVehicleTemperature(@Body() data: VehicleTemperatureDto) {
  // 1. 记录温度
  await this.vehicleTemperatureService.create(data);
  
  // 2. 检查温度异常
  if (data.temperature < 20 || data.temperature > 80) {
    await this.alarmsService.create({
      alarmType: 'temperature_abnormal',
      severity: 'warning',
      message: `车辆${data.vehicleId}混凝土温度异常: ${data.temperature}℃`
    });
  }
  
  // 3. 实时推送
  this.websocketService.emit('vehicle:temperature', data);
}
```

---

## 六、边缘网关配置

### 6.1 硬件配置

**推荐型号**: 研华 UNO-2483G

**配置**:
- CPU: Intel Core i5
- 内存: 8GB DDR4
- 存储: 128GB SSD
- 网络: 2x Gigabit Ethernet
- 串口: 4x RS232/485
- 工作温度: -20℃ ~ 60℃

### 6.2 软件架构

```typescript
// 边缘网关主程序
import express from 'express';
import mqtt from 'mqtt';
import ModbusRTU from 'modbus-serial';

const app = express();
const mqttClient = mqtt.connect('mqtt://localhost:1883');

// 数据缓存队列
const dataQueue: any[] = [];

// 协议转换服务
class ProtocolConverter {
  // Modbus → HTTP
  async modbusToHttp(modbusData: any) {
    return {
      timestamp: new Date().toISOString(),
      value: modbusData.value,
      unit: modbusData.unit
    };
  }
  
  // MQTT → HTTP
  async mqttToHttp(mqttData: any) {
    return {
      timestamp: new Date().toISOString(),
      ...mqttData
    };
  }
}

// 数据上传服务
class DataUploader {
  async upload(data: any) {
    try {
      await axios.post('http://server:3001/api/data', data);
    } catch (error) {
      // 上传失败，加入队列
      dataQueue.push(data);
    }
  }
  
  // 断网续传
  async retryUpload() {
    while (dataQueue.length > 0) {
      const data = dataQueue.shift();
      try {
        await axios.post('http://server:3001/api/data', data);
      } catch (error) {
        dataQueue.unshift(data);
        break;
      }
    }
  }
}

// 启动服务
app.listen(8080, () => {
  console.log('边缘网关启动成功');
});
```

---

## 七、网络架构

### 7.1 网络拓扑

```
                    [互联网]
                       │
                   [防火墙]
                       │
              ┌────────┴────────┐
              │                 │
          [应用服务器]      [数据库服务器]
              │
        [工业交换机]
              │
    ┌─────────┼─────────┐
    │         │         │
[边缘网关1] [边缘网关2] [边缘网关3]
    │         │         │
[设备组1]  [设备组2]  [设备组3]
```

### 7.2 IP地址规划

| 设备类型 | IP段 | 示例 |
|---------|------|------|
| 服务器 | 192.168.1.1-10 | 192.168.1.1 |
| 边缘网关 | 192.168.1.11-20 | 192.168.1.11 |
| 摄像头 | 192.168.1.100-150 | 192.168.1.100 |
| 传感器 | 192.168.1.151-200 | 192.168.1.151 |
| PLC | 192.168.1.201-220 | 192.168.1.201 |

---

## 八、数据采集频率

| 设备类型 | 采集频率 | 上报频率 | 说明 |
|---------|---------|---------|------|
| 称重传感器 | 1秒 | 稳定后上报 | 重量稳定判断 |
| 激光雷达 | 5分钟 | 5分钟 | 库存变化缓慢 |
| 料位传感器 | 30秒 | 30秒 | 实时监控 |
| 温度传感器 | 30秒 | 30秒 | 温度变化缓慢 |
| AI摄像头 | 10fps | 实时 | 对位引导 |
| GPS定位 | 10秒 | 10秒 | 轨迹跟踪 |

---

## 九、故障处理

### 9.1 设备离线处理

```typescript
// 设备心跳检测
setInterval(async () => {
  const devices = await this.devicesService.findAll();
  
  for (const device of devices) {
    const lastHeartbeat = device.lastHeartbeat;
    const now = Date.now();
    
    if (now - lastHeartbeat > 60000) { // 1分钟无心跳
      // 标记设备离线
      await this.devicesService.update(device.id, {
        status: 'offline'
      });
      
      // 创建告警
      await this.alarmsService.create({
        alarmType: 'device_offline',
        severity: 'critical',
        message: `设备${device.name}离线`
      });
    }
  }
}, 30000);
```

### 9.2 数据异常处理

```typescript
// 数据校验
function validateSensorData(data: any): boolean {
  // 1. 范围检查
  if (data.value < data.minValue || data.value > data.maxValue) {
    return false;
  }
  
  // 2. 变化率检查
  const lastValue = getLastValue(data.sensorId);
  const changeRate = Math.abs(data.value - lastValue) / lastValue;
  if (changeRate > 0.5) { // 变化超过50%
    return false;
  }
  
  // 3. 时间戳检查
  const now = Date.now();
  const dataTime = new Date(data.timestamp).getTime();
  if (Math.abs(now - dataTime) > 60000) { // 时间偏差超过1分钟
    return false;
  }
  
  return true;
}
```

---

## 十、安全措施

### 10.1 网络安全

- **防火墙规则**: 只开放必要端口
- **VPN访问**: 远程维护通过VPN
- **数据加密**: TLS/SSL加密传输
- **访问控制**: IP白名单

### 10.2 设备安全

- **固件更新**: 定期更新设备固件
- **密码策略**: 强密码 + 定期更换
- **物理安全**: 设备加锁 + 监控
- **备份恢复**: 配置备份 + 快速恢复

---

**文档版本**: V1.0  
**最后更新**: 2026年2月5日
