
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model EdgeConfig
 * 
 */
export type EdgeConfig = $Result.DefaultSelection<Prisma.$EdgeConfigPayload>
/**
 * Model DeviceConnection
 * 
 */
export type DeviceConnection = $Result.DefaultSelection<Prisma.$DeviceConnectionPayload>
/**
 * Model DataPoint
 * 
 */
export type DataPoint = $Result.DefaultSelection<Prisma.$DataPointPayload>
/**
 * Model DataHistory
 * 
 */
export type DataHistory = $Result.DefaultSelection<Prisma.$DataHistoryPayload>
/**
 * Model LocalRecipe
 * 
 */
export type LocalRecipe = $Result.DefaultSelection<Prisma.$LocalRecipePayload>
/**
 * Model LocalBatch
 * 
 */
export type LocalBatch = $Result.DefaultSelection<Prisma.$LocalBatchPayload>
/**
 * Model LocalBatchingRecord
 * 
 */
export type LocalBatchingRecord = $Result.DefaultSelection<Prisma.$LocalBatchingRecordPayload>
/**
 * Model LocalAlarm
 * 
 */
export type LocalAlarm = $Result.DefaultSelection<Prisma.$LocalAlarmPayload>
/**
 * Model LocalLog
 * 
 */
export type LocalLog = $Result.DefaultSelection<Prisma.$LocalLogPayload>
/**
 * Model SyncQueue
 * 
 */
export type SyncQueue = $Result.DefaultSelection<Prisma.$SyncQueuePayload>
/**
 * Model SyncStatus
 * 
 */
export type SyncStatus = $Result.DefaultSelection<Prisma.$SyncStatusPayload>
/**
 * Model Recipe
 * 
 */
export type Recipe = $Result.DefaultSelection<Prisma.$RecipePayload>
/**
 * Model ProductionTask
 * 
 */
export type ProductionTask = $Result.DefaultSelection<Prisma.$ProductionTaskPayload>
/**
 * Model ProductionRecord
 * 
 */
export type ProductionRecord = $Result.DefaultSelection<Prisma.$ProductionRecordPayload>
/**
 * Model Alarm
 * 
 */
export type Alarm = $Result.DefaultSelection<Prisma.$AlarmPayload>
/**
 * Model SafetyEvent
 * 
 */
export type SafetyEvent = $Result.DefaultSelection<Prisma.$SafetyEventPayload>
/**
 * Model SafetyRule
 * 
 */
export type SafetyRule = $Result.DefaultSelection<Prisma.$SafetyRulePayload>
/**
 * Model SystemMetrics
 * 
 */
export type SystemMetrics = $Result.DefaultSelection<Prisma.$SystemMetricsPayload>
/**
 * Model EquipmentRuntime
 * 
 */
export type EquipmentRuntime = $Result.DefaultSelection<Prisma.$EquipmentRuntimePayload>
/**
 * Model SystemStatus
 * 
 */
export type SystemStatus = $Result.DefaultSelection<Prisma.$SystemStatusPayload>
/**
 * Model DeviceStats
 * 
 */
export type DeviceStats = $Result.DefaultSelection<Prisma.$DeviceStatsPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more EdgeConfigs
 * const edgeConfigs = await prisma.edgeConfig.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more EdgeConfigs
   * const edgeConfigs = await prisma.edgeConfig.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.edgeConfig`: Exposes CRUD operations for the **EdgeConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EdgeConfigs
    * const edgeConfigs = await prisma.edgeConfig.findMany()
    * ```
    */
  get edgeConfig(): Prisma.EdgeConfigDelegate<ExtArgs>;

  /**
   * `prisma.deviceConnection`: Exposes CRUD operations for the **DeviceConnection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceConnections
    * const deviceConnections = await prisma.deviceConnection.findMany()
    * ```
    */
  get deviceConnection(): Prisma.DeviceConnectionDelegate<ExtArgs>;

  /**
   * `prisma.dataPoint`: Exposes CRUD operations for the **DataPoint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataPoints
    * const dataPoints = await prisma.dataPoint.findMany()
    * ```
    */
  get dataPoint(): Prisma.DataPointDelegate<ExtArgs>;

  /**
   * `prisma.dataHistory`: Exposes CRUD operations for the **DataHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataHistories
    * const dataHistories = await prisma.dataHistory.findMany()
    * ```
    */
  get dataHistory(): Prisma.DataHistoryDelegate<ExtArgs>;

  /**
   * `prisma.localRecipe`: Exposes CRUD operations for the **LocalRecipe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LocalRecipes
    * const localRecipes = await prisma.localRecipe.findMany()
    * ```
    */
  get localRecipe(): Prisma.LocalRecipeDelegate<ExtArgs>;

  /**
   * `prisma.localBatch`: Exposes CRUD operations for the **LocalBatch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LocalBatches
    * const localBatches = await prisma.localBatch.findMany()
    * ```
    */
  get localBatch(): Prisma.LocalBatchDelegate<ExtArgs>;

  /**
   * `prisma.localBatchingRecord`: Exposes CRUD operations for the **LocalBatchingRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LocalBatchingRecords
    * const localBatchingRecords = await prisma.localBatchingRecord.findMany()
    * ```
    */
  get localBatchingRecord(): Prisma.LocalBatchingRecordDelegate<ExtArgs>;

  /**
   * `prisma.localAlarm`: Exposes CRUD operations for the **LocalAlarm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LocalAlarms
    * const localAlarms = await prisma.localAlarm.findMany()
    * ```
    */
  get localAlarm(): Prisma.LocalAlarmDelegate<ExtArgs>;

  /**
   * `prisma.localLog`: Exposes CRUD operations for the **LocalLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LocalLogs
    * const localLogs = await prisma.localLog.findMany()
    * ```
    */
  get localLog(): Prisma.LocalLogDelegate<ExtArgs>;

  /**
   * `prisma.syncQueue`: Exposes CRUD operations for the **SyncQueue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SyncQueues
    * const syncQueues = await prisma.syncQueue.findMany()
    * ```
    */
  get syncQueue(): Prisma.SyncQueueDelegate<ExtArgs>;

  /**
   * `prisma.syncStatus`: Exposes CRUD operations for the **SyncStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SyncStatuses
    * const syncStatuses = await prisma.syncStatus.findMany()
    * ```
    */
  get syncStatus(): Prisma.SyncStatusDelegate<ExtArgs>;

  /**
   * `prisma.recipe`: Exposes CRUD operations for the **Recipe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recipes
    * const recipes = await prisma.recipe.findMany()
    * ```
    */
  get recipe(): Prisma.RecipeDelegate<ExtArgs>;

  /**
   * `prisma.productionTask`: Exposes CRUD operations for the **ProductionTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductionTasks
    * const productionTasks = await prisma.productionTask.findMany()
    * ```
    */
  get productionTask(): Prisma.ProductionTaskDelegate<ExtArgs>;

  /**
   * `prisma.productionRecord`: Exposes CRUD operations for the **ProductionRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductionRecords
    * const productionRecords = await prisma.productionRecord.findMany()
    * ```
    */
  get productionRecord(): Prisma.ProductionRecordDelegate<ExtArgs>;

  /**
   * `prisma.alarm`: Exposes CRUD operations for the **Alarm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alarms
    * const alarms = await prisma.alarm.findMany()
    * ```
    */
  get alarm(): Prisma.AlarmDelegate<ExtArgs>;

  /**
   * `prisma.safetyEvent`: Exposes CRUD operations for the **SafetyEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SafetyEvents
    * const safetyEvents = await prisma.safetyEvent.findMany()
    * ```
    */
  get safetyEvent(): Prisma.SafetyEventDelegate<ExtArgs>;

  /**
   * `prisma.safetyRule`: Exposes CRUD operations for the **SafetyRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SafetyRules
    * const safetyRules = await prisma.safetyRule.findMany()
    * ```
    */
  get safetyRule(): Prisma.SafetyRuleDelegate<ExtArgs>;

  /**
   * `prisma.systemMetrics`: Exposes CRUD operations for the **SystemMetrics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemMetrics
    * const systemMetrics = await prisma.systemMetrics.findMany()
    * ```
    */
  get systemMetrics(): Prisma.SystemMetricsDelegate<ExtArgs>;

  /**
   * `prisma.equipmentRuntime`: Exposes CRUD operations for the **EquipmentRuntime** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EquipmentRuntimes
    * const equipmentRuntimes = await prisma.equipmentRuntime.findMany()
    * ```
    */
  get equipmentRuntime(): Prisma.EquipmentRuntimeDelegate<ExtArgs>;

  /**
   * `prisma.systemStatus`: Exposes CRUD operations for the **SystemStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemStatuses
    * const systemStatuses = await prisma.systemStatus.findMany()
    * ```
    */
  get systemStatus(): Prisma.SystemStatusDelegate<ExtArgs>;

  /**
   * `prisma.deviceStats`: Exposes CRUD operations for the **DeviceStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceStats
    * const deviceStats = await prisma.deviceStats.findMany()
    * ```
    */
  get deviceStats(): Prisma.DeviceStatsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    EdgeConfig: 'EdgeConfig',
    DeviceConnection: 'DeviceConnection',
    DataPoint: 'DataPoint',
    DataHistory: 'DataHistory',
    LocalRecipe: 'LocalRecipe',
    LocalBatch: 'LocalBatch',
    LocalBatchingRecord: 'LocalBatchingRecord',
    LocalAlarm: 'LocalAlarm',
    LocalLog: 'LocalLog',
    SyncQueue: 'SyncQueue',
    SyncStatus: 'SyncStatus',
    Recipe: 'Recipe',
    ProductionTask: 'ProductionTask',
    ProductionRecord: 'ProductionRecord',
    Alarm: 'Alarm',
    SafetyEvent: 'SafetyEvent',
    SafetyRule: 'SafetyRule',
    SystemMetrics: 'SystemMetrics',
    EquipmentRuntime: 'EquipmentRuntime',
    SystemStatus: 'SystemStatus',
    DeviceStats: 'DeviceStats'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "edgeConfig" | "deviceConnection" | "dataPoint" | "dataHistory" | "localRecipe" | "localBatch" | "localBatchingRecord" | "localAlarm" | "localLog" | "syncQueue" | "syncStatus" | "recipe" | "productionTask" | "productionRecord" | "alarm" | "safetyEvent" | "safetyRule" | "systemMetrics" | "equipmentRuntime" | "systemStatus" | "deviceStats"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      EdgeConfig: {
        payload: Prisma.$EdgeConfigPayload<ExtArgs>
        fields: Prisma.EdgeConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EdgeConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EdgeConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EdgeConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EdgeConfigPayload>
          }
          findFirst: {
            args: Prisma.EdgeConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EdgeConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EdgeConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EdgeConfigPayload>
          }
          findMany: {
            args: Prisma.EdgeConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EdgeConfigPayload>[]
          }
          create: {
            args: Prisma.EdgeConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EdgeConfigPayload>
          }
          createMany: {
            args: Prisma.EdgeConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EdgeConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EdgeConfigPayload>[]
          }
          delete: {
            args: Prisma.EdgeConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EdgeConfigPayload>
          }
          update: {
            args: Prisma.EdgeConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EdgeConfigPayload>
          }
          deleteMany: {
            args: Prisma.EdgeConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EdgeConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EdgeConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EdgeConfigPayload>
          }
          aggregate: {
            args: Prisma.EdgeConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEdgeConfig>
          }
          groupBy: {
            args: Prisma.EdgeConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<EdgeConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.EdgeConfigCountArgs<ExtArgs>
            result: $Utils.Optional<EdgeConfigCountAggregateOutputType> | number
          }
        }
      }
      DeviceConnection: {
        payload: Prisma.$DeviceConnectionPayload<ExtArgs>
        fields: Prisma.DeviceConnectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceConnectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceConnectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceConnectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceConnectionPayload>
          }
          findFirst: {
            args: Prisma.DeviceConnectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceConnectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceConnectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceConnectionPayload>
          }
          findMany: {
            args: Prisma.DeviceConnectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceConnectionPayload>[]
          }
          create: {
            args: Prisma.DeviceConnectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceConnectionPayload>
          }
          createMany: {
            args: Prisma.DeviceConnectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceConnectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceConnectionPayload>[]
          }
          delete: {
            args: Prisma.DeviceConnectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceConnectionPayload>
          }
          update: {
            args: Prisma.DeviceConnectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceConnectionPayload>
          }
          deleteMany: {
            args: Prisma.DeviceConnectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceConnectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeviceConnectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceConnectionPayload>
          }
          aggregate: {
            args: Prisma.DeviceConnectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceConnection>
          }
          groupBy: {
            args: Prisma.DeviceConnectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceConnectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceConnectionCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceConnectionCountAggregateOutputType> | number
          }
        }
      }
      DataPoint: {
        payload: Prisma.$DataPointPayload<ExtArgs>
        fields: Prisma.DataPointFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DataPointFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataPointPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DataPointFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataPointPayload>
          }
          findFirst: {
            args: Prisma.DataPointFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataPointPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DataPointFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataPointPayload>
          }
          findMany: {
            args: Prisma.DataPointFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataPointPayload>[]
          }
          create: {
            args: Prisma.DataPointCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataPointPayload>
          }
          createMany: {
            args: Prisma.DataPointCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DataPointCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataPointPayload>[]
          }
          delete: {
            args: Prisma.DataPointDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataPointPayload>
          }
          update: {
            args: Prisma.DataPointUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataPointPayload>
          }
          deleteMany: {
            args: Prisma.DataPointDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DataPointUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DataPointUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataPointPayload>
          }
          aggregate: {
            args: Prisma.DataPointAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataPoint>
          }
          groupBy: {
            args: Prisma.DataPointGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataPointGroupByOutputType>[]
          }
          count: {
            args: Prisma.DataPointCountArgs<ExtArgs>
            result: $Utils.Optional<DataPointCountAggregateOutputType> | number
          }
        }
      }
      DataHistory: {
        payload: Prisma.$DataHistoryPayload<ExtArgs>
        fields: Prisma.DataHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DataHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DataHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataHistoryPayload>
          }
          findFirst: {
            args: Prisma.DataHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DataHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataHistoryPayload>
          }
          findMany: {
            args: Prisma.DataHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataHistoryPayload>[]
          }
          create: {
            args: Prisma.DataHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataHistoryPayload>
          }
          createMany: {
            args: Prisma.DataHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DataHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataHistoryPayload>[]
          }
          delete: {
            args: Prisma.DataHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataHistoryPayload>
          }
          update: {
            args: Prisma.DataHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataHistoryPayload>
          }
          deleteMany: {
            args: Prisma.DataHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DataHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DataHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataHistoryPayload>
          }
          aggregate: {
            args: Prisma.DataHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataHistory>
          }
          groupBy: {
            args: Prisma.DataHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.DataHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<DataHistoryCountAggregateOutputType> | number
          }
        }
      }
      LocalRecipe: {
        payload: Prisma.$LocalRecipePayload<ExtArgs>
        fields: Prisma.LocalRecipeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocalRecipeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalRecipePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocalRecipeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalRecipePayload>
          }
          findFirst: {
            args: Prisma.LocalRecipeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalRecipePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocalRecipeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalRecipePayload>
          }
          findMany: {
            args: Prisma.LocalRecipeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalRecipePayload>[]
          }
          create: {
            args: Prisma.LocalRecipeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalRecipePayload>
          }
          createMany: {
            args: Prisma.LocalRecipeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocalRecipeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalRecipePayload>[]
          }
          delete: {
            args: Prisma.LocalRecipeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalRecipePayload>
          }
          update: {
            args: Prisma.LocalRecipeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalRecipePayload>
          }
          deleteMany: {
            args: Prisma.LocalRecipeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocalRecipeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LocalRecipeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalRecipePayload>
          }
          aggregate: {
            args: Prisma.LocalRecipeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocalRecipe>
          }
          groupBy: {
            args: Prisma.LocalRecipeGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocalRecipeGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocalRecipeCountArgs<ExtArgs>
            result: $Utils.Optional<LocalRecipeCountAggregateOutputType> | number
          }
        }
      }
      LocalBatch: {
        payload: Prisma.$LocalBatchPayload<ExtArgs>
        fields: Prisma.LocalBatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocalBatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalBatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocalBatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalBatchPayload>
          }
          findFirst: {
            args: Prisma.LocalBatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalBatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocalBatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalBatchPayload>
          }
          findMany: {
            args: Prisma.LocalBatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalBatchPayload>[]
          }
          create: {
            args: Prisma.LocalBatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalBatchPayload>
          }
          createMany: {
            args: Prisma.LocalBatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocalBatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalBatchPayload>[]
          }
          delete: {
            args: Prisma.LocalBatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalBatchPayload>
          }
          update: {
            args: Prisma.LocalBatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalBatchPayload>
          }
          deleteMany: {
            args: Prisma.LocalBatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocalBatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LocalBatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalBatchPayload>
          }
          aggregate: {
            args: Prisma.LocalBatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocalBatch>
          }
          groupBy: {
            args: Prisma.LocalBatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocalBatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocalBatchCountArgs<ExtArgs>
            result: $Utils.Optional<LocalBatchCountAggregateOutputType> | number
          }
        }
      }
      LocalBatchingRecord: {
        payload: Prisma.$LocalBatchingRecordPayload<ExtArgs>
        fields: Prisma.LocalBatchingRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocalBatchingRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalBatchingRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocalBatchingRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalBatchingRecordPayload>
          }
          findFirst: {
            args: Prisma.LocalBatchingRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalBatchingRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocalBatchingRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalBatchingRecordPayload>
          }
          findMany: {
            args: Prisma.LocalBatchingRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalBatchingRecordPayload>[]
          }
          create: {
            args: Prisma.LocalBatchingRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalBatchingRecordPayload>
          }
          createMany: {
            args: Prisma.LocalBatchingRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocalBatchingRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalBatchingRecordPayload>[]
          }
          delete: {
            args: Prisma.LocalBatchingRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalBatchingRecordPayload>
          }
          update: {
            args: Prisma.LocalBatchingRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalBatchingRecordPayload>
          }
          deleteMany: {
            args: Prisma.LocalBatchingRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocalBatchingRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LocalBatchingRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalBatchingRecordPayload>
          }
          aggregate: {
            args: Prisma.LocalBatchingRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocalBatchingRecord>
          }
          groupBy: {
            args: Prisma.LocalBatchingRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocalBatchingRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocalBatchingRecordCountArgs<ExtArgs>
            result: $Utils.Optional<LocalBatchingRecordCountAggregateOutputType> | number
          }
        }
      }
      LocalAlarm: {
        payload: Prisma.$LocalAlarmPayload<ExtArgs>
        fields: Prisma.LocalAlarmFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocalAlarmFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalAlarmPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocalAlarmFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalAlarmPayload>
          }
          findFirst: {
            args: Prisma.LocalAlarmFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalAlarmPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocalAlarmFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalAlarmPayload>
          }
          findMany: {
            args: Prisma.LocalAlarmFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalAlarmPayload>[]
          }
          create: {
            args: Prisma.LocalAlarmCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalAlarmPayload>
          }
          createMany: {
            args: Prisma.LocalAlarmCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocalAlarmCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalAlarmPayload>[]
          }
          delete: {
            args: Prisma.LocalAlarmDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalAlarmPayload>
          }
          update: {
            args: Prisma.LocalAlarmUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalAlarmPayload>
          }
          deleteMany: {
            args: Prisma.LocalAlarmDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocalAlarmUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LocalAlarmUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalAlarmPayload>
          }
          aggregate: {
            args: Prisma.LocalAlarmAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocalAlarm>
          }
          groupBy: {
            args: Prisma.LocalAlarmGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocalAlarmGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocalAlarmCountArgs<ExtArgs>
            result: $Utils.Optional<LocalAlarmCountAggregateOutputType> | number
          }
        }
      }
      LocalLog: {
        payload: Prisma.$LocalLogPayload<ExtArgs>
        fields: Prisma.LocalLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocalLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocalLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalLogPayload>
          }
          findFirst: {
            args: Prisma.LocalLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocalLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalLogPayload>
          }
          findMany: {
            args: Prisma.LocalLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalLogPayload>[]
          }
          create: {
            args: Prisma.LocalLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalLogPayload>
          }
          createMany: {
            args: Prisma.LocalLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocalLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalLogPayload>[]
          }
          delete: {
            args: Prisma.LocalLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalLogPayload>
          }
          update: {
            args: Prisma.LocalLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalLogPayload>
          }
          deleteMany: {
            args: Prisma.LocalLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocalLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LocalLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalLogPayload>
          }
          aggregate: {
            args: Prisma.LocalLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocalLog>
          }
          groupBy: {
            args: Prisma.LocalLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocalLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocalLogCountArgs<ExtArgs>
            result: $Utils.Optional<LocalLogCountAggregateOutputType> | number
          }
        }
      }
      SyncQueue: {
        payload: Prisma.$SyncQueuePayload<ExtArgs>
        fields: Prisma.SyncQueueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SyncQueueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncQueuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SyncQueueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncQueuePayload>
          }
          findFirst: {
            args: Prisma.SyncQueueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncQueuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SyncQueueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncQueuePayload>
          }
          findMany: {
            args: Prisma.SyncQueueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncQueuePayload>[]
          }
          create: {
            args: Prisma.SyncQueueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncQueuePayload>
          }
          createMany: {
            args: Prisma.SyncQueueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SyncQueueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncQueuePayload>[]
          }
          delete: {
            args: Prisma.SyncQueueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncQueuePayload>
          }
          update: {
            args: Prisma.SyncQueueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncQueuePayload>
          }
          deleteMany: {
            args: Prisma.SyncQueueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SyncQueueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SyncQueueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncQueuePayload>
          }
          aggregate: {
            args: Prisma.SyncQueueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSyncQueue>
          }
          groupBy: {
            args: Prisma.SyncQueueGroupByArgs<ExtArgs>
            result: $Utils.Optional<SyncQueueGroupByOutputType>[]
          }
          count: {
            args: Prisma.SyncQueueCountArgs<ExtArgs>
            result: $Utils.Optional<SyncQueueCountAggregateOutputType> | number
          }
        }
      }
      SyncStatus: {
        payload: Prisma.$SyncStatusPayload<ExtArgs>
        fields: Prisma.SyncStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SyncStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SyncStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncStatusPayload>
          }
          findFirst: {
            args: Prisma.SyncStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SyncStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncStatusPayload>
          }
          findMany: {
            args: Prisma.SyncStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncStatusPayload>[]
          }
          create: {
            args: Prisma.SyncStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncStatusPayload>
          }
          createMany: {
            args: Prisma.SyncStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SyncStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncStatusPayload>[]
          }
          delete: {
            args: Prisma.SyncStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncStatusPayload>
          }
          update: {
            args: Prisma.SyncStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncStatusPayload>
          }
          deleteMany: {
            args: Prisma.SyncStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SyncStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SyncStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncStatusPayload>
          }
          aggregate: {
            args: Prisma.SyncStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSyncStatus>
          }
          groupBy: {
            args: Prisma.SyncStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<SyncStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.SyncStatusCountArgs<ExtArgs>
            result: $Utils.Optional<SyncStatusCountAggregateOutputType> | number
          }
        }
      }
      Recipe: {
        payload: Prisma.$RecipePayload<ExtArgs>
        fields: Prisma.RecipeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          findFirst: {
            args: Prisma.RecipeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          findMany: {
            args: Prisma.RecipeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>[]
          }
          create: {
            args: Prisma.RecipeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          createMany: {
            args: Prisma.RecipeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecipeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>[]
          }
          delete: {
            args: Prisma.RecipeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          update: {
            args: Prisma.RecipeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          deleteMany: {
            args: Prisma.RecipeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RecipeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          aggregate: {
            args: Prisma.RecipeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecipe>
          }
          groupBy: {
            args: Prisma.RecipeGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecipeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeCountArgs<ExtArgs>
            result: $Utils.Optional<RecipeCountAggregateOutputType> | number
          }
        }
      }
      ProductionTask: {
        payload: Prisma.$ProductionTaskPayload<ExtArgs>
        fields: Prisma.ProductionTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductionTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductionTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionTaskPayload>
          }
          findFirst: {
            args: Prisma.ProductionTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductionTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionTaskPayload>
          }
          findMany: {
            args: Prisma.ProductionTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionTaskPayload>[]
          }
          create: {
            args: Prisma.ProductionTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionTaskPayload>
          }
          createMany: {
            args: Prisma.ProductionTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductionTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionTaskPayload>[]
          }
          delete: {
            args: Prisma.ProductionTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionTaskPayload>
          }
          update: {
            args: Prisma.ProductionTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionTaskPayload>
          }
          deleteMany: {
            args: Prisma.ProductionTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductionTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductionTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionTaskPayload>
          }
          aggregate: {
            args: Prisma.ProductionTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductionTask>
          }
          groupBy: {
            args: Prisma.ProductionTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductionTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductionTaskCountArgs<ExtArgs>
            result: $Utils.Optional<ProductionTaskCountAggregateOutputType> | number
          }
        }
      }
      ProductionRecord: {
        payload: Prisma.$ProductionRecordPayload<ExtArgs>
        fields: Prisma.ProductionRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductionRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductionRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRecordPayload>
          }
          findFirst: {
            args: Prisma.ProductionRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductionRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRecordPayload>
          }
          findMany: {
            args: Prisma.ProductionRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRecordPayload>[]
          }
          create: {
            args: Prisma.ProductionRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRecordPayload>
          }
          createMany: {
            args: Prisma.ProductionRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductionRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRecordPayload>[]
          }
          delete: {
            args: Prisma.ProductionRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRecordPayload>
          }
          update: {
            args: Prisma.ProductionRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRecordPayload>
          }
          deleteMany: {
            args: Prisma.ProductionRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductionRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductionRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductionRecordPayload>
          }
          aggregate: {
            args: Prisma.ProductionRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductionRecord>
          }
          groupBy: {
            args: Prisma.ProductionRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductionRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductionRecordCountArgs<ExtArgs>
            result: $Utils.Optional<ProductionRecordCountAggregateOutputType> | number
          }
        }
      }
      Alarm: {
        payload: Prisma.$AlarmPayload<ExtArgs>
        fields: Prisma.AlarmFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlarmFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlarmFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmPayload>
          }
          findFirst: {
            args: Prisma.AlarmFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlarmFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmPayload>
          }
          findMany: {
            args: Prisma.AlarmFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmPayload>[]
          }
          create: {
            args: Prisma.AlarmCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmPayload>
          }
          createMany: {
            args: Prisma.AlarmCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlarmCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmPayload>[]
          }
          delete: {
            args: Prisma.AlarmDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmPayload>
          }
          update: {
            args: Prisma.AlarmUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmPayload>
          }
          deleteMany: {
            args: Prisma.AlarmDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlarmUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AlarmUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlarmPayload>
          }
          aggregate: {
            args: Prisma.AlarmAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlarm>
          }
          groupBy: {
            args: Prisma.AlarmGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlarmGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlarmCountArgs<ExtArgs>
            result: $Utils.Optional<AlarmCountAggregateOutputType> | number
          }
        }
      }
      SafetyEvent: {
        payload: Prisma.$SafetyEventPayload<ExtArgs>
        fields: Prisma.SafetyEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SafetyEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SafetyEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyEventPayload>
          }
          findFirst: {
            args: Prisma.SafetyEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SafetyEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyEventPayload>
          }
          findMany: {
            args: Prisma.SafetyEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyEventPayload>[]
          }
          create: {
            args: Prisma.SafetyEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyEventPayload>
          }
          createMany: {
            args: Prisma.SafetyEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SafetyEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyEventPayload>[]
          }
          delete: {
            args: Prisma.SafetyEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyEventPayload>
          }
          update: {
            args: Prisma.SafetyEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyEventPayload>
          }
          deleteMany: {
            args: Prisma.SafetyEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SafetyEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SafetyEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyEventPayload>
          }
          aggregate: {
            args: Prisma.SafetyEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSafetyEvent>
          }
          groupBy: {
            args: Prisma.SafetyEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<SafetyEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.SafetyEventCountArgs<ExtArgs>
            result: $Utils.Optional<SafetyEventCountAggregateOutputType> | number
          }
        }
      }
      SafetyRule: {
        payload: Prisma.$SafetyRulePayload<ExtArgs>
        fields: Prisma.SafetyRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SafetyRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SafetyRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyRulePayload>
          }
          findFirst: {
            args: Prisma.SafetyRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SafetyRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyRulePayload>
          }
          findMany: {
            args: Prisma.SafetyRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyRulePayload>[]
          }
          create: {
            args: Prisma.SafetyRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyRulePayload>
          }
          createMany: {
            args: Prisma.SafetyRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SafetyRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyRulePayload>[]
          }
          delete: {
            args: Prisma.SafetyRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyRulePayload>
          }
          update: {
            args: Prisma.SafetyRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyRulePayload>
          }
          deleteMany: {
            args: Prisma.SafetyRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SafetyRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SafetyRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SafetyRulePayload>
          }
          aggregate: {
            args: Prisma.SafetyRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSafetyRule>
          }
          groupBy: {
            args: Prisma.SafetyRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<SafetyRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.SafetyRuleCountArgs<ExtArgs>
            result: $Utils.Optional<SafetyRuleCountAggregateOutputType> | number
          }
        }
      }
      SystemMetrics: {
        payload: Prisma.$SystemMetricsPayload<ExtArgs>
        fields: Prisma.SystemMetricsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemMetricsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemMetricsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricsPayload>
          }
          findFirst: {
            args: Prisma.SystemMetricsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemMetricsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricsPayload>
          }
          findMany: {
            args: Prisma.SystemMetricsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricsPayload>[]
          }
          create: {
            args: Prisma.SystemMetricsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricsPayload>
          }
          createMany: {
            args: Prisma.SystemMetricsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemMetricsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricsPayload>[]
          }
          delete: {
            args: Prisma.SystemMetricsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricsPayload>
          }
          update: {
            args: Prisma.SystemMetricsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricsPayload>
          }
          deleteMany: {
            args: Prisma.SystemMetricsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemMetricsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemMetricsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemMetricsPayload>
          }
          aggregate: {
            args: Prisma.SystemMetricsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemMetrics>
          }
          groupBy: {
            args: Prisma.SystemMetricsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemMetricsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemMetricsCountArgs<ExtArgs>
            result: $Utils.Optional<SystemMetricsCountAggregateOutputType> | number
          }
        }
      }
      EquipmentRuntime: {
        payload: Prisma.$EquipmentRuntimePayload<ExtArgs>
        fields: Prisma.EquipmentRuntimeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipmentRuntimeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentRuntimePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipmentRuntimeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentRuntimePayload>
          }
          findFirst: {
            args: Prisma.EquipmentRuntimeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentRuntimePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipmentRuntimeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentRuntimePayload>
          }
          findMany: {
            args: Prisma.EquipmentRuntimeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentRuntimePayload>[]
          }
          create: {
            args: Prisma.EquipmentRuntimeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentRuntimePayload>
          }
          createMany: {
            args: Prisma.EquipmentRuntimeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EquipmentRuntimeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentRuntimePayload>[]
          }
          delete: {
            args: Prisma.EquipmentRuntimeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentRuntimePayload>
          }
          update: {
            args: Prisma.EquipmentRuntimeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentRuntimePayload>
          }
          deleteMany: {
            args: Prisma.EquipmentRuntimeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipmentRuntimeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EquipmentRuntimeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentRuntimePayload>
          }
          aggregate: {
            args: Prisma.EquipmentRuntimeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipmentRuntime>
          }
          groupBy: {
            args: Prisma.EquipmentRuntimeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipmentRuntimeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquipmentRuntimeCountArgs<ExtArgs>
            result: $Utils.Optional<EquipmentRuntimeCountAggregateOutputType> | number
          }
        }
      }
      SystemStatus: {
        payload: Prisma.$SystemStatusPayload<ExtArgs>
        fields: Prisma.SystemStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemStatusPayload>
          }
          findFirst: {
            args: Prisma.SystemStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemStatusPayload>
          }
          findMany: {
            args: Prisma.SystemStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemStatusPayload>[]
          }
          create: {
            args: Prisma.SystemStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemStatusPayload>
          }
          createMany: {
            args: Prisma.SystemStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemStatusPayload>[]
          }
          delete: {
            args: Prisma.SystemStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemStatusPayload>
          }
          update: {
            args: Prisma.SystemStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemStatusPayload>
          }
          deleteMany: {
            args: Prisma.SystemStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemStatusPayload>
          }
          aggregate: {
            args: Prisma.SystemStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemStatus>
          }
          groupBy: {
            args: Prisma.SystemStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemStatusCountArgs<ExtArgs>
            result: $Utils.Optional<SystemStatusCountAggregateOutputType> | number
          }
        }
      }
      DeviceStats: {
        payload: Prisma.$DeviceStatsPayload<ExtArgs>
        fields: Prisma.DeviceStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceStatsPayload>
          }
          findFirst: {
            args: Prisma.DeviceStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceStatsPayload>
          }
          findMany: {
            args: Prisma.DeviceStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceStatsPayload>[]
          }
          create: {
            args: Prisma.DeviceStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceStatsPayload>
          }
          createMany: {
            args: Prisma.DeviceStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceStatsPayload>[]
          }
          delete: {
            args: Prisma.DeviceStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceStatsPayload>
          }
          update: {
            args: Prisma.DeviceStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceStatsPayload>
          }
          deleteMany: {
            args: Prisma.DeviceStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeviceStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceStatsPayload>
          }
          aggregate: {
            args: Prisma.DeviceStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceStats>
          }
          groupBy: {
            args: Prisma.DeviceStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceStatsCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceStatsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type DataPointCountOutputType
   */

  export type DataPointCountOutputType = {
    history: number
  }

  export type DataPointCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    history?: boolean | DataPointCountOutputTypeCountHistoryArgs
  }

  // Custom InputTypes
  /**
   * DataPointCountOutputType without action
   */
  export type DataPointCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataPointCountOutputType
     */
    select?: DataPointCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DataPointCountOutputType without action
   */
  export type DataPointCountOutputTypeCountHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataHistoryWhereInput
  }


  /**
   * Count Type LocalRecipeCountOutputType
   */

  export type LocalRecipeCountOutputType = {
    batches: number
  }

  export type LocalRecipeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batches?: boolean | LocalRecipeCountOutputTypeCountBatchesArgs
  }

  // Custom InputTypes
  /**
   * LocalRecipeCountOutputType without action
   */
  export type LocalRecipeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalRecipeCountOutputType
     */
    select?: LocalRecipeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocalRecipeCountOutputType without action
   */
  export type LocalRecipeCountOutputTypeCountBatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocalBatchWhereInput
  }


  /**
   * Count Type LocalBatchCountOutputType
   */

  export type LocalBatchCountOutputType = {
    batchingRecords: number
  }

  export type LocalBatchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batchingRecords?: boolean | LocalBatchCountOutputTypeCountBatchingRecordsArgs
  }

  // Custom InputTypes
  /**
   * LocalBatchCountOutputType without action
   */
  export type LocalBatchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalBatchCountOutputType
     */
    select?: LocalBatchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocalBatchCountOutputType without action
   */
  export type LocalBatchCountOutputTypeCountBatchingRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocalBatchingRecordWhereInput
  }


  /**
   * Count Type RecipeCountOutputType
   */

  export type RecipeCountOutputType = {
    productionTasks: number
  }

  export type RecipeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionTasks?: boolean | RecipeCountOutputTypeCountProductionTasksArgs
  }

  // Custom InputTypes
  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeCountOutputType
     */
    select?: RecipeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountProductionTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionTaskWhereInput
  }


  /**
   * Count Type ProductionTaskCountOutputType
   */

  export type ProductionTaskCountOutputType = {
    productionRecords: number
  }

  export type ProductionTaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionRecords?: boolean | ProductionTaskCountOutputTypeCountProductionRecordsArgs
  }

  // Custom InputTypes
  /**
   * ProductionTaskCountOutputType without action
   */
  export type ProductionTaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTaskCountOutputType
     */
    select?: ProductionTaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductionTaskCountOutputType without action
   */
  export type ProductionTaskCountOutputTypeCountProductionRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionRecordWhereInput
  }


  /**
   * Models
   */

  /**
   * Model EdgeConfig
   */

  export type AggregateEdgeConfig = {
    _count: EdgeConfigCountAggregateOutputType | null
    _avg: EdgeConfigAvgAggregateOutputType | null
    _sum: EdgeConfigSumAggregateOutputType | null
    _min: EdgeConfigMinAggregateOutputType | null
    _max: EdgeConfigMaxAggregateOutputType | null
  }

  export type EdgeConfigAvgAggregateOutputType = {
    id: number | null
  }

  export type EdgeConfigSumAggregateOutputType = {
    id: number | null
  }

  export type EdgeConfigMinAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
    description: string | null
    updatedAt: Date | null
  }

  export type EdgeConfigMaxAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
    description: string | null
    updatedAt: Date | null
  }

  export type EdgeConfigCountAggregateOutputType = {
    id: number
    key: number
    value: number
    description: number
    updatedAt: number
    _all: number
  }


  export type EdgeConfigAvgAggregateInputType = {
    id?: true
  }

  export type EdgeConfigSumAggregateInputType = {
    id?: true
  }

  export type EdgeConfigMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    updatedAt?: true
  }

  export type EdgeConfigMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    updatedAt?: true
  }

  export type EdgeConfigCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    updatedAt?: true
    _all?: true
  }

  export type EdgeConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EdgeConfig to aggregate.
     */
    where?: EdgeConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EdgeConfigs to fetch.
     */
    orderBy?: EdgeConfigOrderByWithRelationInput | EdgeConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EdgeConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EdgeConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EdgeConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EdgeConfigs
    **/
    _count?: true | EdgeConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EdgeConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EdgeConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EdgeConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EdgeConfigMaxAggregateInputType
  }

  export type GetEdgeConfigAggregateType<T extends EdgeConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateEdgeConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEdgeConfig[P]>
      : GetScalarType<T[P], AggregateEdgeConfig[P]>
  }




  export type EdgeConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EdgeConfigWhereInput
    orderBy?: EdgeConfigOrderByWithAggregationInput | EdgeConfigOrderByWithAggregationInput[]
    by: EdgeConfigScalarFieldEnum[] | EdgeConfigScalarFieldEnum
    having?: EdgeConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EdgeConfigCountAggregateInputType | true
    _avg?: EdgeConfigAvgAggregateInputType
    _sum?: EdgeConfigSumAggregateInputType
    _min?: EdgeConfigMinAggregateInputType
    _max?: EdgeConfigMaxAggregateInputType
  }

  export type EdgeConfigGroupByOutputType = {
    id: number
    key: string
    value: string
    description: string | null
    updatedAt: Date
    _count: EdgeConfigCountAggregateOutputType | null
    _avg: EdgeConfigAvgAggregateOutputType | null
    _sum: EdgeConfigSumAggregateOutputType | null
    _min: EdgeConfigMinAggregateOutputType | null
    _max: EdgeConfigMaxAggregateOutputType | null
  }

  type GetEdgeConfigGroupByPayload<T extends EdgeConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EdgeConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EdgeConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EdgeConfigGroupByOutputType[P]>
            : GetScalarType<T[P], EdgeConfigGroupByOutputType[P]>
        }
      >
    >


  export type EdgeConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["edgeConfig"]>

  export type EdgeConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["edgeConfig"]>

  export type EdgeConfigSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
  }


  export type $EdgeConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EdgeConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      key: string
      value: string
      description: string | null
      updatedAt: Date
    }, ExtArgs["result"]["edgeConfig"]>
    composites: {}
  }

  type EdgeConfigGetPayload<S extends boolean | null | undefined | EdgeConfigDefaultArgs> = $Result.GetResult<Prisma.$EdgeConfigPayload, S>

  type EdgeConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EdgeConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EdgeConfigCountAggregateInputType | true
    }

  export interface EdgeConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EdgeConfig'], meta: { name: 'EdgeConfig' } }
    /**
     * Find zero or one EdgeConfig that matches the filter.
     * @param {EdgeConfigFindUniqueArgs} args - Arguments to find a EdgeConfig
     * @example
     * // Get one EdgeConfig
     * const edgeConfig = await prisma.edgeConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EdgeConfigFindUniqueArgs>(args: SelectSubset<T, EdgeConfigFindUniqueArgs<ExtArgs>>): Prisma__EdgeConfigClient<$Result.GetResult<Prisma.$EdgeConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EdgeConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EdgeConfigFindUniqueOrThrowArgs} args - Arguments to find a EdgeConfig
     * @example
     * // Get one EdgeConfig
     * const edgeConfig = await prisma.edgeConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EdgeConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, EdgeConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EdgeConfigClient<$Result.GetResult<Prisma.$EdgeConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EdgeConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EdgeConfigFindFirstArgs} args - Arguments to find a EdgeConfig
     * @example
     * // Get one EdgeConfig
     * const edgeConfig = await prisma.edgeConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EdgeConfigFindFirstArgs>(args?: SelectSubset<T, EdgeConfigFindFirstArgs<ExtArgs>>): Prisma__EdgeConfigClient<$Result.GetResult<Prisma.$EdgeConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EdgeConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EdgeConfigFindFirstOrThrowArgs} args - Arguments to find a EdgeConfig
     * @example
     * // Get one EdgeConfig
     * const edgeConfig = await prisma.edgeConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EdgeConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, EdgeConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__EdgeConfigClient<$Result.GetResult<Prisma.$EdgeConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EdgeConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EdgeConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EdgeConfigs
     * const edgeConfigs = await prisma.edgeConfig.findMany()
     * 
     * // Get first 10 EdgeConfigs
     * const edgeConfigs = await prisma.edgeConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const edgeConfigWithIdOnly = await prisma.edgeConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EdgeConfigFindManyArgs>(args?: SelectSubset<T, EdgeConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EdgeConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EdgeConfig.
     * @param {EdgeConfigCreateArgs} args - Arguments to create a EdgeConfig.
     * @example
     * // Create one EdgeConfig
     * const EdgeConfig = await prisma.edgeConfig.create({
     *   data: {
     *     // ... data to create a EdgeConfig
     *   }
     * })
     * 
     */
    create<T extends EdgeConfigCreateArgs>(args: SelectSubset<T, EdgeConfigCreateArgs<ExtArgs>>): Prisma__EdgeConfigClient<$Result.GetResult<Prisma.$EdgeConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EdgeConfigs.
     * @param {EdgeConfigCreateManyArgs} args - Arguments to create many EdgeConfigs.
     * @example
     * // Create many EdgeConfigs
     * const edgeConfig = await prisma.edgeConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EdgeConfigCreateManyArgs>(args?: SelectSubset<T, EdgeConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EdgeConfigs and returns the data saved in the database.
     * @param {EdgeConfigCreateManyAndReturnArgs} args - Arguments to create many EdgeConfigs.
     * @example
     * // Create many EdgeConfigs
     * const edgeConfig = await prisma.edgeConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EdgeConfigs and only return the `id`
     * const edgeConfigWithIdOnly = await prisma.edgeConfig.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EdgeConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, EdgeConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EdgeConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EdgeConfig.
     * @param {EdgeConfigDeleteArgs} args - Arguments to delete one EdgeConfig.
     * @example
     * // Delete one EdgeConfig
     * const EdgeConfig = await prisma.edgeConfig.delete({
     *   where: {
     *     // ... filter to delete one EdgeConfig
     *   }
     * })
     * 
     */
    delete<T extends EdgeConfigDeleteArgs>(args: SelectSubset<T, EdgeConfigDeleteArgs<ExtArgs>>): Prisma__EdgeConfigClient<$Result.GetResult<Prisma.$EdgeConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EdgeConfig.
     * @param {EdgeConfigUpdateArgs} args - Arguments to update one EdgeConfig.
     * @example
     * // Update one EdgeConfig
     * const edgeConfig = await prisma.edgeConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EdgeConfigUpdateArgs>(args: SelectSubset<T, EdgeConfigUpdateArgs<ExtArgs>>): Prisma__EdgeConfigClient<$Result.GetResult<Prisma.$EdgeConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EdgeConfigs.
     * @param {EdgeConfigDeleteManyArgs} args - Arguments to filter EdgeConfigs to delete.
     * @example
     * // Delete a few EdgeConfigs
     * const { count } = await prisma.edgeConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EdgeConfigDeleteManyArgs>(args?: SelectSubset<T, EdgeConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EdgeConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EdgeConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EdgeConfigs
     * const edgeConfig = await prisma.edgeConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EdgeConfigUpdateManyArgs>(args: SelectSubset<T, EdgeConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EdgeConfig.
     * @param {EdgeConfigUpsertArgs} args - Arguments to update or create a EdgeConfig.
     * @example
     * // Update or create a EdgeConfig
     * const edgeConfig = await prisma.edgeConfig.upsert({
     *   create: {
     *     // ... data to create a EdgeConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EdgeConfig we want to update
     *   }
     * })
     */
    upsert<T extends EdgeConfigUpsertArgs>(args: SelectSubset<T, EdgeConfigUpsertArgs<ExtArgs>>): Prisma__EdgeConfigClient<$Result.GetResult<Prisma.$EdgeConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EdgeConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EdgeConfigCountArgs} args - Arguments to filter EdgeConfigs to count.
     * @example
     * // Count the number of EdgeConfigs
     * const count = await prisma.edgeConfig.count({
     *   where: {
     *     // ... the filter for the EdgeConfigs we want to count
     *   }
     * })
    **/
    count<T extends EdgeConfigCountArgs>(
      args?: Subset<T, EdgeConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EdgeConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EdgeConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EdgeConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EdgeConfigAggregateArgs>(args: Subset<T, EdgeConfigAggregateArgs>): Prisma.PrismaPromise<GetEdgeConfigAggregateType<T>>

    /**
     * Group by EdgeConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EdgeConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EdgeConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EdgeConfigGroupByArgs['orderBy'] }
        : { orderBy?: EdgeConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EdgeConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEdgeConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EdgeConfig model
   */
  readonly fields: EdgeConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EdgeConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EdgeConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EdgeConfig model
   */ 
  interface EdgeConfigFieldRefs {
    readonly id: FieldRef<"EdgeConfig", 'Int'>
    readonly key: FieldRef<"EdgeConfig", 'String'>
    readonly value: FieldRef<"EdgeConfig", 'String'>
    readonly description: FieldRef<"EdgeConfig", 'String'>
    readonly updatedAt: FieldRef<"EdgeConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EdgeConfig findUnique
   */
  export type EdgeConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EdgeConfig
     */
    select?: EdgeConfigSelect<ExtArgs> | null
    /**
     * Filter, which EdgeConfig to fetch.
     */
    where: EdgeConfigWhereUniqueInput
  }

  /**
   * EdgeConfig findUniqueOrThrow
   */
  export type EdgeConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EdgeConfig
     */
    select?: EdgeConfigSelect<ExtArgs> | null
    /**
     * Filter, which EdgeConfig to fetch.
     */
    where: EdgeConfigWhereUniqueInput
  }

  /**
   * EdgeConfig findFirst
   */
  export type EdgeConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EdgeConfig
     */
    select?: EdgeConfigSelect<ExtArgs> | null
    /**
     * Filter, which EdgeConfig to fetch.
     */
    where?: EdgeConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EdgeConfigs to fetch.
     */
    orderBy?: EdgeConfigOrderByWithRelationInput | EdgeConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EdgeConfigs.
     */
    cursor?: EdgeConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EdgeConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EdgeConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EdgeConfigs.
     */
    distinct?: EdgeConfigScalarFieldEnum | EdgeConfigScalarFieldEnum[]
  }

  /**
   * EdgeConfig findFirstOrThrow
   */
  export type EdgeConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EdgeConfig
     */
    select?: EdgeConfigSelect<ExtArgs> | null
    /**
     * Filter, which EdgeConfig to fetch.
     */
    where?: EdgeConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EdgeConfigs to fetch.
     */
    orderBy?: EdgeConfigOrderByWithRelationInput | EdgeConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EdgeConfigs.
     */
    cursor?: EdgeConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EdgeConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EdgeConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EdgeConfigs.
     */
    distinct?: EdgeConfigScalarFieldEnum | EdgeConfigScalarFieldEnum[]
  }

  /**
   * EdgeConfig findMany
   */
  export type EdgeConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EdgeConfig
     */
    select?: EdgeConfigSelect<ExtArgs> | null
    /**
     * Filter, which EdgeConfigs to fetch.
     */
    where?: EdgeConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EdgeConfigs to fetch.
     */
    orderBy?: EdgeConfigOrderByWithRelationInput | EdgeConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EdgeConfigs.
     */
    cursor?: EdgeConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EdgeConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EdgeConfigs.
     */
    skip?: number
    distinct?: EdgeConfigScalarFieldEnum | EdgeConfigScalarFieldEnum[]
  }

  /**
   * EdgeConfig create
   */
  export type EdgeConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EdgeConfig
     */
    select?: EdgeConfigSelect<ExtArgs> | null
    /**
     * The data needed to create a EdgeConfig.
     */
    data: XOR<EdgeConfigCreateInput, EdgeConfigUncheckedCreateInput>
  }

  /**
   * EdgeConfig createMany
   */
  export type EdgeConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EdgeConfigs.
     */
    data: EdgeConfigCreateManyInput | EdgeConfigCreateManyInput[]
  }

  /**
   * EdgeConfig createManyAndReturn
   */
  export type EdgeConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EdgeConfig
     */
    select?: EdgeConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EdgeConfigs.
     */
    data: EdgeConfigCreateManyInput | EdgeConfigCreateManyInput[]
  }

  /**
   * EdgeConfig update
   */
  export type EdgeConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EdgeConfig
     */
    select?: EdgeConfigSelect<ExtArgs> | null
    /**
     * The data needed to update a EdgeConfig.
     */
    data: XOR<EdgeConfigUpdateInput, EdgeConfigUncheckedUpdateInput>
    /**
     * Choose, which EdgeConfig to update.
     */
    where: EdgeConfigWhereUniqueInput
  }

  /**
   * EdgeConfig updateMany
   */
  export type EdgeConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EdgeConfigs.
     */
    data: XOR<EdgeConfigUpdateManyMutationInput, EdgeConfigUncheckedUpdateManyInput>
    /**
     * Filter which EdgeConfigs to update
     */
    where?: EdgeConfigWhereInput
  }

  /**
   * EdgeConfig upsert
   */
  export type EdgeConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EdgeConfig
     */
    select?: EdgeConfigSelect<ExtArgs> | null
    /**
     * The filter to search for the EdgeConfig to update in case it exists.
     */
    where: EdgeConfigWhereUniqueInput
    /**
     * In case the EdgeConfig found by the `where` argument doesn't exist, create a new EdgeConfig with this data.
     */
    create: XOR<EdgeConfigCreateInput, EdgeConfigUncheckedCreateInput>
    /**
     * In case the EdgeConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EdgeConfigUpdateInput, EdgeConfigUncheckedUpdateInput>
  }

  /**
   * EdgeConfig delete
   */
  export type EdgeConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EdgeConfig
     */
    select?: EdgeConfigSelect<ExtArgs> | null
    /**
     * Filter which EdgeConfig to delete.
     */
    where: EdgeConfigWhereUniqueInput
  }

  /**
   * EdgeConfig deleteMany
   */
  export type EdgeConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EdgeConfigs to delete
     */
    where?: EdgeConfigWhereInput
  }

  /**
   * EdgeConfig without action
   */
  export type EdgeConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EdgeConfig
     */
    select?: EdgeConfigSelect<ExtArgs> | null
  }


  /**
   * Model DeviceConnection
   */

  export type AggregateDeviceConnection = {
    _count: DeviceConnectionCountAggregateOutputType | null
    _avg: DeviceConnectionAvgAggregateOutputType | null
    _sum: DeviceConnectionSumAggregateOutputType | null
    _min: DeviceConnectionMinAggregateOutputType | null
    _max: DeviceConnectionMaxAggregateOutputType | null
  }

  export type DeviceConnectionAvgAggregateOutputType = {
    id: number | null
    port: number | null
  }

  export type DeviceConnectionSumAggregateOutputType = {
    id: number | null
    port: number | null
  }

  export type DeviceConnectionMinAggregateOutputType = {
    id: number | null
    deviceType: string | null
    deviceId: string | null
    host: string | null
    port: number | null
    status: string | null
    lastConnect: Date | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeviceConnectionMaxAggregateOutputType = {
    id: number | null
    deviceType: string | null
    deviceId: string | null
    host: string | null
    port: number | null
    status: string | null
    lastConnect: Date | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeviceConnectionCountAggregateOutputType = {
    id: number
    deviceType: number
    deviceId: number
    host: number
    port: number
    status: number
    lastConnect: number
    errorMessage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeviceConnectionAvgAggregateInputType = {
    id?: true
    port?: true
  }

  export type DeviceConnectionSumAggregateInputType = {
    id?: true
    port?: true
  }

  export type DeviceConnectionMinAggregateInputType = {
    id?: true
    deviceType?: true
    deviceId?: true
    host?: true
    port?: true
    status?: true
    lastConnect?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeviceConnectionMaxAggregateInputType = {
    id?: true
    deviceType?: true
    deviceId?: true
    host?: true
    port?: true
    status?: true
    lastConnect?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeviceConnectionCountAggregateInputType = {
    id?: true
    deviceType?: true
    deviceId?: true
    host?: true
    port?: true
    status?: true
    lastConnect?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeviceConnectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceConnection to aggregate.
     */
    where?: DeviceConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceConnections to fetch.
     */
    orderBy?: DeviceConnectionOrderByWithRelationInput | DeviceConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceConnections
    **/
    _count?: true | DeviceConnectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceConnectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceConnectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceConnectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceConnectionMaxAggregateInputType
  }

  export type GetDeviceConnectionAggregateType<T extends DeviceConnectionAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceConnection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceConnection[P]>
      : GetScalarType<T[P], AggregateDeviceConnection[P]>
  }




  export type DeviceConnectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceConnectionWhereInput
    orderBy?: DeviceConnectionOrderByWithAggregationInput | DeviceConnectionOrderByWithAggregationInput[]
    by: DeviceConnectionScalarFieldEnum[] | DeviceConnectionScalarFieldEnum
    having?: DeviceConnectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceConnectionCountAggregateInputType | true
    _avg?: DeviceConnectionAvgAggregateInputType
    _sum?: DeviceConnectionSumAggregateInputType
    _min?: DeviceConnectionMinAggregateInputType
    _max?: DeviceConnectionMaxAggregateInputType
  }

  export type DeviceConnectionGroupByOutputType = {
    id: number
    deviceType: string
    deviceId: string
    host: string
    port: number | null
    status: string
    lastConnect: Date | null
    errorMessage: string | null
    createdAt: Date
    updatedAt: Date
    _count: DeviceConnectionCountAggregateOutputType | null
    _avg: DeviceConnectionAvgAggregateOutputType | null
    _sum: DeviceConnectionSumAggregateOutputType | null
    _min: DeviceConnectionMinAggregateOutputType | null
    _max: DeviceConnectionMaxAggregateOutputType | null
  }

  type GetDeviceConnectionGroupByPayload<T extends DeviceConnectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceConnectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceConnectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceConnectionGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceConnectionGroupByOutputType[P]>
        }
      >
    >


  export type DeviceConnectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceType?: boolean
    deviceId?: boolean
    host?: boolean
    port?: boolean
    status?: boolean
    lastConnect?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["deviceConnection"]>

  export type DeviceConnectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceType?: boolean
    deviceId?: boolean
    host?: boolean
    port?: boolean
    status?: boolean
    lastConnect?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["deviceConnection"]>

  export type DeviceConnectionSelectScalar = {
    id?: boolean
    deviceType?: boolean
    deviceId?: boolean
    host?: boolean
    port?: boolean
    status?: boolean
    lastConnect?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $DeviceConnectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceConnection"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      deviceType: string
      deviceId: string
      host: string
      port: number | null
      status: string
      lastConnect: Date | null
      errorMessage: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deviceConnection"]>
    composites: {}
  }

  type DeviceConnectionGetPayload<S extends boolean | null | undefined | DeviceConnectionDefaultArgs> = $Result.GetResult<Prisma.$DeviceConnectionPayload, S>

  type DeviceConnectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeviceConnectionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeviceConnectionCountAggregateInputType | true
    }

  export interface DeviceConnectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceConnection'], meta: { name: 'DeviceConnection' } }
    /**
     * Find zero or one DeviceConnection that matches the filter.
     * @param {DeviceConnectionFindUniqueArgs} args - Arguments to find a DeviceConnection
     * @example
     * // Get one DeviceConnection
     * const deviceConnection = await prisma.deviceConnection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceConnectionFindUniqueArgs>(args: SelectSubset<T, DeviceConnectionFindUniqueArgs<ExtArgs>>): Prisma__DeviceConnectionClient<$Result.GetResult<Prisma.$DeviceConnectionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DeviceConnection that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeviceConnectionFindUniqueOrThrowArgs} args - Arguments to find a DeviceConnection
     * @example
     * // Get one DeviceConnection
     * const deviceConnection = await prisma.deviceConnection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceConnectionFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceConnectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceConnectionClient<$Result.GetResult<Prisma.$DeviceConnectionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DeviceConnection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceConnectionFindFirstArgs} args - Arguments to find a DeviceConnection
     * @example
     * // Get one DeviceConnection
     * const deviceConnection = await prisma.deviceConnection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceConnectionFindFirstArgs>(args?: SelectSubset<T, DeviceConnectionFindFirstArgs<ExtArgs>>): Prisma__DeviceConnectionClient<$Result.GetResult<Prisma.$DeviceConnectionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DeviceConnection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceConnectionFindFirstOrThrowArgs} args - Arguments to find a DeviceConnection
     * @example
     * // Get one DeviceConnection
     * const deviceConnection = await prisma.deviceConnection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceConnectionFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceConnectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceConnectionClient<$Result.GetResult<Prisma.$DeviceConnectionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DeviceConnections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceConnectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceConnections
     * const deviceConnections = await prisma.deviceConnection.findMany()
     * 
     * // Get first 10 DeviceConnections
     * const deviceConnections = await prisma.deviceConnection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceConnectionWithIdOnly = await prisma.deviceConnection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceConnectionFindManyArgs>(args?: SelectSubset<T, DeviceConnectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceConnectionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DeviceConnection.
     * @param {DeviceConnectionCreateArgs} args - Arguments to create a DeviceConnection.
     * @example
     * // Create one DeviceConnection
     * const DeviceConnection = await prisma.deviceConnection.create({
     *   data: {
     *     // ... data to create a DeviceConnection
     *   }
     * })
     * 
     */
    create<T extends DeviceConnectionCreateArgs>(args: SelectSubset<T, DeviceConnectionCreateArgs<ExtArgs>>): Prisma__DeviceConnectionClient<$Result.GetResult<Prisma.$DeviceConnectionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DeviceConnections.
     * @param {DeviceConnectionCreateManyArgs} args - Arguments to create many DeviceConnections.
     * @example
     * // Create many DeviceConnections
     * const deviceConnection = await prisma.deviceConnection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceConnectionCreateManyArgs>(args?: SelectSubset<T, DeviceConnectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceConnections and returns the data saved in the database.
     * @param {DeviceConnectionCreateManyAndReturnArgs} args - Arguments to create many DeviceConnections.
     * @example
     * // Create many DeviceConnections
     * const deviceConnection = await prisma.deviceConnection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceConnections and only return the `id`
     * const deviceConnectionWithIdOnly = await prisma.deviceConnection.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceConnectionCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceConnectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceConnectionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DeviceConnection.
     * @param {DeviceConnectionDeleteArgs} args - Arguments to delete one DeviceConnection.
     * @example
     * // Delete one DeviceConnection
     * const DeviceConnection = await prisma.deviceConnection.delete({
     *   where: {
     *     // ... filter to delete one DeviceConnection
     *   }
     * })
     * 
     */
    delete<T extends DeviceConnectionDeleteArgs>(args: SelectSubset<T, DeviceConnectionDeleteArgs<ExtArgs>>): Prisma__DeviceConnectionClient<$Result.GetResult<Prisma.$DeviceConnectionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DeviceConnection.
     * @param {DeviceConnectionUpdateArgs} args - Arguments to update one DeviceConnection.
     * @example
     * // Update one DeviceConnection
     * const deviceConnection = await prisma.deviceConnection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceConnectionUpdateArgs>(args: SelectSubset<T, DeviceConnectionUpdateArgs<ExtArgs>>): Prisma__DeviceConnectionClient<$Result.GetResult<Prisma.$DeviceConnectionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DeviceConnections.
     * @param {DeviceConnectionDeleteManyArgs} args - Arguments to filter DeviceConnections to delete.
     * @example
     * // Delete a few DeviceConnections
     * const { count } = await prisma.deviceConnection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceConnectionDeleteManyArgs>(args?: SelectSubset<T, DeviceConnectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceConnectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceConnections
     * const deviceConnection = await prisma.deviceConnection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceConnectionUpdateManyArgs>(args: SelectSubset<T, DeviceConnectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeviceConnection.
     * @param {DeviceConnectionUpsertArgs} args - Arguments to update or create a DeviceConnection.
     * @example
     * // Update or create a DeviceConnection
     * const deviceConnection = await prisma.deviceConnection.upsert({
     *   create: {
     *     // ... data to create a DeviceConnection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceConnection we want to update
     *   }
     * })
     */
    upsert<T extends DeviceConnectionUpsertArgs>(args: SelectSubset<T, DeviceConnectionUpsertArgs<ExtArgs>>): Prisma__DeviceConnectionClient<$Result.GetResult<Prisma.$DeviceConnectionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DeviceConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceConnectionCountArgs} args - Arguments to filter DeviceConnections to count.
     * @example
     * // Count the number of DeviceConnections
     * const count = await prisma.deviceConnection.count({
     *   where: {
     *     // ... the filter for the DeviceConnections we want to count
     *   }
     * })
    **/
    count<T extends DeviceConnectionCountArgs>(
      args?: Subset<T, DeviceConnectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceConnectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceConnection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceConnectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceConnectionAggregateArgs>(args: Subset<T, DeviceConnectionAggregateArgs>): Prisma.PrismaPromise<GetDeviceConnectionAggregateType<T>>

    /**
     * Group by DeviceConnection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceConnectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceConnectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceConnectionGroupByArgs['orderBy'] }
        : { orderBy?: DeviceConnectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceConnectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceConnectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceConnection model
   */
  readonly fields: DeviceConnectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceConnection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceConnectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceConnection model
   */ 
  interface DeviceConnectionFieldRefs {
    readonly id: FieldRef<"DeviceConnection", 'Int'>
    readonly deviceType: FieldRef<"DeviceConnection", 'String'>
    readonly deviceId: FieldRef<"DeviceConnection", 'String'>
    readonly host: FieldRef<"DeviceConnection", 'String'>
    readonly port: FieldRef<"DeviceConnection", 'Int'>
    readonly status: FieldRef<"DeviceConnection", 'String'>
    readonly lastConnect: FieldRef<"DeviceConnection", 'DateTime'>
    readonly errorMessage: FieldRef<"DeviceConnection", 'String'>
    readonly createdAt: FieldRef<"DeviceConnection", 'DateTime'>
    readonly updatedAt: FieldRef<"DeviceConnection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeviceConnection findUnique
   */
  export type DeviceConnectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConnection
     */
    select?: DeviceConnectionSelect<ExtArgs> | null
    /**
     * Filter, which DeviceConnection to fetch.
     */
    where: DeviceConnectionWhereUniqueInput
  }

  /**
   * DeviceConnection findUniqueOrThrow
   */
  export type DeviceConnectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConnection
     */
    select?: DeviceConnectionSelect<ExtArgs> | null
    /**
     * Filter, which DeviceConnection to fetch.
     */
    where: DeviceConnectionWhereUniqueInput
  }

  /**
   * DeviceConnection findFirst
   */
  export type DeviceConnectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConnection
     */
    select?: DeviceConnectionSelect<ExtArgs> | null
    /**
     * Filter, which DeviceConnection to fetch.
     */
    where?: DeviceConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceConnections to fetch.
     */
    orderBy?: DeviceConnectionOrderByWithRelationInput | DeviceConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceConnections.
     */
    cursor?: DeviceConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceConnections.
     */
    distinct?: DeviceConnectionScalarFieldEnum | DeviceConnectionScalarFieldEnum[]
  }

  /**
   * DeviceConnection findFirstOrThrow
   */
  export type DeviceConnectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConnection
     */
    select?: DeviceConnectionSelect<ExtArgs> | null
    /**
     * Filter, which DeviceConnection to fetch.
     */
    where?: DeviceConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceConnections to fetch.
     */
    orderBy?: DeviceConnectionOrderByWithRelationInput | DeviceConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceConnections.
     */
    cursor?: DeviceConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceConnections.
     */
    distinct?: DeviceConnectionScalarFieldEnum | DeviceConnectionScalarFieldEnum[]
  }

  /**
   * DeviceConnection findMany
   */
  export type DeviceConnectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConnection
     */
    select?: DeviceConnectionSelect<ExtArgs> | null
    /**
     * Filter, which DeviceConnections to fetch.
     */
    where?: DeviceConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceConnections to fetch.
     */
    orderBy?: DeviceConnectionOrderByWithRelationInput | DeviceConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceConnections.
     */
    cursor?: DeviceConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceConnections.
     */
    skip?: number
    distinct?: DeviceConnectionScalarFieldEnum | DeviceConnectionScalarFieldEnum[]
  }

  /**
   * DeviceConnection create
   */
  export type DeviceConnectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConnection
     */
    select?: DeviceConnectionSelect<ExtArgs> | null
    /**
     * The data needed to create a DeviceConnection.
     */
    data: XOR<DeviceConnectionCreateInput, DeviceConnectionUncheckedCreateInput>
  }

  /**
   * DeviceConnection createMany
   */
  export type DeviceConnectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceConnections.
     */
    data: DeviceConnectionCreateManyInput | DeviceConnectionCreateManyInput[]
  }

  /**
   * DeviceConnection createManyAndReturn
   */
  export type DeviceConnectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConnection
     */
    select?: DeviceConnectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DeviceConnections.
     */
    data: DeviceConnectionCreateManyInput | DeviceConnectionCreateManyInput[]
  }

  /**
   * DeviceConnection update
   */
  export type DeviceConnectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConnection
     */
    select?: DeviceConnectionSelect<ExtArgs> | null
    /**
     * The data needed to update a DeviceConnection.
     */
    data: XOR<DeviceConnectionUpdateInput, DeviceConnectionUncheckedUpdateInput>
    /**
     * Choose, which DeviceConnection to update.
     */
    where: DeviceConnectionWhereUniqueInput
  }

  /**
   * DeviceConnection updateMany
   */
  export type DeviceConnectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceConnections.
     */
    data: XOR<DeviceConnectionUpdateManyMutationInput, DeviceConnectionUncheckedUpdateManyInput>
    /**
     * Filter which DeviceConnections to update
     */
    where?: DeviceConnectionWhereInput
  }

  /**
   * DeviceConnection upsert
   */
  export type DeviceConnectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConnection
     */
    select?: DeviceConnectionSelect<ExtArgs> | null
    /**
     * The filter to search for the DeviceConnection to update in case it exists.
     */
    where: DeviceConnectionWhereUniqueInput
    /**
     * In case the DeviceConnection found by the `where` argument doesn't exist, create a new DeviceConnection with this data.
     */
    create: XOR<DeviceConnectionCreateInput, DeviceConnectionUncheckedCreateInput>
    /**
     * In case the DeviceConnection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceConnectionUpdateInput, DeviceConnectionUncheckedUpdateInput>
  }

  /**
   * DeviceConnection delete
   */
  export type DeviceConnectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConnection
     */
    select?: DeviceConnectionSelect<ExtArgs> | null
    /**
     * Filter which DeviceConnection to delete.
     */
    where: DeviceConnectionWhereUniqueInput
  }

  /**
   * DeviceConnection deleteMany
   */
  export type DeviceConnectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceConnections to delete
     */
    where?: DeviceConnectionWhereInput
  }

  /**
   * DeviceConnection without action
   */
  export type DeviceConnectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceConnection
     */
    select?: DeviceConnectionSelect<ExtArgs> | null
  }


  /**
   * Model DataPoint
   */

  export type AggregateDataPoint = {
    _count: DataPointCountAggregateOutputType | null
    _avg: DataPointAvgAggregateOutputType | null
    _sum: DataPointSumAggregateOutputType | null
    _min: DataPointMinAggregateOutputType | null
    _max: DataPointMaxAggregateOutputType | null
  }

  export type DataPointAvgAggregateOutputType = {
    id: number | null
  }

  export type DataPointSumAggregateOutputType = {
    id: number | null
  }

  export type DataPointMinAggregateOutputType = {
    id: number | null
    tagName: string | null
    deviceId: string | null
    address: string | null
    dataType: string | null
    value: string | null
    quality: string | null
    timestamp: Date | null
    description: string | null
  }

  export type DataPointMaxAggregateOutputType = {
    id: number | null
    tagName: string | null
    deviceId: string | null
    address: string | null
    dataType: string | null
    value: string | null
    quality: string | null
    timestamp: Date | null
    description: string | null
  }

  export type DataPointCountAggregateOutputType = {
    id: number
    tagName: number
    deviceId: number
    address: number
    dataType: number
    value: number
    quality: number
    timestamp: number
    description: number
    _all: number
  }


  export type DataPointAvgAggregateInputType = {
    id?: true
  }

  export type DataPointSumAggregateInputType = {
    id?: true
  }

  export type DataPointMinAggregateInputType = {
    id?: true
    tagName?: true
    deviceId?: true
    address?: true
    dataType?: true
    value?: true
    quality?: true
    timestamp?: true
    description?: true
  }

  export type DataPointMaxAggregateInputType = {
    id?: true
    tagName?: true
    deviceId?: true
    address?: true
    dataType?: true
    value?: true
    quality?: true
    timestamp?: true
    description?: true
  }

  export type DataPointCountAggregateInputType = {
    id?: true
    tagName?: true
    deviceId?: true
    address?: true
    dataType?: true
    value?: true
    quality?: true
    timestamp?: true
    description?: true
    _all?: true
  }

  export type DataPointAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataPoint to aggregate.
     */
    where?: DataPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataPoints to fetch.
     */
    orderBy?: DataPointOrderByWithRelationInput | DataPointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataPoints
    **/
    _count?: true | DataPointCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DataPointAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DataPointSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataPointMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataPointMaxAggregateInputType
  }

  export type GetDataPointAggregateType<T extends DataPointAggregateArgs> = {
        [P in keyof T & keyof AggregateDataPoint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataPoint[P]>
      : GetScalarType<T[P], AggregateDataPoint[P]>
  }




  export type DataPointGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataPointWhereInput
    orderBy?: DataPointOrderByWithAggregationInput | DataPointOrderByWithAggregationInput[]
    by: DataPointScalarFieldEnum[] | DataPointScalarFieldEnum
    having?: DataPointScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataPointCountAggregateInputType | true
    _avg?: DataPointAvgAggregateInputType
    _sum?: DataPointSumAggregateInputType
    _min?: DataPointMinAggregateInputType
    _max?: DataPointMaxAggregateInputType
  }

  export type DataPointGroupByOutputType = {
    id: number
    tagName: string
    deviceId: string
    address: string
    dataType: string
    value: string
    quality: string
    timestamp: Date
    description: string | null
    _count: DataPointCountAggregateOutputType | null
    _avg: DataPointAvgAggregateOutputType | null
    _sum: DataPointSumAggregateOutputType | null
    _min: DataPointMinAggregateOutputType | null
    _max: DataPointMaxAggregateOutputType | null
  }

  type GetDataPointGroupByPayload<T extends DataPointGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataPointGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataPointGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataPointGroupByOutputType[P]>
            : GetScalarType<T[P], DataPointGroupByOutputType[P]>
        }
      >
    >


  export type DataPointSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tagName?: boolean
    deviceId?: boolean
    address?: boolean
    dataType?: boolean
    value?: boolean
    quality?: boolean
    timestamp?: boolean
    description?: boolean
    history?: boolean | DataPoint$historyArgs<ExtArgs>
    _count?: boolean | DataPointCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataPoint"]>

  export type DataPointSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tagName?: boolean
    deviceId?: boolean
    address?: boolean
    dataType?: boolean
    value?: boolean
    quality?: boolean
    timestamp?: boolean
    description?: boolean
  }, ExtArgs["result"]["dataPoint"]>

  export type DataPointSelectScalar = {
    id?: boolean
    tagName?: boolean
    deviceId?: boolean
    address?: boolean
    dataType?: boolean
    value?: boolean
    quality?: boolean
    timestamp?: boolean
    description?: boolean
  }

  export type DataPointInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    history?: boolean | DataPoint$historyArgs<ExtArgs>
    _count?: boolean | DataPointCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DataPointIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DataPointPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DataPoint"
    objects: {
      history: Prisma.$DataHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tagName: string
      deviceId: string
      address: string
      dataType: string
      value: string
      quality: string
      timestamp: Date
      description: string | null
    }, ExtArgs["result"]["dataPoint"]>
    composites: {}
  }

  type DataPointGetPayload<S extends boolean | null | undefined | DataPointDefaultArgs> = $Result.GetResult<Prisma.$DataPointPayload, S>

  type DataPointCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DataPointFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DataPointCountAggregateInputType | true
    }

  export interface DataPointDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DataPoint'], meta: { name: 'DataPoint' } }
    /**
     * Find zero or one DataPoint that matches the filter.
     * @param {DataPointFindUniqueArgs} args - Arguments to find a DataPoint
     * @example
     * // Get one DataPoint
     * const dataPoint = await prisma.dataPoint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataPointFindUniqueArgs>(args: SelectSubset<T, DataPointFindUniqueArgs<ExtArgs>>): Prisma__DataPointClient<$Result.GetResult<Prisma.$DataPointPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DataPoint that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DataPointFindUniqueOrThrowArgs} args - Arguments to find a DataPoint
     * @example
     * // Get one DataPoint
     * const dataPoint = await prisma.dataPoint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataPointFindUniqueOrThrowArgs>(args: SelectSubset<T, DataPointFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DataPointClient<$Result.GetResult<Prisma.$DataPointPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DataPoint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataPointFindFirstArgs} args - Arguments to find a DataPoint
     * @example
     * // Get one DataPoint
     * const dataPoint = await prisma.dataPoint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataPointFindFirstArgs>(args?: SelectSubset<T, DataPointFindFirstArgs<ExtArgs>>): Prisma__DataPointClient<$Result.GetResult<Prisma.$DataPointPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DataPoint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataPointFindFirstOrThrowArgs} args - Arguments to find a DataPoint
     * @example
     * // Get one DataPoint
     * const dataPoint = await prisma.dataPoint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataPointFindFirstOrThrowArgs>(args?: SelectSubset<T, DataPointFindFirstOrThrowArgs<ExtArgs>>): Prisma__DataPointClient<$Result.GetResult<Prisma.$DataPointPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DataPoints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataPointFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataPoints
     * const dataPoints = await prisma.dataPoint.findMany()
     * 
     * // Get first 10 DataPoints
     * const dataPoints = await prisma.dataPoint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dataPointWithIdOnly = await prisma.dataPoint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DataPointFindManyArgs>(args?: SelectSubset<T, DataPointFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataPointPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DataPoint.
     * @param {DataPointCreateArgs} args - Arguments to create a DataPoint.
     * @example
     * // Create one DataPoint
     * const DataPoint = await prisma.dataPoint.create({
     *   data: {
     *     // ... data to create a DataPoint
     *   }
     * })
     * 
     */
    create<T extends DataPointCreateArgs>(args: SelectSubset<T, DataPointCreateArgs<ExtArgs>>): Prisma__DataPointClient<$Result.GetResult<Prisma.$DataPointPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DataPoints.
     * @param {DataPointCreateManyArgs} args - Arguments to create many DataPoints.
     * @example
     * // Create many DataPoints
     * const dataPoint = await prisma.dataPoint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DataPointCreateManyArgs>(args?: SelectSubset<T, DataPointCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DataPoints and returns the data saved in the database.
     * @param {DataPointCreateManyAndReturnArgs} args - Arguments to create many DataPoints.
     * @example
     * // Create many DataPoints
     * const dataPoint = await prisma.dataPoint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DataPoints and only return the `id`
     * const dataPointWithIdOnly = await prisma.dataPoint.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DataPointCreateManyAndReturnArgs>(args?: SelectSubset<T, DataPointCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataPointPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DataPoint.
     * @param {DataPointDeleteArgs} args - Arguments to delete one DataPoint.
     * @example
     * // Delete one DataPoint
     * const DataPoint = await prisma.dataPoint.delete({
     *   where: {
     *     // ... filter to delete one DataPoint
     *   }
     * })
     * 
     */
    delete<T extends DataPointDeleteArgs>(args: SelectSubset<T, DataPointDeleteArgs<ExtArgs>>): Prisma__DataPointClient<$Result.GetResult<Prisma.$DataPointPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DataPoint.
     * @param {DataPointUpdateArgs} args - Arguments to update one DataPoint.
     * @example
     * // Update one DataPoint
     * const dataPoint = await prisma.dataPoint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DataPointUpdateArgs>(args: SelectSubset<T, DataPointUpdateArgs<ExtArgs>>): Prisma__DataPointClient<$Result.GetResult<Prisma.$DataPointPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DataPoints.
     * @param {DataPointDeleteManyArgs} args - Arguments to filter DataPoints to delete.
     * @example
     * // Delete a few DataPoints
     * const { count } = await prisma.dataPoint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DataPointDeleteManyArgs>(args?: SelectSubset<T, DataPointDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataPoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataPointUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataPoints
     * const dataPoint = await prisma.dataPoint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DataPointUpdateManyArgs>(args: SelectSubset<T, DataPointUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DataPoint.
     * @param {DataPointUpsertArgs} args - Arguments to update or create a DataPoint.
     * @example
     * // Update or create a DataPoint
     * const dataPoint = await prisma.dataPoint.upsert({
     *   create: {
     *     // ... data to create a DataPoint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataPoint we want to update
     *   }
     * })
     */
    upsert<T extends DataPointUpsertArgs>(args: SelectSubset<T, DataPointUpsertArgs<ExtArgs>>): Prisma__DataPointClient<$Result.GetResult<Prisma.$DataPointPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DataPoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataPointCountArgs} args - Arguments to filter DataPoints to count.
     * @example
     * // Count the number of DataPoints
     * const count = await prisma.dataPoint.count({
     *   where: {
     *     // ... the filter for the DataPoints we want to count
     *   }
     * })
    **/
    count<T extends DataPointCountArgs>(
      args?: Subset<T, DataPointCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataPointCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataPoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataPointAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataPointAggregateArgs>(args: Subset<T, DataPointAggregateArgs>): Prisma.PrismaPromise<GetDataPointAggregateType<T>>

    /**
     * Group by DataPoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataPointGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataPointGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataPointGroupByArgs['orderBy'] }
        : { orderBy?: DataPointGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataPointGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataPointGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DataPoint model
   */
  readonly fields: DataPointFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataPoint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataPointClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    history<T extends DataPoint$historyArgs<ExtArgs> = {}>(args?: Subset<T, DataPoint$historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DataPoint model
   */ 
  interface DataPointFieldRefs {
    readonly id: FieldRef<"DataPoint", 'Int'>
    readonly tagName: FieldRef<"DataPoint", 'String'>
    readonly deviceId: FieldRef<"DataPoint", 'String'>
    readonly address: FieldRef<"DataPoint", 'String'>
    readonly dataType: FieldRef<"DataPoint", 'String'>
    readonly value: FieldRef<"DataPoint", 'String'>
    readonly quality: FieldRef<"DataPoint", 'String'>
    readonly timestamp: FieldRef<"DataPoint", 'DateTime'>
    readonly description: FieldRef<"DataPoint", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DataPoint findUnique
   */
  export type DataPointFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataPoint
     */
    select?: DataPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataPointInclude<ExtArgs> | null
    /**
     * Filter, which DataPoint to fetch.
     */
    where: DataPointWhereUniqueInput
  }

  /**
   * DataPoint findUniqueOrThrow
   */
  export type DataPointFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataPoint
     */
    select?: DataPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataPointInclude<ExtArgs> | null
    /**
     * Filter, which DataPoint to fetch.
     */
    where: DataPointWhereUniqueInput
  }

  /**
   * DataPoint findFirst
   */
  export type DataPointFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataPoint
     */
    select?: DataPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataPointInclude<ExtArgs> | null
    /**
     * Filter, which DataPoint to fetch.
     */
    where?: DataPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataPoints to fetch.
     */
    orderBy?: DataPointOrderByWithRelationInput | DataPointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataPoints.
     */
    cursor?: DataPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataPoints.
     */
    distinct?: DataPointScalarFieldEnum | DataPointScalarFieldEnum[]
  }

  /**
   * DataPoint findFirstOrThrow
   */
  export type DataPointFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataPoint
     */
    select?: DataPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataPointInclude<ExtArgs> | null
    /**
     * Filter, which DataPoint to fetch.
     */
    where?: DataPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataPoints to fetch.
     */
    orderBy?: DataPointOrderByWithRelationInput | DataPointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataPoints.
     */
    cursor?: DataPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataPoints.
     */
    distinct?: DataPointScalarFieldEnum | DataPointScalarFieldEnum[]
  }

  /**
   * DataPoint findMany
   */
  export type DataPointFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataPoint
     */
    select?: DataPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataPointInclude<ExtArgs> | null
    /**
     * Filter, which DataPoints to fetch.
     */
    where?: DataPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataPoints to fetch.
     */
    orderBy?: DataPointOrderByWithRelationInput | DataPointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataPoints.
     */
    cursor?: DataPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataPoints.
     */
    skip?: number
    distinct?: DataPointScalarFieldEnum | DataPointScalarFieldEnum[]
  }

  /**
   * DataPoint create
   */
  export type DataPointCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataPoint
     */
    select?: DataPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataPointInclude<ExtArgs> | null
    /**
     * The data needed to create a DataPoint.
     */
    data: XOR<DataPointCreateInput, DataPointUncheckedCreateInput>
  }

  /**
   * DataPoint createMany
   */
  export type DataPointCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DataPoints.
     */
    data: DataPointCreateManyInput | DataPointCreateManyInput[]
  }

  /**
   * DataPoint createManyAndReturn
   */
  export type DataPointCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataPoint
     */
    select?: DataPointSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DataPoints.
     */
    data: DataPointCreateManyInput | DataPointCreateManyInput[]
  }

  /**
   * DataPoint update
   */
  export type DataPointUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataPoint
     */
    select?: DataPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataPointInclude<ExtArgs> | null
    /**
     * The data needed to update a DataPoint.
     */
    data: XOR<DataPointUpdateInput, DataPointUncheckedUpdateInput>
    /**
     * Choose, which DataPoint to update.
     */
    where: DataPointWhereUniqueInput
  }

  /**
   * DataPoint updateMany
   */
  export type DataPointUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DataPoints.
     */
    data: XOR<DataPointUpdateManyMutationInput, DataPointUncheckedUpdateManyInput>
    /**
     * Filter which DataPoints to update
     */
    where?: DataPointWhereInput
  }

  /**
   * DataPoint upsert
   */
  export type DataPointUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataPoint
     */
    select?: DataPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataPointInclude<ExtArgs> | null
    /**
     * The filter to search for the DataPoint to update in case it exists.
     */
    where: DataPointWhereUniqueInput
    /**
     * In case the DataPoint found by the `where` argument doesn't exist, create a new DataPoint with this data.
     */
    create: XOR<DataPointCreateInput, DataPointUncheckedCreateInput>
    /**
     * In case the DataPoint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataPointUpdateInput, DataPointUncheckedUpdateInput>
  }

  /**
   * DataPoint delete
   */
  export type DataPointDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataPoint
     */
    select?: DataPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataPointInclude<ExtArgs> | null
    /**
     * Filter which DataPoint to delete.
     */
    where: DataPointWhereUniqueInput
  }

  /**
   * DataPoint deleteMany
   */
  export type DataPointDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataPoints to delete
     */
    where?: DataPointWhereInput
  }

  /**
   * DataPoint.history
   */
  export type DataPoint$historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataHistory
     */
    select?: DataHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataHistoryInclude<ExtArgs> | null
    where?: DataHistoryWhereInput
    orderBy?: DataHistoryOrderByWithRelationInput | DataHistoryOrderByWithRelationInput[]
    cursor?: DataHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DataHistoryScalarFieldEnum | DataHistoryScalarFieldEnum[]
  }

  /**
   * DataPoint without action
   */
  export type DataPointDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataPoint
     */
    select?: DataPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataPointInclude<ExtArgs> | null
  }


  /**
   * Model DataHistory
   */

  export type AggregateDataHistory = {
    _count: DataHistoryCountAggregateOutputType | null
    _avg: DataHistoryAvgAggregateOutputType | null
    _sum: DataHistorySumAggregateOutputType | null
    _min: DataHistoryMinAggregateOutputType | null
    _max: DataHistoryMaxAggregateOutputType | null
  }

  export type DataHistoryAvgAggregateOutputType = {
    id: number | null
    pointId: number | null
  }

  export type DataHistorySumAggregateOutputType = {
    id: number | null
    pointId: number | null
  }

  export type DataHistoryMinAggregateOutputType = {
    id: number | null
    pointId: number | null
    value: string | null
    quality: string | null
    timestamp: Date | null
  }

  export type DataHistoryMaxAggregateOutputType = {
    id: number | null
    pointId: number | null
    value: string | null
    quality: string | null
    timestamp: Date | null
  }

  export type DataHistoryCountAggregateOutputType = {
    id: number
    pointId: number
    value: number
    quality: number
    timestamp: number
    _all: number
  }


  export type DataHistoryAvgAggregateInputType = {
    id?: true
    pointId?: true
  }

  export type DataHistorySumAggregateInputType = {
    id?: true
    pointId?: true
  }

  export type DataHistoryMinAggregateInputType = {
    id?: true
    pointId?: true
    value?: true
    quality?: true
    timestamp?: true
  }

  export type DataHistoryMaxAggregateInputType = {
    id?: true
    pointId?: true
    value?: true
    quality?: true
    timestamp?: true
  }

  export type DataHistoryCountAggregateInputType = {
    id?: true
    pointId?: true
    value?: true
    quality?: true
    timestamp?: true
    _all?: true
  }

  export type DataHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataHistory to aggregate.
     */
    where?: DataHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataHistories to fetch.
     */
    orderBy?: DataHistoryOrderByWithRelationInput | DataHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataHistories
    **/
    _count?: true | DataHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DataHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DataHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataHistoryMaxAggregateInputType
  }

  export type GetDataHistoryAggregateType<T extends DataHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateDataHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataHistory[P]>
      : GetScalarType<T[P], AggregateDataHistory[P]>
  }




  export type DataHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataHistoryWhereInput
    orderBy?: DataHistoryOrderByWithAggregationInput | DataHistoryOrderByWithAggregationInput[]
    by: DataHistoryScalarFieldEnum[] | DataHistoryScalarFieldEnum
    having?: DataHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataHistoryCountAggregateInputType | true
    _avg?: DataHistoryAvgAggregateInputType
    _sum?: DataHistorySumAggregateInputType
    _min?: DataHistoryMinAggregateInputType
    _max?: DataHistoryMaxAggregateInputType
  }

  export type DataHistoryGroupByOutputType = {
    id: number
    pointId: number
    value: string
    quality: string
    timestamp: Date
    _count: DataHistoryCountAggregateOutputType | null
    _avg: DataHistoryAvgAggregateOutputType | null
    _sum: DataHistorySumAggregateOutputType | null
    _min: DataHistoryMinAggregateOutputType | null
    _max: DataHistoryMaxAggregateOutputType | null
  }

  type GetDataHistoryGroupByPayload<T extends DataHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], DataHistoryGroupByOutputType[P]>
        }
      >
    >


  export type DataHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pointId?: boolean
    value?: boolean
    quality?: boolean
    timestamp?: boolean
    dataPoint?: boolean | DataPointDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataHistory"]>

  export type DataHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pointId?: boolean
    value?: boolean
    quality?: boolean
    timestamp?: boolean
    dataPoint?: boolean | DataPointDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataHistory"]>

  export type DataHistorySelectScalar = {
    id?: boolean
    pointId?: boolean
    value?: boolean
    quality?: boolean
    timestamp?: boolean
  }

  export type DataHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dataPoint?: boolean | DataPointDefaultArgs<ExtArgs>
  }
  export type DataHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dataPoint?: boolean | DataPointDefaultArgs<ExtArgs>
  }

  export type $DataHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DataHistory"
    objects: {
      dataPoint: Prisma.$DataPointPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pointId: number
      value: string
      quality: string
      timestamp: Date
    }, ExtArgs["result"]["dataHistory"]>
    composites: {}
  }

  type DataHistoryGetPayload<S extends boolean | null | undefined | DataHistoryDefaultArgs> = $Result.GetResult<Prisma.$DataHistoryPayload, S>

  type DataHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DataHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DataHistoryCountAggregateInputType | true
    }

  export interface DataHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DataHistory'], meta: { name: 'DataHistory' } }
    /**
     * Find zero or one DataHistory that matches the filter.
     * @param {DataHistoryFindUniqueArgs} args - Arguments to find a DataHistory
     * @example
     * // Get one DataHistory
     * const dataHistory = await prisma.dataHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataHistoryFindUniqueArgs>(args: SelectSubset<T, DataHistoryFindUniqueArgs<ExtArgs>>): Prisma__DataHistoryClient<$Result.GetResult<Prisma.$DataHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DataHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DataHistoryFindUniqueOrThrowArgs} args - Arguments to find a DataHistory
     * @example
     * // Get one DataHistory
     * const dataHistory = await prisma.dataHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, DataHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DataHistoryClient<$Result.GetResult<Prisma.$DataHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DataHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataHistoryFindFirstArgs} args - Arguments to find a DataHistory
     * @example
     * // Get one DataHistory
     * const dataHistory = await prisma.dataHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataHistoryFindFirstArgs>(args?: SelectSubset<T, DataHistoryFindFirstArgs<ExtArgs>>): Prisma__DataHistoryClient<$Result.GetResult<Prisma.$DataHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DataHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataHistoryFindFirstOrThrowArgs} args - Arguments to find a DataHistory
     * @example
     * // Get one DataHistory
     * const dataHistory = await prisma.dataHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, DataHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__DataHistoryClient<$Result.GetResult<Prisma.$DataHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DataHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataHistories
     * const dataHistories = await prisma.dataHistory.findMany()
     * 
     * // Get first 10 DataHistories
     * const dataHistories = await prisma.dataHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dataHistoryWithIdOnly = await prisma.dataHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DataHistoryFindManyArgs>(args?: SelectSubset<T, DataHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DataHistory.
     * @param {DataHistoryCreateArgs} args - Arguments to create a DataHistory.
     * @example
     * // Create one DataHistory
     * const DataHistory = await prisma.dataHistory.create({
     *   data: {
     *     // ... data to create a DataHistory
     *   }
     * })
     * 
     */
    create<T extends DataHistoryCreateArgs>(args: SelectSubset<T, DataHistoryCreateArgs<ExtArgs>>): Prisma__DataHistoryClient<$Result.GetResult<Prisma.$DataHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DataHistories.
     * @param {DataHistoryCreateManyArgs} args - Arguments to create many DataHistories.
     * @example
     * // Create many DataHistories
     * const dataHistory = await prisma.dataHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DataHistoryCreateManyArgs>(args?: SelectSubset<T, DataHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DataHistories and returns the data saved in the database.
     * @param {DataHistoryCreateManyAndReturnArgs} args - Arguments to create many DataHistories.
     * @example
     * // Create many DataHistories
     * const dataHistory = await prisma.dataHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DataHistories and only return the `id`
     * const dataHistoryWithIdOnly = await prisma.dataHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DataHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, DataHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DataHistory.
     * @param {DataHistoryDeleteArgs} args - Arguments to delete one DataHistory.
     * @example
     * // Delete one DataHistory
     * const DataHistory = await prisma.dataHistory.delete({
     *   where: {
     *     // ... filter to delete one DataHistory
     *   }
     * })
     * 
     */
    delete<T extends DataHistoryDeleteArgs>(args: SelectSubset<T, DataHistoryDeleteArgs<ExtArgs>>): Prisma__DataHistoryClient<$Result.GetResult<Prisma.$DataHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DataHistory.
     * @param {DataHistoryUpdateArgs} args - Arguments to update one DataHistory.
     * @example
     * // Update one DataHistory
     * const dataHistory = await prisma.dataHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DataHistoryUpdateArgs>(args: SelectSubset<T, DataHistoryUpdateArgs<ExtArgs>>): Prisma__DataHistoryClient<$Result.GetResult<Prisma.$DataHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DataHistories.
     * @param {DataHistoryDeleteManyArgs} args - Arguments to filter DataHistories to delete.
     * @example
     * // Delete a few DataHistories
     * const { count } = await prisma.dataHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DataHistoryDeleteManyArgs>(args?: SelectSubset<T, DataHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataHistories
     * const dataHistory = await prisma.dataHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DataHistoryUpdateManyArgs>(args: SelectSubset<T, DataHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DataHistory.
     * @param {DataHistoryUpsertArgs} args - Arguments to update or create a DataHistory.
     * @example
     * // Update or create a DataHistory
     * const dataHistory = await prisma.dataHistory.upsert({
     *   create: {
     *     // ... data to create a DataHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataHistory we want to update
     *   }
     * })
     */
    upsert<T extends DataHistoryUpsertArgs>(args: SelectSubset<T, DataHistoryUpsertArgs<ExtArgs>>): Prisma__DataHistoryClient<$Result.GetResult<Prisma.$DataHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DataHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataHistoryCountArgs} args - Arguments to filter DataHistories to count.
     * @example
     * // Count the number of DataHistories
     * const count = await prisma.dataHistory.count({
     *   where: {
     *     // ... the filter for the DataHistories we want to count
     *   }
     * })
    **/
    count<T extends DataHistoryCountArgs>(
      args?: Subset<T, DataHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataHistoryAggregateArgs>(args: Subset<T, DataHistoryAggregateArgs>): Prisma.PrismaPromise<GetDataHistoryAggregateType<T>>

    /**
     * Group by DataHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataHistoryGroupByArgs['orderBy'] }
        : { orderBy?: DataHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DataHistory model
   */
  readonly fields: DataHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dataPoint<T extends DataPointDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DataPointDefaultArgs<ExtArgs>>): Prisma__DataPointClient<$Result.GetResult<Prisma.$DataPointPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DataHistory model
   */ 
  interface DataHistoryFieldRefs {
    readonly id: FieldRef<"DataHistory", 'Int'>
    readonly pointId: FieldRef<"DataHistory", 'Int'>
    readonly value: FieldRef<"DataHistory", 'String'>
    readonly quality: FieldRef<"DataHistory", 'String'>
    readonly timestamp: FieldRef<"DataHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DataHistory findUnique
   */
  export type DataHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataHistory
     */
    select?: DataHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataHistoryInclude<ExtArgs> | null
    /**
     * Filter, which DataHistory to fetch.
     */
    where: DataHistoryWhereUniqueInput
  }

  /**
   * DataHistory findUniqueOrThrow
   */
  export type DataHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataHistory
     */
    select?: DataHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataHistoryInclude<ExtArgs> | null
    /**
     * Filter, which DataHistory to fetch.
     */
    where: DataHistoryWhereUniqueInput
  }

  /**
   * DataHistory findFirst
   */
  export type DataHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataHistory
     */
    select?: DataHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataHistoryInclude<ExtArgs> | null
    /**
     * Filter, which DataHistory to fetch.
     */
    where?: DataHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataHistories to fetch.
     */
    orderBy?: DataHistoryOrderByWithRelationInput | DataHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataHistories.
     */
    cursor?: DataHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataHistories.
     */
    distinct?: DataHistoryScalarFieldEnum | DataHistoryScalarFieldEnum[]
  }

  /**
   * DataHistory findFirstOrThrow
   */
  export type DataHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataHistory
     */
    select?: DataHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataHistoryInclude<ExtArgs> | null
    /**
     * Filter, which DataHistory to fetch.
     */
    where?: DataHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataHistories to fetch.
     */
    orderBy?: DataHistoryOrderByWithRelationInput | DataHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataHistories.
     */
    cursor?: DataHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataHistories.
     */
    distinct?: DataHistoryScalarFieldEnum | DataHistoryScalarFieldEnum[]
  }

  /**
   * DataHistory findMany
   */
  export type DataHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataHistory
     */
    select?: DataHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataHistoryInclude<ExtArgs> | null
    /**
     * Filter, which DataHistories to fetch.
     */
    where?: DataHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataHistories to fetch.
     */
    orderBy?: DataHistoryOrderByWithRelationInput | DataHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataHistories.
     */
    cursor?: DataHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataHistories.
     */
    skip?: number
    distinct?: DataHistoryScalarFieldEnum | DataHistoryScalarFieldEnum[]
  }

  /**
   * DataHistory create
   */
  export type DataHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataHistory
     */
    select?: DataHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a DataHistory.
     */
    data: XOR<DataHistoryCreateInput, DataHistoryUncheckedCreateInput>
  }

  /**
   * DataHistory createMany
   */
  export type DataHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DataHistories.
     */
    data: DataHistoryCreateManyInput | DataHistoryCreateManyInput[]
  }

  /**
   * DataHistory createManyAndReturn
   */
  export type DataHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataHistory
     */
    select?: DataHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DataHistories.
     */
    data: DataHistoryCreateManyInput | DataHistoryCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DataHistory update
   */
  export type DataHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataHistory
     */
    select?: DataHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a DataHistory.
     */
    data: XOR<DataHistoryUpdateInput, DataHistoryUncheckedUpdateInput>
    /**
     * Choose, which DataHistory to update.
     */
    where: DataHistoryWhereUniqueInput
  }

  /**
   * DataHistory updateMany
   */
  export type DataHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DataHistories.
     */
    data: XOR<DataHistoryUpdateManyMutationInput, DataHistoryUncheckedUpdateManyInput>
    /**
     * Filter which DataHistories to update
     */
    where?: DataHistoryWhereInput
  }

  /**
   * DataHistory upsert
   */
  export type DataHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataHistory
     */
    select?: DataHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the DataHistory to update in case it exists.
     */
    where: DataHistoryWhereUniqueInput
    /**
     * In case the DataHistory found by the `where` argument doesn't exist, create a new DataHistory with this data.
     */
    create: XOR<DataHistoryCreateInput, DataHistoryUncheckedCreateInput>
    /**
     * In case the DataHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataHistoryUpdateInput, DataHistoryUncheckedUpdateInput>
  }

  /**
   * DataHistory delete
   */
  export type DataHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataHistory
     */
    select?: DataHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataHistoryInclude<ExtArgs> | null
    /**
     * Filter which DataHistory to delete.
     */
    where: DataHistoryWhereUniqueInput
  }

  /**
   * DataHistory deleteMany
   */
  export type DataHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataHistories to delete
     */
    where?: DataHistoryWhereInput
  }

  /**
   * DataHistory without action
   */
  export type DataHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataHistory
     */
    select?: DataHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataHistoryInclude<ExtArgs> | null
  }


  /**
   * Model LocalRecipe
   */

  export type AggregateLocalRecipe = {
    _count: LocalRecipeCountAggregateOutputType | null
    _avg: LocalRecipeAvgAggregateOutputType | null
    _sum: LocalRecipeSumAggregateOutputType | null
    _min: LocalRecipeMinAggregateOutputType | null
    _max: LocalRecipeMaxAggregateOutputType | null
  }

  export type LocalRecipeAvgAggregateOutputType = {
    id: number | null
    remoteId: number | null
  }

  export type LocalRecipeSumAggregateOutputType = {
    id: number | null
    remoteId: number | null
  }

  export type LocalRecipeMinAggregateOutputType = {
    id: number | null
    name: string | null
    concreteGrade: string | null
    version: string | null
    isActive: boolean | null
    recipeData: string | null
    syncStatus: string | null
    remoteId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocalRecipeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    concreteGrade: string | null
    version: string | null
    isActive: boolean | null
    recipeData: string | null
    syncStatus: string | null
    remoteId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocalRecipeCountAggregateOutputType = {
    id: number
    name: number
    concreteGrade: number
    version: number
    isActive: number
    recipeData: number
    syncStatus: number
    remoteId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LocalRecipeAvgAggregateInputType = {
    id?: true
    remoteId?: true
  }

  export type LocalRecipeSumAggregateInputType = {
    id?: true
    remoteId?: true
  }

  export type LocalRecipeMinAggregateInputType = {
    id?: true
    name?: true
    concreteGrade?: true
    version?: true
    isActive?: true
    recipeData?: true
    syncStatus?: true
    remoteId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocalRecipeMaxAggregateInputType = {
    id?: true
    name?: true
    concreteGrade?: true
    version?: true
    isActive?: true
    recipeData?: true
    syncStatus?: true
    remoteId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocalRecipeCountAggregateInputType = {
    id?: true
    name?: true
    concreteGrade?: true
    version?: true
    isActive?: true
    recipeData?: true
    syncStatus?: true
    remoteId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LocalRecipeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocalRecipe to aggregate.
     */
    where?: LocalRecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalRecipes to fetch.
     */
    orderBy?: LocalRecipeOrderByWithRelationInput | LocalRecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocalRecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalRecipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalRecipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LocalRecipes
    **/
    _count?: true | LocalRecipeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocalRecipeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocalRecipeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocalRecipeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocalRecipeMaxAggregateInputType
  }

  export type GetLocalRecipeAggregateType<T extends LocalRecipeAggregateArgs> = {
        [P in keyof T & keyof AggregateLocalRecipe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocalRecipe[P]>
      : GetScalarType<T[P], AggregateLocalRecipe[P]>
  }




  export type LocalRecipeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocalRecipeWhereInput
    orderBy?: LocalRecipeOrderByWithAggregationInput | LocalRecipeOrderByWithAggregationInput[]
    by: LocalRecipeScalarFieldEnum[] | LocalRecipeScalarFieldEnum
    having?: LocalRecipeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocalRecipeCountAggregateInputType | true
    _avg?: LocalRecipeAvgAggregateInputType
    _sum?: LocalRecipeSumAggregateInputType
    _min?: LocalRecipeMinAggregateInputType
    _max?: LocalRecipeMaxAggregateInputType
  }

  export type LocalRecipeGroupByOutputType = {
    id: number
    name: string
    concreteGrade: string
    version: string
    isActive: boolean
    recipeData: string
    syncStatus: string
    remoteId: number | null
    createdAt: Date
    updatedAt: Date
    _count: LocalRecipeCountAggregateOutputType | null
    _avg: LocalRecipeAvgAggregateOutputType | null
    _sum: LocalRecipeSumAggregateOutputType | null
    _min: LocalRecipeMinAggregateOutputType | null
    _max: LocalRecipeMaxAggregateOutputType | null
  }

  type GetLocalRecipeGroupByPayload<T extends LocalRecipeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocalRecipeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocalRecipeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocalRecipeGroupByOutputType[P]>
            : GetScalarType<T[P], LocalRecipeGroupByOutputType[P]>
        }
      >
    >


  export type LocalRecipeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    concreteGrade?: boolean
    version?: boolean
    isActive?: boolean
    recipeData?: boolean
    syncStatus?: boolean
    remoteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    batches?: boolean | LocalRecipe$batchesArgs<ExtArgs>
    _count?: boolean | LocalRecipeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["localRecipe"]>

  export type LocalRecipeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    concreteGrade?: boolean
    version?: boolean
    isActive?: boolean
    recipeData?: boolean
    syncStatus?: boolean
    remoteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["localRecipe"]>

  export type LocalRecipeSelectScalar = {
    id?: boolean
    name?: boolean
    concreteGrade?: boolean
    version?: boolean
    isActive?: boolean
    recipeData?: boolean
    syncStatus?: boolean
    remoteId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LocalRecipeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batches?: boolean | LocalRecipe$batchesArgs<ExtArgs>
    _count?: boolean | LocalRecipeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocalRecipeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LocalRecipePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LocalRecipe"
    objects: {
      batches: Prisma.$LocalBatchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      concreteGrade: string
      version: string
      isActive: boolean
      recipeData: string
      syncStatus: string
      remoteId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["localRecipe"]>
    composites: {}
  }

  type LocalRecipeGetPayload<S extends boolean | null | undefined | LocalRecipeDefaultArgs> = $Result.GetResult<Prisma.$LocalRecipePayload, S>

  type LocalRecipeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LocalRecipeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LocalRecipeCountAggregateInputType | true
    }

  export interface LocalRecipeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LocalRecipe'], meta: { name: 'LocalRecipe' } }
    /**
     * Find zero or one LocalRecipe that matches the filter.
     * @param {LocalRecipeFindUniqueArgs} args - Arguments to find a LocalRecipe
     * @example
     * // Get one LocalRecipe
     * const localRecipe = await prisma.localRecipe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocalRecipeFindUniqueArgs>(args: SelectSubset<T, LocalRecipeFindUniqueArgs<ExtArgs>>): Prisma__LocalRecipeClient<$Result.GetResult<Prisma.$LocalRecipePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LocalRecipe that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LocalRecipeFindUniqueOrThrowArgs} args - Arguments to find a LocalRecipe
     * @example
     * // Get one LocalRecipe
     * const localRecipe = await prisma.localRecipe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocalRecipeFindUniqueOrThrowArgs>(args: SelectSubset<T, LocalRecipeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocalRecipeClient<$Result.GetResult<Prisma.$LocalRecipePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LocalRecipe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalRecipeFindFirstArgs} args - Arguments to find a LocalRecipe
     * @example
     * // Get one LocalRecipe
     * const localRecipe = await prisma.localRecipe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocalRecipeFindFirstArgs>(args?: SelectSubset<T, LocalRecipeFindFirstArgs<ExtArgs>>): Prisma__LocalRecipeClient<$Result.GetResult<Prisma.$LocalRecipePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LocalRecipe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalRecipeFindFirstOrThrowArgs} args - Arguments to find a LocalRecipe
     * @example
     * // Get one LocalRecipe
     * const localRecipe = await prisma.localRecipe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocalRecipeFindFirstOrThrowArgs>(args?: SelectSubset<T, LocalRecipeFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocalRecipeClient<$Result.GetResult<Prisma.$LocalRecipePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LocalRecipes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalRecipeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LocalRecipes
     * const localRecipes = await prisma.localRecipe.findMany()
     * 
     * // Get first 10 LocalRecipes
     * const localRecipes = await prisma.localRecipe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const localRecipeWithIdOnly = await prisma.localRecipe.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocalRecipeFindManyArgs>(args?: SelectSubset<T, LocalRecipeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocalRecipePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LocalRecipe.
     * @param {LocalRecipeCreateArgs} args - Arguments to create a LocalRecipe.
     * @example
     * // Create one LocalRecipe
     * const LocalRecipe = await prisma.localRecipe.create({
     *   data: {
     *     // ... data to create a LocalRecipe
     *   }
     * })
     * 
     */
    create<T extends LocalRecipeCreateArgs>(args: SelectSubset<T, LocalRecipeCreateArgs<ExtArgs>>): Prisma__LocalRecipeClient<$Result.GetResult<Prisma.$LocalRecipePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LocalRecipes.
     * @param {LocalRecipeCreateManyArgs} args - Arguments to create many LocalRecipes.
     * @example
     * // Create many LocalRecipes
     * const localRecipe = await prisma.localRecipe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocalRecipeCreateManyArgs>(args?: SelectSubset<T, LocalRecipeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LocalRecipes and returns the data saved in the database.
     * @param {LocalRecipeCreateManyAndReturnArgs} args - Arguments to create many LocalRecipes.
     * @example
     * // Create many LocalRecipes
     * const localRecipe = await prisma.localRecipe.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LocalRecipes and only return the `id`
     * const localRecipeWithIdOnly = await prisma.localRecipe.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocalRecipeCreateManyAndReturnArgs>(args?: SelectSubset<T, LocalRecipeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocalRecipePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LocalRecipe.
     * @param {LocalRecipeDeleteArgs} args - Arguments to delete one LocalRecipe.
     * @example
     * // Delete one LocalRecipe
     * const LocalRecipe = await prisma.localRecipe.delete({
     *   where: {
     *     // ... filter to delete one LocalRecipe
     *   }
     * })
     * 
     */
    delete<T extends LocalRecipeDeleteArgs>(args: SelectSubset<T, LocalRecipeDeleteArgs<ExtArgs>>): Prisma__LocalRecipeClient<$Result.GetResult<Prisma.$LocalRecipePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LocalRecipe.
     * @param {LocalRecipeUpdateArgs} args - Arguments to update one LocalRecipe.
     * @example
     * // Update one LocalRecipe
     * const localRecipe = await prisma.localRecipe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocalRecipeUpdateArgs>(args: SelectSubset<T, LocalRecipeUpdateArgs<ExtArgs>>): Prisma__LocalRecipeClient<$Result.GetResult<Prisma.$LocalRecipePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LocalRecipes.
     * @param {LocalRecipeDeleteManyArgs} args - Arguments to filter LocalRecipes to delete.
     * @example
     * // Delete a few LocalRecipes
     * const { count } = await prisma.localRecipe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocalRecipeDeleteManyArgs>(args?: SelectSubset<T, LocalRecipeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocalRecipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalRecipeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LocalRecipes
     * const localRecipe = await prisma.localRecipe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocalRecipeUpdateManyArgs>(args: SelectSubset<T, LocalRecipeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LocalRecipe.
     * @param {LocalRecipeUpsertArgs} args - Arguments to update or create a LocalRecipe.
     * @example
     * // Update or create a LocalRecipe
     * const localRecipe = await prisma.localRecipe.upsert({
     *   create: {
     *     // ... data to create a LocalRecipe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LocalRecipe we want to update
     *   }
     * })
     */
    upsert<T extends LocalRecipeUpsertArgs>(args: SelectSubset<T, LocalRecipeUpsertArgs<ExtArgs>>): Prisma__LocalRecipeClient<$Result.GetResult<Prisma.$LocalRecipePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LocalRecipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalRecipeCountArgs} args - Arguments to filter LocalRecipes to count.
     * @example
     * // Count the number of LocalRecipes
     * const count = await prisma.localRecipe.count({
     *   where: {
     *     // ... the filter for the LocalRecipes we want to count
     *   }
     * })
    **/
    count<T extends LocalRecipeCountArgs>(
      args?: Subset<T, LocalRecipeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocalRecipeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LocalRecipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalRecipeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocalRecipeAggregateArgs>(args: Subset<T, LocalRecipeAggregateArgs>): Prisma.PrismaPromise<GetLocalRecipeAggregateType<T>>

    /**
     * Group by LocalRecipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalRecipeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocalRecipeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocalRecipeGroupByArgs['orderBy'] }
        : { orderBy?: LocalRecipeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocalRecipeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocalRecipeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LocalRecipe model
   */
  readonly fields: LocalRecipeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LocalRecipe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocalRecipeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    batches<T extends LocalRecipe$batchesArgs<ExtArgs> = {}>(args?: Subset<T, LocalRecipe$batchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocalBatchPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LocalRecipe model
   */ 
  interface LocalRecipeFieldRefs {
    readonly id: FieldRef<"LocalRecipe", 'Int'>
    readonly name: FieldRef<"LocalRecipe", 'String'>
    readonly concreteGrade: FieldRef<"LocalRecipe", 'String'>
    readonly version: FieldRef<"LocalRecipe", 'String'>
    readonly isActive: FieldRef<"LocalRecipe", 'Boolean'>
    readonly recipeData: FieldRef<"LocalRecipe", 'String'>
    readonly syncStatus: FieldRef<"LocalRecipe", 'String'>
    readonly remoteId: FieldRef<"LocalRecipe", 'Int'>
    readonly createdAt: FieldRef<"LocalRecipe", 'DateTime'>
    readonly updatedAt: FieldRef<"LocalRecipe", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LocalRecipe findUnique
   */
  export type LocalRecipeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalRecipe
     */
    select?: LocalRecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalRecipeInclude<ExtArgs> | null
    /**
     * Filter, which LocalRecipe to fetch.
     */
    where: LocalRecipeWhereUniqueInput
  }

  /**
   * LocalRecipe findUniqueOrThrow
   */
  export type LocalRecipeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalRecipe
     */
    select?: LocalRecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalRecipeInclude<ExtArgs> | null
    /**
     * Filter, which LocalRecipe to fetch.
     */
    where: LocalRecipeWhereUniqueInput
  }

  /**
   * LocalRecipe findFirst
   */
  export type LocalRecipeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalRecipe
     */
    select?: LocalRecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalRecipeInclude<ExtArgs> | null
    /**
     * Filter, which LocalRecipe to fetch.
     */
    where?: LocalRecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalRecipes to fetch.
     */
    orderBy?: LocalRecipeOrderByWithRelationInput | LocalRecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocalRecipes.
     */
    cursor?: LocalRecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalRecipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalRecipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocalRecipes.
     */
    distinct?: LocalRecipeScalarFieldEnum | LocalRecipeScalarFieldEnum[]
  }

  /**
   * LocalRecipe findFirstOrThrow
   */
  export type LocalRecipeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalRecipe
     */
    select?: LocalRecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalRecipeInclude<ExtArgs> | null
    /**
     * Filter, which LocalRecipe to fetch.
     */
    where?: LocalRecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalRecipes to fetch.
     */
    orderBy?: LocalRecipeOrderByWithRelationInput | LocalRecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocalRecipes.
     */
    cursor?: LocalRecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalRecipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalRecipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocalRecipes.
     */
    distinct?: LocalRecipeScalarFieldEnum | LocalRecipeScalarFieldEnum[]
  }

  /**
   * LocalRecipe findMany
   */
  export type LocalRecipeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalRecipe
     */
    select?: LocalRecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalRecipeInclude<ExtArgs> | null
    /**
     * Filter, which LocalRecipes to fetch.
     */
    where?: LocalRecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalRecipes to fetch.
     */
    orderBy?: LocalRecipeOrderByWithRelationInput | LocalRecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LocalRecipes.
     */
    cursor?: LocalRecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalRecipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalRecipes.
     */
    skip?: number
    distinct?: LocalRecipeScalarFieldEnum | LocalRecipeScalarFieldEnum[]
  }

  /**
   * LocalRecipe create
   */
  export type LocalRecipeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalRecipe
     */
    select?: LocalRecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalRecipeInclude<ExtArgs> | null
    /**
     * The data needed to create a LocalRecipe.
     */
    data: XOR<LocalRecipeCreateInput, LocalRecipeUncheckedCreateInput>
  }

  /**
   * LocalRecipe createMany
   */
  export type LocalRecipeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LocalRecipes.
     */
    data: LocalRecipeCreateManyInput | LocalRecipeCreateManyInput[]
  }

  /**
   * LocalRecipe createManyAndReturn
   */
  export type LocalRecipeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalRecipe
     */
    select?: LocalRecipeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LocalRecipes.
     */
    data: LocalRecipeCreateManyInput | LocalRecipeCreateManyInput[]
  }

  /**
   * LocalRecipe update
   */
  export type LocalRecipeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalRecipe
     */
    select?: LocalRecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalRecipeInclude<ExtArgs> | null
    /**
     * The data needed to update a LocalRecipe.
     */
    data: XOR<LocalRecipeUpdateInput, LocalRecipeUncheckedUpdateInput>
    /**
     * Choose, which LocalRecipe to update.
     */
    where: LocalRecipeWhereUniqueInput
  }

  /**
   * LocalRecipe updateMany
   */
  export type LocalRecipeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LocalRecipes.
     */
    data: XOR<LocalRecipeUpdateManyMutationInput, LocalRecipeUncheckedUpdateManyInput>
    /**
     * Filter which LocalRecipes to update
     */
    where?: LocalRecipeWhereInput
  }

  /**
   * LocalRecipe upsert
   */
  export type LocalRecipeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalRecipe
     */
    select?: LocalRecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalRecipeInclude<ExtArgs> | null
    /**
     * The filter to search for the LocalRecipe to update in case it exists.
     */
    where: LocalRecipeWhereUniqueInput
    /**
     * In case the LocalRecipe found by the `where` argument doesn't exist, create a new LocalRecipe with this data.
     */
    create: XOR<LocalRecipeCreateInput, LocalRecipeUncheckedCreateInput>
    /**
     * In case the LocalRecipe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocalRecipeUpdateInput, LocalRecipeUncheckedUpdateInput>
  }

  /**
   * LocalRecipe delete
   */
  export type LocalRecipeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalRecipe
     */
    select?: LocalRecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalRecipeInclude<ExtArgs> | null
    /**
     * Filter which LocalRecipe to delete.
     */
    where: LocalRecipeWhereUniqueInput
  }

  /**
   * LocalRecipe deleteMany
   */
  export type LocalRecipeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocalRecipes to delete
     */
    where?: LocalRecipeWhereInput
  }

  /**
   * LocalRecipe.batches
   */
  export type LocalRecipe$batchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalBatch
     */
    select?: LocalBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalBatchInclude<ExtArgs> | null
    where?: LocalBatchWhereInput
    orderBy?: LocalBatchOrderByWithRelationInput | LocalBatchOrderByWithRelationInput[]
    cursor?: LocalBatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocalBatchScalarFieldEnum | LocalBatchScalarFieldEnum[]
  }

  /**
   * LocalRecipe without action
   */
  export type LocalRecipeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalRecipe
     */
    select?: LocalRecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalRecipeInclude<ExtArgs> | null
  }


  /**
   * Model LocalBatch
   */

  export type AggregateLocalBatch = {
    _count: LocalBatchCountAggregateOutputType | null
    _avg: LocalBatchAvgAggregateOutputType | null
    _sum: LocalBatchSumAggregateOutputType | null
    _min: LocalBatchMinAggregateOutputType | null
    _max: LocalBatchMaxAggregateOutputType | null
  }

  export type LocalBatchAvgAggregateOutputType = {
    id: number | null
    recipeId: number | null
    volume: number | null
    remoteId: number | null
  }

  export type LocalBatchSumAggregateOutputType = {
    id: number | null
    recipeId: number | null
    volume: number | null
    remoteId: number | null
  }

  export type LocalBatchMinAggregateOutputType = {
    id: number | null
    batchNumber: string | null
    recipeId: number | null
    volume: number | null
    status: string | null
    startTime: Date | null
    endTime: Date | null
    operatorName: string | null
    syncStatus: string | null
    remoteId: number | null
    createdAt: Date | null
  }

  export type LocalBatchMaxAggregateOutputType = {
    id: number | null
    batchNumber: string | null
    recipeId: number | null
    volume: number | null
    status: string | null
    startTime: Date | null
    endTime: Date | null
    operatorName: string | null
    syncStatus: string | null
    remoteId: number | null
    createdAt: Date | null
  }

  export type LocalBatchCountAggregateOutputType = {
    id: number
    batchNumber: number
    recipeId: number
    volume: number
    status: number
    startTime: number
    endTime: number
    operatorName: number
    syncStatus: number
    remoteId: number
    createdAt: number
    _all: number
  }


  export type LocalBatchAvgAggregateInputType = {
    id?: true
    recipeId?: true
    volume?: true
    remoteId?: true
  }

  export type LocalBatchSumAggregateInputType = {
    id?: true
    recipeId?: true
    volume?: true
    remoteId?: true
  }

  export type LocalBatchMinAggregateInputType = {
    id?: true
    batchNumber?: true
    recipeId?: true
    volume?: true
    status?: true
    startTime?: true
    endTime?: true
    operatorName?: true
    syncStatus?: true
    remoteId?: true
    createdAt?: true
  }

  export type LocalBatchMaxAggregateInputType = {
    id?: true
    batchNumber?: true
    recipeId?: true
    volume?: true
    status?: true
    startTime?: true
    endTime?: true
    operatorName?: true
    syncStatus?: true
    remoteId?: true
    createdAt?: true
  }

  export type LocalBatchCountAggregateInputType = {
    id?: true
    batchNumber?: true
    recipeId?: true
    volume?: true
    status?: true
    startTime?: true
    endTime?: true
    operatorName?: true
    syncStatus?: true
    remoteId?: true
    createdAt?: true
    _all?: true
  }

  export type LocalBatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocalBatch to aggregate.
     */
    where?: LocalBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalBatches to fetch.
     */
    orderBy?: LocalBatchOrderByWithRelationInput | LocalBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocalBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LocalBatches
    **/
    _count?: true | LocalBatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocalBatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocalBatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocalBatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocalBatchMaxAggregateInputType
  }

  export type GetLocalBatchAggregateType<T extends LocalBatchAggregateArgs> = {
        [P in keyof T & keyof AggregateLocalBatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocalBatch[P]>
      : GetScalarType<T[P], AggregateLocalBatch[P]>
  }




  export type LocalBatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocalBatchWhereInput
    orderBy?: LocalBatchOrderByWithAggregationInput | LocalBatchOrderByWithAggregationInput[]
    by: LocalBatchScalarFieldEnum[] | LocalBatchScalarFieldEnum
    having?: LocalBatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocalBatchCountAggregateInputType | true
    _avg?: LocalBatchAvgAggregateInputType
    _sum?: LocalBatchSumAggregateInputType
    _min?: LocalBatchMinAggregateInputType
    _max?: LocalBatchMaxAggregateInputType
  }

  export type LocalBatchGroupByOutputType = {
    id: number
    batchNumber: string
    recipeId: number
    volume: number
    status: string
    startTime: Date | null
    endTime: Date | null
    operatorName: string | null
    syncStatus: string
    remoteId: number | null
    createdAt: Date
    _count: LocalBatchCountAggregateOutputType | null
    _avg: LocalBatchAvgAggregateOutputType | null
    _sum: LocalBatchSumAggregateOutputType | null
    _min: LocalBatchMinAggregateOutputType | null
    _max: LocalBatchMaxAggregateOutputType | null
  }

  type GetLocalBatchGroupByPayload<T extends LocalBatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocalBatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocalBatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocalBatchGroupByOutputType[P]>
            : GetScalarType<T[P], LocalBatchGroupByOutputType[P]>
        }
      >
    >


  export type LocalBatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchNumber?: boolean
    recipeId?: boolean
    volume?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    operatorName?: boolean
    syncStatus?: boolean
    remoteId?: boolean
    createdAt?: boolean
    recipe?: boolean | LocalRecipeDefaultArgs<ExtArgs>
    batchingRecords?: boolean | LocalBatch$batchingRecordsArgs<ExtArgs>
    _count?: boolean | LocalBatchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["localBatch"]>

  export type LocalBatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchNumber?: boolean
    recipeId?: boolean
    volume?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    operatorName?: boolean
    syncStatus?: boolean
    remoteId?: boolean
    createdAt?: boolean
    recipe?: boolean | LocalRecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["localBatch"]>

  export type LocalBatchSelectScalar = {
    id?: boolean
    batchNumber?: boolean
    recipeId?: boolean
    volume?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    operatorName?: boolean
    syncStatus?: boolean
    remoteId?: boolean
    createdAt?: boolean
  }

  export type LocalBatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | LocalRecipeDefaultArgs<ExtArgs>
    batchingRecords?: boolean | LocalBatch$batchingRecordsArgs<ExtArgs>
    _count?: boolean | LocalBatchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocalBatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | LocalRecipeDefaultArgs<ExtArgs>
  }

  export type $LocalBatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LocalBatch"
    objects: {
      recipe: Prisma.$LocalRecipePayload<ExtArgs>
      batchingRecords: Prisma.$LocalBatchingRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      batchNumber: string
      recipeId: number
      volume: number
      status: string
      startTime: Date | null
      endTime: Date | null
      operatorName: string | null
      syncStatus: string
      remoteId: number | null
      createdAt: Date
    }, ExtArgs["result"]["localBatch"]>
    composites: {}
  }

  type LocalBatchGetPayload<S extends boolean | null | undefined | LocalBatchDefaultArgs> = $Result.GetResult<Prisma.$LocalBatchPayload, S>

  type LocalBatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LocalBatchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LocalBatchCountAggregateInputType | true
    }

  export interface LocalBatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LocalBatch'], meta: { name: 'LocalBatch' } }
    /**
     * Find zero or one LocalBatch that matches the filter.
     * @param {LocalBatchFindUniqueArgs} args - Arguments to find a LocalBatch
     * @example
     * // Get one LocalBatch
     * const localBatch = await prisma.localBatch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocalBatchFindUniqueArgs>(args: SelectSubset<T, LocalBatchFindUniqueArgs<ExtArgs>>): Prisma__LocalBatchClient<$Result.GetResult<Prisma.$LocalBatchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LocalBatch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LocalBatchFindUniqueOrThrowArgs} args - Arguments to find a LocalBatch
     * @example
     * // Get one LocalBatch
     * const localBatch = await prisma.localBatch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocalBatchFindUniqueOrThrowArgs>(args: SelectSubset<T, LocalBatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocalBatchClient<$Result.GetResult<Prisma.$LocalBatchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LocalBatch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalBatchFindFirstArgs} args - Arguments to find a LocalBatch
     * @example
     * // Get one LocalBatch
     * const localBatch = await prisma.localBatch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocalBatchFindFirstArgs>(args?: SelectSubset<T, LocalBatchFindFirstArgs<ExtArgs>>): Prisma__LocalBatchClient<$Result.GetResult<Prisma.$LocalBatchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LocalBatch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalBatchFindFirstOrThrowArgs} args - Arguments to find a LocalBatch
     * @example
     * // Get one LocalBatch
     * const localBatch = await prisma.localBatch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocalBatchFindFirstOrThrowArgs>(args?: SelectSubset<T, LocalBatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocalBatchClient<$Result.GetResult<Prisma.$LocalBatchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LocalBatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalBatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LocalBatches
     * const localBatches = await prisma.localBatch.findMany()
     * 
     * // Get first 10 LocalBatches
     * const localBatches = await prisma.localBatch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const localBatchWithIdOnly = await prisma.localBatch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocalBatchFindManyArgs>(args?: SelectSubset<T, LocalBatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocalBatchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LocalBatch.
     * @param {LocalBatchCreateArgs} args - Arguments to create a LocalBatch.
     * @example
     * // Create one LocalBatch
     * const LocalBatch = await prisma.localBatch.create({
     *   data: {
     *     // ... data to create a LocalBatch
     *   }
     * })
     * 
     */
    create<T extends LocalBatchCreateArgs>(args: SelectSubset<T, LocalBatchCreateArgs<ExtArgs>>): Prisma__LocalBatchClient<$Result.GetResult<Prisma.$LocalBatchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LocalBatches.
     * @param {LocalBatchCreateManyArgs} args - Arguments to create many LocalBatches.
     * @example
     * // Create many LocalBatches
     * const localBatch = await prisma.localBatch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocalBatchCreateManyArgs>(args?: SelectSubset<T, LocalBatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LocalBatches and returns the data saved in the database.
     * @param {LocalBatchCreateManyAndReturnArgs} args - Arguments to create many LocalBatches.
     * @example
     * // Create many LocalBatches
     * const localBatch = await prisma.localBatch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LocalBatches and only return the `id`
     * const localBatchWithIdOnly = await prisma.localBatch.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocalBatchCreateManyAndReturnArgs>(args?: SelectSubset<T, LocalBatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocalBatchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LocalBatch.
     * @param {LocalBatchDeleteArgs} args - Arguments to delete one LocalBatch.
     * @example
     * // Delete one LocalBatch
     * const LocalBatch = await prisma.localBatch.delete({
     *   where: {
     *     // ... filter to delete one LocalBatch
     *   }
     * })
     * 
     */
    delete<T extends LocalBatchDeleteArgs>(args: SelectSubset<T, LocalBatchDeleteArgs<ExtArgs>>): Prisma__LocalBatchClient<$Result.GetResult<Prisma.$LocalBatchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LocalBatch.
     * @param {LocalBatchUpdateArgs} args - Arguments to update one LocalBatch.
     * @example
     * // Update one LocalBatch
     * const localBatch = await prisma.localBatch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocalBatchUpdateArgs>(args: SelectSubset<T, LocalBatchUpdateArgs<ExtArgs>>): Prisma__LocalBatchClient<$Result.GetResult<Prisma.$LocalBatchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LocalBatches.
     * @param {LocalBatchDeleteManyArgs} args - Arguments to filter LocalBatches to delete.
     * @example
     * // Delete a few LocalBatches
     * const { count } = await prisma.localBatch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocalBatchDeleteManyArgs>(args?: SelectSubset<T, LocalBatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocalBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalBatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LocalBatches
     * const localBatch = await prisma.localBatch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocalBatchUpdateManyArgs>(args: SelectSubset<T, LocalBatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LocalBatch.
     * @param {LocalBatchUpsertArgs} args - Arguments to update or create a LocalBatch.
     * @example
     * // Update or create a LocalBatch
     * const localBatch = await prisma.localBatch.upsert({
     *   create: {
     *     // ... data to create a LocalBatch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LocalBatch we want to update
     *   }
     * })
     */
    upsert<T extends LocalBatchUpsertArgs>(args: SelectSubset<T, LocalBatchUpsertArgs<ExtArgs>>): Prisma__LocalBatchClient<$Result.GetResult<Prisma.$LocalBatchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LocalBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalBatchCountArgs} args - Arguments to filter LocalBatches to count.
     * @example
     * // Count the number of LocalBatches
     * const count = await prisma.localBatch.count({
     *   where: {
     *     // ... the filter for the LocalBatches we want to count
     *   }
     * })
    **/
    count<T extends LocalBatchCountArgs>(
      args?: Subset<T, LocalBatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocalBatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LocalBatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalBatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocalBatchAggregateArgs>(args: Subset<T, LocalBatchAggregateArgs>): Prisma.PrismaPromise<GetLocalBatchAggregateType<T>>

    /**
     * Group by LocalBatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalBatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocalBatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocalBatchGroupByArgs['orderBy'] }
        : { orderBy?: LocalBatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocalBatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocalBatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LocalBatch model
   */
  readonly fields: LocalBatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LocalBatch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocalBatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipe<T extends LocalRecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocalRecipeDefaultArgs<ExtArgs>>): Prisma__LocalRecipeClient<$Result.GetResult<Prisma.$LocalRecipePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    batchingRecords<T extends LocalBatch$batchingRecordsArgs<ExtArgs> = {}>(args?: Subset<T, LocalBatch$batchingRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocalBatchingRecordPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LocalBatch model
   */ 
  interface LocalBatchFieldRefs {
    readonly id: FieldRef<"LocalBatch", 'Int'>
    readonly batchNumber: FieldRef<"LocalBatch", 'String'>
    readonly recipeId: FieldRef<"LocalBatch", 'Int'>
    readonly volume: FieldRef<"LocalBatch", 'Float'>
    readonly status: FieldRef<"LocalBatch", 'String'>
    readonly startTime: FieldRef<"LocalBatch", 'DateTime'>
    readonly endTime: FieldRef<"LocalBatch", 'DateTime'>
    readonly operatorName: FieldRef<"LocalBatch", 'String'>
    readonly syncStatus: FieldRef<"LocalBatch", 'String'>
    readonly remoteId: FieldRef<"LocalBatch", 'Int'>
    readonly createdAt: FieldRef<"LocalBatch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LocalBatch findUnique
   */
  export type LocalBatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalBatch
     */
    select?: LocalBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalBatchInclude<ExtArgs> | null
    /**
     * Filter, which LocalBatch to fetch.
     */
    where: LocalBatchWhereUniqueInput
  }

  /**
   * LocalBatch findUniqueOrThrow
   */
  export type LocalBatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalBatch
     */
    select?: LocalBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalBatchInclude<ExtArgs> | null
    /**
     * Filter, which LocalBatch to fetch.
     */
    where: LocalBatchWhereUniqueInput
  }

  /**
   * LocalBatch findFirst
   */
  export type LocalBatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalBatch
     */
    select?: LocalBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalBatchInclude<ExtArgs> | null
    /**
     * Filter, which LocalBatch to fetch.
     */
    where?: LocalBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalBatches to fetch.
     */
    orderBy?: LocalBatchOrderByWithRelationInput | LocalBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocalBatches.
     */
    cursor?: LocalBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocalBatches.
     */
    distinct?: LocalBatchScalarFieldEnum | LocalBatchScalarFieldEnum[]
  }

  /**
   * LocalBatch findFirstOrThrow
   */
  export type LocalBatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalBatch
     */
    select?: LocalBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalBatchInclude<ExtArgs> | null
    /**
     * Filter, which LocalBatch to fetch.
     */
    where?: LocalBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalBatches to fetch.
     */
    orderBy?: LocalBatchOrderByWithRelationInput | LocalBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocalBatches.
     */
    cursor?: LocalBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocalBatches.
     */
    distinct?: LocalBatchScalarFieldEnum | LocalBatchScalarFieldEnum[]
  }

  /**
   * LocalBatch findMany
   */
  export type LocalBatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalBatch
     */
    select?: LocalBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalBatchInclude<ExtArgs> | null
    /**
     * Filter, which LocalBatches to fetch.
     */
    where?: LocalBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalBatches to fetch.
     */
    orderBy?: LocalBatchOrderByWithRelationInput | LocalBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LocalBatches.
     */
    cursor?: LocalBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalBatches.
     */
    skip?: number
    distinct?: LocalBatchScalarFieldEnum | LocalBatchScalarFieldEnum[]
  }

  /**
   * LocalBatch create
   */
  export type LocalBatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalBatch
     */
    select?: LocalBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalBatchInclude<ExtArgs> | null
    /**
     * The data needed to create a LocalBatch.
     */
    data: XOR<LocalBatchCreateInput, LocalBatchUncheckedCreateInput>
  }

  /**
   * LocalBatch createMany
   */
  export type LocalBatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LocalBatches.
     */
    data: LocalBatchCreateManyInput | LocalBatchCreateManyInput[]
  }

  /**
   * LocalBatch createManyAndReturn
   */
  export type LocalBatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalBatch
     */
    select?: LocalBatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LocalBatches.
     */
    data: LocalBatchCreateManyInput | LocalBatchCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalBatchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LocalBatch update
   */
  export type LocalBatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalBatch
     */
    select?: LocalBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalBatchInclude<ExtArgs> | null
    /**
     * The data needed to update a LocalBatch.
     */
    data: XOR<LocalBatchUpdateInput, LocalBatchUncheckedUpdateInput>
    /**
     * Choose, which LocalBatch to update.
     */
    where: LocalBatchWhereUniqueInput
  }

  /**
   * LocalBatch updateMany
   */
  export type LocalBatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LocalBatches.
     */
    data: XOR<LocalBatchUpdateManyMutationInput, LocalBatchUncheckedUpdateManyInput>
    /**
     * Filter which LocalBatches to update
     */
    where?: LocalBatchWhereInput
  }

  /**
   * LocalBatch upsert
   */
  export type LocalBatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalBatch
     */
    select?: LocalBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalBatchInclude<ExtArgs> | null
    /**
     * The filter to search for the LocalBatch to update in case it exists.
     */
    where: LocalBatchWhereUniqueInput
    /**
     * In case the LocalBatch found by the `where` argument doesn't exist, create a new LocalBatch with this data.
     */
    create: XOR<LocalBatchCreateInput, LocalBatchUncheckedCreateInput>
    /**
     * In case the LocalBatch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocalBatchUpdateInput, LocalBatchUncheckedUpdateInput>
  }

  /**
   * LocalBatch delete
   */
  export type LocalBatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalBatch
     */
    select?: LocalBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalBatchInclude<ExtArgs> | null
    /**
     * Filter which LocalBatch to delete.
     */
    where: LocalBatchWhereUniqueInput
  }

  /**
   * LocalBatch deleteMany
   */
  export type LocalBatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocalBatches to delete
     */
    where?: LocalBatchWhereInput
  }

  /**
   * LocalBatch.batchingRecords
   */
  export type LocalBatch$batchingRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalBatchingRecord
     */
    select?: LocalBatchingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalBatchingRecordInclude<ExtArgs> | null
    where?: LocalBatchingRecordWhereInput
    orderBy?: LocalBatchingRecordOrderByWithRelationInput | LocalBatchingRecordOrderByWithRelationInput[]
    cursor?: LocalBatchingRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocalBatchingRecordScalarFieldEnum | LocalBatchingRecordScalarFieldEnum[]
  }

  /**
   * LocalBatch without action
   */
  export type LocalBatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalBatch
     */
    select?: LocalBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalBatchInclude<ExtArgs> | null
  }


  /**
   * Model LocalBatchingRecord
   */

  export type AggregateLocalBatchingRecord = {
    _count: LocalBatchingRecordCountAggregateOutputType | null
    _avg: LocalBatchingRecordAvgAggregateOutputType | null
    _sum: LocalBatchingRecordSumAggregateOutputType | null
    _min: LocalBatchingRecordMinAggregateOutputType | null
    _max: LocalBatchingRecordMaxAggregateOutputType | null
  }

  export type LocalBatchingRecordAvgAggregateOutputType = {
    id: number | null
    batchId: number | null
    targetWeight: number | null
    actualWeight: number | null
    deviation: number | null
  }

  export type LocalBatchingRecordSumAggregateOutputType = {
    id: number | null
    batchId: number | null
    targetWeight: number | null
    actualWeight: number | null
    deviation: number | null
  }

  export type LocalBatchingRecordMinAggregateOutputType = {
    id: number | null
    batchId: number | null
    materialName: string | null
    targetWeight: number | null
    actualWeight: number | null
    deviation: number | null
    toleranceCheck: string | null
    timestamp: Date | null
  }

  export type LocalBatchingRecordMaxAggregateOutputType = {
    id: number | null
    batchId: number | null
    materialName: string | null
    targetWeight: number | null
    actualWeight: number | null
    deviation: number | null
    toleranceCheck: string | null
    timestamp: Date | null
  }

  export type LocalBatchingRecordCountAggregateOutputType = {
    id: number
    batchId: number
    materialName: number
    targetWeight: number
    actualWeight: number
    deviation: number
    toleranceCheck: number
    timestamp: number
    _all: number
  }


  export type LocalBatchingRecordAvgAggregateInputType = {
    id?: true
    batchId?: true
    targetWeight?: true
    actualWeight?: true
    deviation?: true
  }

  export type LocalBatchingRecordSumAggregateInputType = {
    id?: true
    batchId?: true
    targetWeight?: true
    actualWeight?: true
    deviation?: true
  }

  export type LocalBatchingRecordMinAggregateInputType = {
    id?: true
    batchId?: true
    materialName?: true
    targetWeight?: true
    actualWeight?: true
    deviation?: true
    toleranceCheck?: true
    timestamp?: true
  }

  export type LocalBatchingRecordMaxAggregateInputType = {
    id?: true
    batchId?: true
    materialName?: true
    targetWeight?: true
    actualWeight?: true
    deviation?: true
    toleranceCheck?: true
    timestamp?: true
  }

  export type LocalBatchingRecordCountAggregateInputType = {
    id?: true
    batchId?: true
    materialName?: true
    targetWeight?: true
    actualWeight?: true
    deviation?: true
    toleranceCheck?: true
    timestamp?: true
    _all?: true
  }

  export type LocalBatchingRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocalBatchingRecord to aggregate.
     */
    where?: LocalBatchingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalBatchingRecords to fetch.
     */
    orderBy?: LocalBatchingRecordOrderByWithRelationInput | LocalBatchingRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocalBatchingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalBatchingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalBatchingRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LocalBatchingRecords
    **/
    _count?: true | LocalBatchingRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocalBatchingRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocalBatchingRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocalBatchingRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocalBatchingRecordMaxAggregateInputType
  }

  export type GetLocalBatchingRecordAggregateType<T extends LocalBatchingRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateLocalBatchingRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocalBatchingRecord[P]>
      : GetScalarType<T[P], AggregateLocalBatchingRecord[P]>
  }




  export type LocalBatchingRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocalBatchingRecordWhereInput
    orderBy?: LocalBatchingRecordOrderByWithAggregationInput | LocalBatchingRecordOrderByWithAggregationInput[]
    by: LocalBatchingRecordScalarFieldEnum[] | LocalBatchingRecordScalarFieldEnum
    having?: LocalBatchingRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocalBatchingRecordCountAggregateInputType | true
    _avg?: LocalBatchingRecordAvgAggregateInputType
    _sum?: LocalBatchingRecordSumAggregateInputType
    _min?: LocalBatchingRecordMinAggregateInputType
    _max?: LocalBatchingRecordMaxAggregateInputType
  }

  export type LocalBatchingRecordGroupByOutputType = {
    id: number
    batchId: number
    materialName: string
    targetWeight: number
    actualWeight: number
    deviation: number | null
    toleranceCheck: string
    timestamp: Date
    _count: LocalBatchingRecordCountAggregateOutputType | null
    _avg: LocalBatchingRecordAvgAggregateOutputType | null
    _sum: LocalBatchingRecordSumAggregateOutputType | null
    _min: LocalBatchingRecordMinAggregateOutputType | null
    _max: LocalBatchingRecordMaxAggregateOutputType | null
  }

  type GetLocalBatchingRecordGroupByPayload<T extends LocalBatchingRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocalBatchingRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocalBatchingRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocalBatchingRecordGroupByOutputType[P]>
            : GetScalarType<T[P], LocalBatchingRecordGroupByOutputType[P]>
        }
      >
    >


  export type LocalBatchingRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchId?: boolean
    materialName?: boolean
    targetWeight?: boolean
    actualWeight?: boolean
    deviation?: boolean
    toleranceCheck?: boolean
    timestamp?: boolean
    batch?: boolean | LocalBatchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["localBatchingRecord"]>

  export type LocalBatchingRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchId?: boolean
    materialName?: boolean
    targetWeight?: boolean
    actualWeight?: boolean
    deviation?: boolean
    toleranceCheck?: boolean
    timestamp?: boolean
    batch?: boolean | LocalBatchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["localBatchingRecord"]>

  export type LocalBatchingRecordSelectScalar = {
    id?: boolean
    batchId?: boolean
    materialName?: boolean
    targetWeight?: boolean
    actualWeight?: boolean
    deviation?: boolean
    toleranceCheck?: boolean
    timestamp?: boolean
  }

  export type LocalBatchingRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | LocalBatchDefaultArgs<ExtArgs>
  }
  export type LocalBatchingRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | LocalBatchDefaultArgs<ExtArgs>
  }

  export type $LocalBatchingRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LocalBatchingRecord"
    objects: {
      batch: Prisma.$LocalBatchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      batchId: number
      materialName: string
      targetWeight: number
      actualWeight: number
      deviation: number | null
      toleranceCheck: string
      timestamp: Date
    }, ExtArgs["result"]["localBatchingRecord"]>
    composites: {}
  }

  type LocalBatchingRecordGetPayload<S extends boolean | null | undefined | LocalBatchingRecordDefaultArgs> = $Result.GetResult<Prisma.$LocalBatchingRecordPayload, S>

  type LocalBatchingRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LocalBatchingRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LocalBatchingRecordCountAggregateInputType | true
    }

  export interface LocalBatchingRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LocalBatchingRecord'], meta: { name: 'LocalBatchingRecord' } }
    /**
     * Find zero or one LocalBatchingRecord that matches the filter.
     * @param {LocalBatchingRecordFindUniqueArgs} args - Arguments to find a LocalBatchingRecord
     * @example
     * // Get one LocalBatchingRecord
     * const localBatchingRecord = await prisma.localBatchingRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocalBatchingRecordFindUniqueArgs>(args: SelectSubset<T, LocalBatchingRecordFindUniqueArgs<ExtArgs>>): Prisma__LocalBatchingRecordClient<$Result.GetResult<Prisma.$LocalBatchingRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LocalBatchingRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LocalBatchingRecordFindUniqueOrThrowArgs} args - Arguments to find a LocalBatchingRecord
     * @example
     * // Get one LocalBatchingRecord
     * const localBatchingRecord = await prisma.localBatchingRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocalBatchingRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, LocalBatchingRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocalBatchingRecordClient<$Result.GetResult<Prisma.$LocalBatchingRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LocalBatchingRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalBatchingRecordFindFirstArgs} args - Arguments to find a LocalBatchingRecord
     * @example
     * // Get one LocalBatchingRecord
     * const localBatchingRecord = await prisma.localBatchingRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocalBatchingRecordFindFirstArgs>(args?: SelectSubset<T, LocalBatchingRecordFindFirstArgs<ExtArgs>>): Prisma__LocalBatchingRecordClient<$Result.GetResult<Prisma.$LocalBatchingRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LocalBatchingRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalBatchingRecordFindFirstOrThrowArgs} args - Arguments to find a LocalBatchingRecord
     * @example
     * // Get one LocalBatchingRecord
     * const localBatchingRecord = await prisma.localBatchingRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocalBatchingRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, LocalBatchingRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocalBatchingRecordClient<$Result.GetResult<Prisma.$LocalBatchingRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LocalBatchingRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalBatchingRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LocalBatchingRecords
     * const localBatchingRecords = await prisma.localBatchingRecord.findMany()
     * 
     * // Get first 10 LocalBatchingRecords
     * const localBatchingRecords = await prisma.localBatchingRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const localBatchingRecordWithIdOnly = await prisma.localBatchingRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocalBatchingRecordFindManyArgs>(args?: SelectSubset<T, LocalBatchingRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocalBatchingRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LocalBatchingRecord.
     * @param {LocalBatchingRecordCreateArgs} args - Arguments to create a LocalBatchingRecord.
     * @example
     * // Create one LocalBatchingRecord
     * const LocalBatchingRecord = await prisma.localBatchingRecord.create({
     *   data: {
     *     // ... data to create a LocalBatchingRecord
     *   }
     * })
     * 
     */
    create<T extends LocalBatchingRecordCreateArgs>(args: SelectSubset<T, LocalBatchingRecordCreateArgs<ExtArgs>>): Prisma__LocalBatchingRecordClient<$Result.GetResult<Prisma.$LocalBatchingRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LocalBatchingRecords.
     * @param {LocalBatchingRecordCreateManyArgs} args - Arguments to create many LocalBatchingRecords.
     * @example
     * // Create many LocalBatchingRecords
     * const localBatchingRecord = await prisma.localBatchingRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocalBatchingRecordCreateManyArgs>(args?: SelectSubset<T, LocalBatchingRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LocalBatchingRecords and returns the data saved in the database.
     * @param {LocalBatchingRecordCreateManyAndReturnArgs} args - Arguments to create many LocalBatchingRecords.
     * @example
     * // Create many LocalBatchingRecords
     * const localBatchingRecord = await prisma.localBatchingRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LocalBatchingRecords and only return the `id`
     * const localBatchingRecordWithIdOnly = await prisma.localBatchingRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocalBatchingRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, LocalBatchingRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocalBatchingRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LocalBatchingRecord.
     * @param {LocalBatchingRecordDeleteArgs} args - Arguments to delete one LocalBatchingRecord.
     * @example
     * // Delete one LocalBatchingRecord
     * const LocalBatchingRecord = await prisma.localBatchingRecord.delete({
     *   where: {
     *     // ... filter to delete one LocalBatchingRecord
     *   }
     * })
     * 
     */
    delete<T extends LocalBatchingRecordDeleteArgs>(args: SelectSubset<T, LocalBatchingRecordDeleteArgs<ExtArgs>>): Prisma__LocalBatchingRecordClient<$Result.GetResult<Prisma.$LocalBatchingRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LocalBatchingRecord.
     * @param {LocalBatchingRecordUpdateArgs} args - Arguments to update one LocalBatchingRecord.
     * @example
     * // Update one LocalBatchingRecord
     * const localBatchingRecord = await prisma.localBatchingRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocalBatchingRecordUpdateArgs>(args: SelectSubset<T, LocalBatchingRecordUpdateArgs<ExtArgs>>): Prisma__LocalBatchingRecordClient<$Result.GetResult<Prisma.$LocalBatchingRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LocalBatchingRecords.
     * @param {LocalBatchingRecordDeleteManyArgs} args - Arguments to filter LocalBatchingRecords to delete.
     * @example
     * // Delete a few LocalBatchingRecords
     * const { count } = await prisma.localBatchingRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocalBatchingRecordDeleteManyArgs>(args?: SelectSubset<T, LocalBatchingRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocalBatchingRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalBatchingRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LocalBatchingRecords
     * const localBatchingRecord = await prisma.localBatchingRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocalBatchingRecordUpdateManyArgs>(args: SelectSubset<T, LocalBatchingRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LocalBatchingRecord.
     * @param {LocalBatchingRecordUpsertArgs} args - Arguments to update or create a LocalBatchingRecord.
     * @example
     * // Update or create a LocalBatchingRecord
     * const localBatchingRecord = await prisma.localBatchingRecord.upsert({
     *   create: {
     *     // ... data to create a LocalBatchingRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LocalBatchingRecord we want to update
     *   }
     * })
     */
    upsert<T extends LocalBatchingRecordUpsertArgs>(args: SelectSubset<T, LocalBatchingRecordUpsertArgs<ExtArgs>>): Prisma__LocalBatchingRecordClient<$Result.GetResult<Prisma.$LocalBatchingRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LocalBatchingRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalBatchingRecordCountArgs} args - Arguments to filter LocalBatchingRecords to count.
     * @example
     * // Count the number of LocalBatchingRecords
     * const count = await prisma.localBatchingRecord.count({
     *   where: {
     *     // ... the filter for the LocalBatchingRecords we want to count
     *   }
     * })
    **/
    count<T extends LocalBatchingRecordCountArgs>(
      args?: Subset<T, LocalBatchingRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocalBatchingRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LocalBatchingRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalBatchingRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocalBatchingRecordAggregateArgs>(args: Subset<T, LocalBatchingRecordAggregateArgs>): Prisma.PrismaPromise<GetLocalBatchingRecordAggregateType<T>>

    /**
     * Group by LocalBatchingRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalBatchingRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocalBatchingRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocalBatchingRecordGroupByArgs['orderBy'] }
        : { orderBy?: LocalBatchingRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocalBatchingRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocalBatchingRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LocalBatchingRecord model
   */
  readonly fields: LocalBatchingRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LocalBatchingRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocalBatchingRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    batch<T extends LocalBatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocalBatchDefaultArgs<ExtArgs>>): Prisma__LocalBatchClient<$Result.GetResult<Prisma.$LocalBatchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LocalBatchingRecord model
   */ 
  interface LocalBatchingRecordFieldRefs {
    readonly id: FieldRef<"LocalBatchingRecord", 'Int'>
    readonly batchId: FieldRef<"LocalBatchingRecord", 'Int'>
    readonly materialName: FieldRef<"LocalBatchingRecord", 'String'>
    readonly targetWeight: FieldRef<"LocalBatchingRecord", 'Float'>
    readonly actualWeight: FieldRef<"LocalBatchingRecord", 'Float'>
    readonly deviation: FieldRef<"LocalBatchingRecord", 'Float'>
    readonly toleranceCheck: FieldRef<"LocalBatchingRecord", 'String'>
    readonly timestamp: FieldRef<"LocalBatchingRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LocalBatchingRecord findUnique
   */
  export type LocalBatchingRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalBatchingRecord
     */
    select?: LocalBatchingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalBatchingRecordInclude<ExtArgs> | null
    /**
     * Filter, which LocalBatchingRecord to fetch.
     */
    where: LocalBatchingRecordWhereUniqueInput
  }

  /**
   * LocalBatchingRecord findUniqueOrThrow
   */
  export type LocalBatchingRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalBatchingRecord
     */
    select?: LocalBatchingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalBatchingRecordInclude<ExtArgs> | null
    /**
     * Filter, which LocalBatchingRecord to fetch.
     */
    where: LocalBatchingRecordWhereUniqueInput
  }

  /**
   * LocalBatchingRecord findFirst
   */
  export type LocalBatchingRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalBatchingRecord
     */
    select?: LocalBatchingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalBatchingRecordInclude<ExtArgs> | null
    /**
     * Filter, which LocalBatchingRecord to fetch.
     */
    where?: LocalBatchingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalBatchingRecords to fetch.
     */
    orderBy?: LocalBatchingRecordOrderByWithRelationInput | LocalBatchingRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocalBatchingRecords.
     */
    cursor?: LocalBatchingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalBatchingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalBatchingRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocalBatchingRecords.
     */
    distinct?: LocalBatchingRecordScalarFieldEnum | LocalBatchingRecordScalarFieldEnum[]
  }

  /**
   * LocalBatchingRecord findFirstOrThrow
   */
  export type LocalBatchingRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalBatchingRecord
     */
    select?: LocalBatchingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalBatchingRecordInclude<ExtArgs> | null
    /**
     * Filter, which LocalBatchingRecord to fetch.
     */
    where?: LocalBatchingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalBatchingRecords to fetch.
     */
    orderBy?: LocalBatchingRecordOrderByWithRelationInput | LocalBatchingRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocalBatchingRecords.
     */
    cursor?: LocalBatchingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalBatchingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalBatchingRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocalBatchingRecords.
     */
    distinct?: LocalBatchingRecordScalarFieldEnum | LocalBatchingRecordScalarFieldEnum[]
  }

  /**
   * LocalBatchingRecord findMany
   */
  export type LocalBatchingRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalBatchingRecord
     */
    select?: LocalBatchingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalBatchingRecordInclude<ExtArgs> | null
    /**
     * Filter, which LocalBatchingRecords to fetch.
     */
    where?: LocalBatchingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalBatchingRecords to fetch.
     */
    orderBy?: LocalBatchingRecordOrderByWithRelationInput | LocalBatchingRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LocalBatchingRecords.
     */
    cursor?: LocalBatchingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalBatchingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalBatchingRecords.
     */
    skip?: number
    distinct?: LocalBatchingRecordScalarFieldEnum | LocalBatchingRecordScalarFieldEnum[]
  }

  /**
   * LocalBatchingRecord create
   */
  export type LocalBatchingRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalBatchingRecord
     */
    select?: LocalBatchingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalBatchingRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a LocalBatchingRecord.
     */
    data: XOR<LocalBatchingRecordCreateInput, LocalBatchingRecordUncheckedCreateInput>
  }

  /**
   * LocalBatchingRecord createMany
   */
  export type LocalBatchingRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LocalBatchingRecords.
     */
    data: LocalBatchingRecordCreateManyInput | LocalBatchingRecordCreateManyInput[]
  }

  /**
   * LocalBatchingRecord createManyAndReturn
   */
  export type LocalBatchingRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalBatchingRecord
     */
    select?: LocalBatchingRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LocalBatchingRecords.
     */
    data: LocalBatchingRecordCreateManyInput | LocalBatchingRecordCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalBatchingRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LocalBatchingRecord update
   */
  export type LocalBatchingRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalBatchingRecord
     */
    select?: LocalBatchingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalBatchingRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a LocalBatchingRecord.
     */
    data: XOR<LocalBatchingRecordUpdateInput, LocalBatchingRecordUncheckedUpdateInput>
    /**
     * Choose, which LocalBatchingRecord to update.
     */
    where: LocalBatchingRecordWhereUniqueInput
  }

  /**
   * LocalBatchingRecord updateMany
   */
  export type LocalBatchingRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LocalBatchingRecords.
     */
    data: XOR<LocalBatchingRecordUpdateManyMutationInput, LocalBatchingRecordUncheckedUpdateManyInput>
    /**
     * Filter which LocalBatchingRecords to update
     */
    where?: LocalBatchingRecordWhereInput
  }

  /**
   * LocalBatchingRecord upsert
   */
  export type LocalBatchingRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalBatchingRecord
     */
    select?: LocalBatchingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalBatchingRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the LocalBatchingRecord to update in case it exists.
     */
    where: LocalBatchingRecordWhereUniqueInput
    /**
     * In case the LocalBatchingRecord found by the `where` argument doesn't exist, create a new LocalBatchingRecord with this data.
     */
    create: XOR<LocalBatchingRecordCreateInput, LocalBatchingRecordUncheckedCreateInput>
    /**
     * In case the LocalBatchingRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocalBatchingRecordUpdateInput, LocalBatchingRecordUncheckedUpdateInput>
  }

  /**
   * LocalBatchingRecord delete
   */
  export type LocalBatchingRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalBatchingRecord
     */
    select?: LocalBatchingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalBatchingRecordInclude<ExtArgs> | null
    /**
     * Filter which LocalBatchingRecord to delete.
     */
    where: LocalBatchingRecordWhereUniqueInput
  }

  /**
   * LocalBatchingRecord deleteMany
   */
  export type LocalBatchingRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocalBatchingRecords to delete
     */
    where?: LocalBatchingRecordWhereInput
  }

  /**
   * LocalBatchingRecord without action
   */
  export type LocalBatchingRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalBatchingRecord
     */
    select?: LocalBatchingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalBatchingRecordInclude<ExtArgs> | null
  }


  /**
   * Model LocalAlarm
   */

  export type AggregateLocalAlarm = {
    _count: LocalAlarmCountAggregateOutputType | null
    _avg: LocalAlarmAvgAggregateOutputType | null
    _sum: LocalAlarmSumAggregateOutputType | null
    _min: LocalAlarmMinAggregateOutputType | null
    _max: LocalAlarmMaxAggregateOutputType | null
  }

  export type LocalAlarmAvgAggregateOutputType = {
    id: number | null
    remoteId: number | null
  }

  export type LocalAlarmSumAggregateOutputType = {
    id: number | null
    remoteId: number | null
  }

  export type LocalAlarmMinAggregateOutputType = {
    id: number | null
    alarmType: string | null
    source: string | null
    message: string | null
    severity: string | null
    acknowledged: boolean | null
    resolved: boolean | null
    syncStatus: string | null
    remoteId: number | null
    timestamp: Date | null
    resolvedAt: Date | null
  }

  export type LocalAlarmMaxAggregateOutputType = {
    id: number | null
    alarmType: string | null
    source: string | null
    message: string | null
    severity: string | null
    acknowledged: boolean | null
    resolved: boolean | null
    syncStatus: string | null
    remoteId: number | null
    timestamp: Date | null
    resolvedAt: Date | null
  }

  export type LocalAlarmCountAggregateOutputType = {
    id: number
    alarmType: number
    source: number
    message: number
    severity: number
    acknowledged: number
    resolved: number
    syncStatus: number
    remoteId: number
    timestamp: number
    resolvedAt: number
    _all: number
  }


  export type LocalAlarmAvgAggregateInputType = {
    id?: true
    remoteId?: true
  }

  export type LocalAlarmSumAggregateInputType = {
    id?: true
    remoteId?: true
  }

  export type LocalAlarmMinAggregateInputType = {
    id?: true
    alarmType?: true
    source?: true
    message?: true
    severity?: true
    acknowledged?: true
    resolved?: true
    syncStatus?: true
    remoteId?: true
    timestamp?: true
    resolvedAt?: true
  }

  export type LocalAlarmMaxAggregateInputType = {
    id?: true
    alarmType?: true
    source?: true
    message?: true
    severity?: true
    acknowledged?: true
    resolved?: true
    syncStatus?: true
    remoteId?: true
    timestamp?: true
    resolvedAt?: true
  }

  export type LocalAlarmCountAggregateInputType = {
    id?: true
    alarmType?: true
    source?: true
    message?: true
    severity?: true
    acknowledged?: true
    resolved?: true
    syncStatus?: true
    remoteId?: true
    timestamp?: true
    resolvedAt?: true
    _all?: true
  }

  export type LocalAlarmAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocalAlarm to aggregate.
     */
    where?: LocalAlarmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalAlarms to fetch.
     */
    orderBy?: LocalAlarmOrderByWithRelationInput | LocalAlarmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocalAlarmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalAlarms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalAlarms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LocalAlarms
    **/
    _count?: true | LocalAlarmCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocalAlarmAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocalAlarmSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocalAlarmMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocalAlarmMaxAggregateInputType
  }

  export type GetLocalAlarmAggregateType<T extends LocalAlarmAggregateArgs> = {
        [P in keyof T & keyof AggregateLocalAlarm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocalAlarm[P]>
      : GetScalarType<T[P], AggregateLocalAlarm[P]>
  }




  export type LocalAlarmGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocalAlarmWhereInput
    orderBy?: LocalAlarmOrderByWithAggregationInput | LocalAlarmOrderByWithAggregationInput[]
    by: LocalAlarmScalarFieldEnum[] | LocalAlarmScalarFieldEnum
    having?: LocalAlarmScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocalAlarmCountAggregateInputType | true
    _avg?: LocalAlarmAvgAggregateInputType
    _sum?: LocalAlarmSumAggregateInputType
    _min?: LocalAlarmMinAggregateInputType
    _max?: LocalAlarmMaxAggregateInputType
  }

  export type LocalAlarmGroupByOutputType = {
    id: number
    alarmType: string
    source: string
    message: string
    severity: string
    acknowledged: boolean
    resolved: boolean
    syncStatus: string
    remoteId: number | null
    timestamp: Date
    resolvedAt: Date | null
    _count: LocalAlarmCountAggregateOutputType | null
    _avg: LocalAlarmAvgAggregateOutputType | null
    _sum: LocalAlarmSumAggregateOutputType | null
    _min: LocalAlarmMinAggregateOutputType | null
    _max: LocalAlarmMaxAggregateOutputType | null
  }

  type GetLocalAlarmGroupByPayload<T extends LocalAlarmGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocalAlarmGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocalAlarmGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocalAlarmGroupByOutputType[P]>
            : GetScalarType<T[P], LocalAlarmGroupByOutputType[P]>
        }
      >
    >


  export type LocalAlarmSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alarmType?: boolean
    source?: boolean
    message?: boolean
    severity?: boolean
    acknowledged?: boolean
    resolved?: boolean
    syncStatus?: boolean
    remoteId?: boolean
    timestamp?: boolean
    resolvedAt?: boolean
  }, ExtArgs["result"]["localAlarm"]>

  export type LocalAlarmSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    alarmType?: boolean
    source?: boolean
    message?: boolean
    severity?: boolean
    acknowledged?: boolean
    resolved?: boolean
    syncStatus?: boolean
    remoteId?: boolean
    timestamp?: boolean
    resolvedAt?: boolean
  }, ExtArgs["result"]["localAlarm"]>

  export type LocalAlarmSelectScalar = {
    id?: boolean
    alarmType?: boolean
    source?: boolean
    message?: boolean
    severity?: boolean
    acknowledged?: boolean
    resolved?: boolean
    syncStatus?: boolean
    remoteId?: boolean
    timestamp?: boolean
    resolvedAt?: boolean
  }


  export type $LocalAlarmPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LocalAlarm"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      alarmType: string
      source: string
      message: string
      severity: string
      acknowledged: boolean
      resolved: boolean
      syncStatus: string
      remoteId: number | null
      timestamp: Date
      resolvedAt: Date | null
    }, ExtArgs["result"]["localAlarm"]>
    composites: {}
  }

  type LocalAlarmGetPayload<S extends boolean | null | undefined | LocalAlarmDefaultArgs> = $Result.GetResult<Prisma.$LocalAlarmPayload, S>

  type LocalAlarmCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LocalAlarmFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LocalAlarmCountAggregateInputType | true
    }

  export interface LocalAlarmDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LocalAlarm'], meta: { name: 'LocalAlarm' } }
    /**
     * Find zero or one LocalAlarm that matches the filter.
     * @param {LocalAlarmFindUniqueArgs} args - Arguments to find a LocalAlarm
     * @example
     * // Get one LocalAlarm
     * const localAlarm = await prisma.localAlarm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocalAlarmFindUniqueArgs>(args: SelectSubset<T, LocalAlarmFindUniqueArgs<ExtArgs>>): Prisma__LocalAlarmClient<$Result.GetResult<Prisma.$LocalAlarmPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LocalAlarm that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LocalAlarmFindUniqueOrThrowArgs} args - Arguments to find a LocalAlarm
     * @example
     * // Get one LocalAlarm
     * const localAlarm = await prisma.localAlarm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocalAlarmFindUniqueOrThrowArgs>(args: SelectSubset<T, LocalAlarmFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocalAlarmClient<$Result.GetResult<Prisma.$LocalAlarmPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LocalAlarm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalAlarmFindFirstArgs} args - Arguments to find a LocalAlarm
     * @example
     * // Get one LocalAlarm
     * const localAlarm = await prisma.localAlarm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocalAlarmFindFirstArgs>(args?: SelectSubset<T, LocalAlarmFindFirstArgs<ExtArgs>>): Prisma__LocalAlarmClient<$Result.GetResult<Prisma.$LocalAlarmPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LocalAlarm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalAlarmFindFirstOrThrowArgs} args - Arguments to find a LocalAlarm
     * @example
     * // Get one LocalAlarm
     * const localAlarm = await prisma.localAlarm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocalAlarmFindFirstOrThrowArgs>(args?: SelectSubset<T, LocalAlarmFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocalAlarmClient<$Result.GetResult<Prisma.$LocalAlarmPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LocalAlarms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalAlarmFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LocalAlarms
     * const localAlarms = await prisma.localAlarm.findMany()
     * 
     * // Get first 10 LocalAlarms
     * const localAlarms = await prisma.localAlarm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const localAlarmWithIdOnly = await prisma.localAlarm.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocalAlarmFindManyArgs>(args?: SelectSubset<T, LocalAlarmFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocalAlarmPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LocalAlarm.
     * @param {LocalAlarmCreateArgs} args - Arguments to create a LocalAlarm.
     * @example
     * // Create one LocalAlarm
     * const LocalAlarm = await prisma.localAlarm.create({
     *   data: {
     *     // ... data to create a LocalAlarm
     *   }
     * })
     * 
     */
    create<T extends LocalAlarmCreateArgs>(args: SelectSubset<T, LocalAlarmCreateArgs<ExtArgs>>): Prisma__LocalAlarmClient<$Result.GetResult<Prisma.$LocalAlarmPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LocalAlarms.
     * @param {LocalAlarmCreateManyArgs} args - Arguments to create many LocalAlarms.
     * @example
     * // Create many LocalAlarms
     * const localAlarm = await prisma.localAlarm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocalAlarmCreateManyArgs>(args?: SelectSubset<T, LocalAlarmCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LocalAlarms and returns the data saved in the database.
     * @param {LocalAlarmCreateManyAndReturnArgs} args - Arguments to create many LocalAlarms.
     * @example
     * // Create many LocalAlarms
     * const localAlarm = await prisma.localAlarm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LocalAlarms and only return the `id`
     * const localAlarmWithIdOnly = await prisma.localAlarm.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocalAlarmCreateManyAndReturnArgs>(args?: SelectSubset<T, LocalAlarmCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocalAlarmPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LocalAlarm.
     * @param {LocalAlarmDeleteArgs} args - Arguments to delete one LocalAlarm.
     * @example
     * // Delete one LocalAlarm
     * const LocalAlarm = await prisma.localAlarm.delete({
     *   where: {
     *     // ... filter to delete one LocalAlarm
     *   }
     * })
     * 
     */
    delete<T extends LocalAlarmDeleteArgs>(args: SelectSubset<T, LocalAlarmDeleteArgs<ExtArgs>>): Prisma__LocalAlarmClient<$Result.GetResult<Prisma.$LocalAlarmPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LocalAlarm.
     * @param {LocalAlarmUpdateArgs} args - Arguments to update one LocalAlarm.
     * @example
     * // Update one LocalAlarm
     * const localAlarm = await prisma.localAlarm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocalAlarmUpdateArgs>(args: SelectSubset<T, LocalAlarmUpdateArgs<ExtArgs>>): Prisma__LocalAlarmClient<$Result.GetResult<Prisma.$LocalAlarmPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LocalAlarms.
     * @param {LocalAlarmDeleteManyArgs} args - Arguments to filter LocalAlarms to delete.
     * @example
     * // Delete a few LocalAlarms
     * const { count } = await prisma.localAlarm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocalAlarmDeleteManyArgs>(args?: SelectSubset<T, LocalAlarmDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocalAlarms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalAlarmUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LocalAlarms
     * const localAlarm = await prisma.localAlarm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocalAlarmUpdateManyArgs>(args: SelectSubset<T, LocalAlarmUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LocalAlarm.
     * @param {LocalAlarmUpsertArgs} args - Arguments to update or create a LocalAlarm.
     * @example
     * // Update or create a LocalAlarm
     * const localAlarm = await prisma.localAlarm.upsert({
     *   create: {
     *     // ... data to create a LocalAlarm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LocalAlarm we want to update
     *   }
     * })
     */
    upsert<T extends LocalAlarmUpsertArgs>(args: SelectSubset<T, LocalAlarmUpsertArgs<ExtArgs>>): Prisma__LocalAlarmClient<$Result.GetResult<Prisma.$LocalAlarmPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LocalAlarms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalAlarmCountArgs} args - Arguments to filter LocalAlarms to count.
     * @example
     * // Count the number of LocalAlarms
     * const count = await prisma.localAlarm.count({
     *   where: {
     *     // ... the filter for the LocalAlarms we want to count
     *   }
     * })
    **/
    count<T extends LocalAlarmCountArgs>(
      args?: Subset<T, LocalAlarmCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocalAlarmCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LocalAlarm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalAlarmAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocalAlarmAggregateArgs>(args: Subset<T, LocalAlarmAggregateArgs>): Prisma.PrismaPromise<GetLocalAlarmAggregateType<T>>

    /**
     * Group by LocalAlarm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalAlarmGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocalAlarmGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocalAlarmGroupByArgs['orderBy'] }
        : { orderBy?: LocalAlarmGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocalAlarmGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocalAlarmGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LocalAlarm model
   */
  readonly fields: LocalAlarmFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LocalAlarm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocalAlarmClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LocalAlarm model
   */ 
  interface LocalAlarmFieldRefs {
    readonly id: FieldRef<"LocalAlarm", 'Int'>
    readonly alarmType: FieldRef<"LocalAlarm", 'String'>
    readonly source: FieldRef<"LocalAlarm", 'String'>
    readonly message: FieldRef<"LocalAlarm", 'String'>
    readonly severity: FieldRef<"LocalAlarm", 'String'>
    readonly acknowledged: FieldRef<"LocalAlarm", 'Boolean'>
    readonly resolved: FieldRef<"LocalAlarm", 'Boolean'>
    readonly syncStatus: FieldRef<"LocalAlarm", 'String'>
    readonly remoteId: FieldRef<"LocalAlarm", 'Int'>
    readonly timestamp: FieldRef<"LocalAlarm", 'DateTime'>
    readonly resolvedAt: FieldRef<"LocalAlarm", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LocalAlarm findUnique
   */
  export type LocalAlarmFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalAlarm
     */
    select?: LocalAlarmSelect<ExtArgs> | null
    /**
     * Filter, which LocalAlarm to fetch.
     */
    where: LocalAlarmWhereUniqueInput
  }

  /**
   * LocalAlarm findUniqueOrThrow
   */
  export type LocalAlarmFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalAlarm
     */
    select?: LocalAlarmSelect<ExtArgs> | null
    /**
     * Filter, which LocalAlarm to fetch.
     */
    where: LocalAlarmWhereUniqueInput
  }

  /**
   * LocalAlarm findFirst
   */
  export type LocalAlarmFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalAlarm
     */
    select?: LocalAlarmSelect<ExtArgs> | null
    /**
     * Filter, which LocalAlarm to fetch.
     */
    where?: LocalAlarmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalAlarms to fetch.
     */
    orderBy?: LocalAlarmOrderByWithRelationInput | LocalAlarmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocalAlarms.
     */
    cursor?: LocalAlarmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalAlarms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalAlarms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocalAlarms.
     */
    distinct?: LocalAlarmScalarFieldEnum | LocalAlarmScalarFieldEnum[]
  }

  /**
   * LocalAlarm findFirstOrThrow
   */
  export type LocalAlarmFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalAlarm
     */
    select?: LocalAlarmSelect<ExtArgs> | null
    /**
     * Filter, which LocalAlarm to fetch.
     */
    where?: LocalAlarmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalAlarms to fetch.
     */
    orderBy?: LocalAlarmOrderByWithRelationInput | LocalAlarmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocalAlarms.
     */
    cursor?: LocalAlarmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalAlarms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalAlarms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocalAlarms.
     */
    distinct?: LocalAlarmScalarFieldEnum | LocalAlarmScalarFieldEnum[]
  }

  /**
   * LocalAlarm findMany
   */
  export type LocalAlarmFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalAlarm
     */
    select?: LocalAlarmSelect<ExtArgs> | null
    /**
     * Filter, which LocalAlarms to fetch.
     */
    where?: LocalAlarmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalAlarms to fetch.
     */
    orderBy?: LocalAlarmOrderByWithRelationInput | LocalAlarmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LocalAlarms.
     */
    cursor?: LocalAlarmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalAlarms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalAlarms.
     */
    skip?: number
    distinct?: LocalAlarmScalarFieldEnum | LocalAlarmScalarFieldEnum[]
  }

  /**
   * LocalAlarm create
   */
  export type LocalAlarmCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalAlarm
     */
    select?: LocalAlarmSelect<ExtArgs> | null
    /**
     * The data needed to create a LocalAlarm.
     */
    data: XOR<LocalAlarmCreateInput, LocalAlarmUncheckedCreateInput>
  }

  /**
   * LocalAlarm createMany
   */
  export type LocalAlarmCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LocalAlarms.
     */
    data: LocalAlarmCreateManyInput | LocalAlarmCreateManyInput[]
  }

  /**
   * LocalAlarm createManyAndReturn
   */
  export type LocalAlarmCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalAlarm
     */
    select?: LocalAlarmSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LocalAlarms.
     */
    data: LocalAlarmCreateManyInput | LocalAlarmCreateManyInput[]
  }

  /**
   * LocalAlarm update
   */
  export type LocalAlarmUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalAlarm
     */
    select?: LocalAlarmSelect<ExtArgs> | null
    /**
     * The data needed to update a LocalAlarm.
     */
    data: XOR<LocalAlarmUpdateInput, LocalAlarmUncheckedUpdateInput>
    /**
     * Choose, which LocalAlarm to update.
     */
    where: LocalAlarmWhereUniqueInput
  }

  /**
   * LocalAlarm updateMany
   */
  export type LocalAlarmUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LocalAlarms.
     */
    data: XOR<LocalAlarmUpdateManyMutationInput, LocalAlarmUncheckedUpdateManyInput>
    /**
     * Filter which LocalAlarms to update
     */
    where?: LocalAlarmWhereInput
  }

  /**
   * LocalAlarm upsert
   */
  export type LocalAlarmUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalAlarm
     */
    select?: LocalAlarmSelect<ExtArgs> | null
    /**
     * The filter to search for the LocalAlarm to update in case it exists.
     */
    where: LocalAlarmWhereUniqueInput
    /**
     * In case the LocalAlarm found by the `where` argument doesn't exist, create a new LocalAlarm with this data.
     */
    create: XOR<LocalAlarmCreateInput, LocalAlarmUncheckedCreateInput>
    /**
     * In case the LocalAlarm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocalAlarmUpdateInput, LocalAlarmUncheckedUpdateInput>
  }

  /**
   * LocalAlarm delete
   */
  export type LocalAlarmDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalAlarm
     */
    select?: LocalAlarmSelect<ExtArgs> | null
    /**
     * Filter which LocalAlarm to delete.
     */
    where: LocalAlarmWhereUniqueInput
  }

  /**
   * LocalAlarm deleteMany
   */
  export type LocalAlarmDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocalAlarms to delete
     */
    where?: LocalAlarmWhereInput
  }

  /**
   * LocalAlarm without action
   */
  export type LocalAlarmDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalAlarm
     */
    select?: LocalAlarmSelect<ExtArgs> | null
  }


  /**
   * Model LocalLog
   */

  export type AggregateLocalLog = {
    _count: LocalLogCountAggregateOutputType | null
    _avg: LocalLogAvgAggregateOutputType | null
    _sum: LocalLogSumAggregateOutputType | null
    _min: LocalLogMinAggregateOutputType | null
    _max: LocalLogMaxAggregateOutputType | null
  }

  export type LocalLogAvgAggregateOutputType = {
    id: number | null
  }

  export type LocalLogSumAggregateOutputType = {
    id: number | null
  }

  export type LocalLogMinAggregateOutputType = {
    id: number | null
    level: string | null
    module: string | null
    action: string | null
    message: string | null
    data: string | null
    syncStatus: string | null
    timestamp: Date | null
  }

  export type LocalLogMaxAggregateOutputType = {
    id: number | null
    level: string | null
    module: string | null
    action: string | null
    message: string | null
    data: string | null
    syncStatus: string | null
    timestamp: Date | null
  }

  export type LocalLogCountAggregateOutputType = {
    id: number
    level: number
    module: number
    action: number
    message: number
    data: number
    syncStatus: number
    timestamp: number
    _all: number
  }


  export type LocalLogAvgAggregateInputType = {
    id?: true
  }

  export type LocalLogSumAggregateInputType = {
    id?: true
  }

  export type LocalLogMinAggregateInputType = {
    id?: true
    level?: true
    module?: true
    action?: true
    message?: true
    data?: true
    syncStatus?: true
    timestamp?: true
  }

  export type LocalLogMaxAggregateInputType = {
    id?: true
    level?: true
    module?: true
    action?: true
    message?: true
    data?: true
    syncStatus?: true
    timestamp?: true
  }

  export type LocalLogCountAggregateInputType = {
    id?: true
    level?: true
    module?: true
    action?: true
    message?: true
    data?: true
    syncStatus?: true
    timestamp?: true
    _all?: true
  }

  export type LocalLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocalLog to aggregate.
     */
    where?: LocalLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalLogs to fetch.
     */
    orderBy?: LocalLogOrderByWithRelationInput | LocalLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocalLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LocalLogs
    **/
    _count?: true | LocalLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocalLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocalLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocalLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocalLogMaxAggregateInputType
  }

  export type GetLocalLogAggregateType<T extends LocalLogAggregateArgs> = {
        [P in keyof T & keyof AggregateLocalLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocalLog[P]>
      : GetScalarType<T[P], AggregateLocalLog[P]>
  }




  export type LocalLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocalLogWhereInput
    orderBy?: LocalLogOrderByWithAggregationInput | LocalLogOrderByWithAggregationInput[]
    by: LocalLogScalarFieldEnum[] | LocalLogScalarFieldEnum
    having?: LocalLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocalLogCountAggregateInputType | true
    _avg?: LocalLogAvgAggregateInputType
    _sum?: LocalLogSumAggregateInputType
    _min?: LocalLogMinAggregateInputType
    _max?: LocalLogMaxAggregateInputType
  }

  export type LocalLogGroupByOutputType = {
    id: number
    level: string
    module: string
    action: string
    message: string
    data: string | null
    syncStatus: string
    timestamp: Date
    _count: LocalLogCountAggregateOutputType | null
    _avg: LocalLogAvgAggregateOutputType | null
    _sum: LocalLogSumAggregateOutputType | null
    _min: LocalLogMinAggregateOutputType | null
    _max: LocalLogMaxAggregateOutputType | null
  }

  type GetLocalLogGroupByPayload<T extends LocalLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocalLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocalLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocalLogGroupByOutputType[P]>
            : GetScalarType<T[P], LocalLogGroupByOutputType[P]>
        }
      >
    >


  export type LocalLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    module?: boolean
    action?: boolean
    message?: boolean
    data?: boolean
    syncStatus?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["localLog"]>

  export type LocalLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    module?: boolean
    action?: boolean
    message?: boolean
    data?: boolean
    syncStatus?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["localLog"]>

  export type LocalLogSelectScalar = {
    id?: boolean
    level?: boolean
    module?: boolean
    action?: boolean
    message?: boolean
    data?: boolean
    syncStatus?: boolean
    timestamp?: boolean
  }


  export type $LocalLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LocalLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      level: string
      module: string
      action: string
      message: string
      data: string | null
      syncStatus: string
      timestamp: Date
    }, ExtArgs["result"]["localLog"]>
    composites: {}
  }

  type LocalLogGetPayload<S extends boolean | null | undefined | LocalLogDefaultArgs> = $Result.GetResult<Prisma.$LocalLogPayload, S>

  type LocalLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LocalLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LocalLogCountAggregateInputType | true
    }

  export interface LocalLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LocalLog'], meta: { name: 'LocalLog' } }
    /**
     * Find zero or one LocalLog that matches the filter.
     * @param {LocalLogFindUniqueArgs} args - Arguments to find a LocalLog
     * @example
     * // Get one LocalLog
     * const localLog = await prisma.localLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocalLogFindUniqueArgs>(args: SelectSubset<T, LocalLogFindUniqueArgs<ExtArgs>>): Prisma__LocalLogClient<$Result.GetResult<Prisma.$LocalLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LocalLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LocalLogFindUniqueOrThrowArgs} args - Arguments to find a LocalLog
     * @example
     * // Get one LocalLog
     * const localLog = await prisma.localLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocalLogFindUniqueOrThrowArgs>(args: SelectSubset<T, LocalLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocalLogClient<$Result.GetResult<Prisma.$LocalLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LocalLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalLogFindFirstArgs} args - Arguments to find a LocalLog
     * @example
     * // Get one LocalLog
     * const localLog = await prisma.localLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocalLogFindFirstArgs>(args?: SelectSubset<T, LocalLogFindFirstArgs<ExtArgs>>): Prisma__LocalLogClient<$Result.GetResult<Prisma.$LocalLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LocalLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalLogFindFirstOrThrowArgs} args - Arguments to find a LocalLog
     * @example
     * // Get one LocalLog
     * const localLog = await prisma.localLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocalLogFindFirstOrThrowArgs>(args?: SelectSubset<T, LocalLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocalLogClient<$Result.GetResult<Prisma.$LocalLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LocalLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LocalLogs
     * const localLogs = await prisma.localLog.findMany()
     * 
     * // Get first 10 LocalLogs
     * const localLogs = await prisma.localLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const localLogWithIdOnly = await prisma.localLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocalLogFindManyArgs>(args?: SelectSubset<T, LocalLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocalLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LocalLog.
     * @param {LocalLogCreateArgs} args - Arguments to create a LocalLog.
     * @example
     * // Create one LocalLog
     * const LocalLog = await prisma.localLog.create({
     *   data: {
     *     // ... data to create a LocalLog
     *   }
     * })
     * 
     */
    create<T extends LocalLogCreateArgs>(args: SelectSubset<T, LocalLogCreateArgs<ExtArgs>>): Prisma__LocalLogClient<$Result.GetResult<Prisma.$LocalLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LocalLogs.
     * @param {LocalLogCreateManyArgs} args - Arguments to create many LocalLogs.
     * @example
     * // Create many LocalLogs
     * const localLog = await prisma.localLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocalLogCreateManyArgs>(args?: SelectSubset<T, LocalLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LocalLogs and returns the data saved in the database.
     * @param {LocalLogCreateManyAndReturnArgs} args - Arguments to create many LocalLogs.
     * @example
     * // Create many LocalLogs
     * const localLog = await prisma.localLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LocalLogs and only return the `id`
     * const localLogWithIdOnly = await prisma.localLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocalLogCreateManyAndReturnArgs>(args?: SelectSubset<T, LocalLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocalLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LocalLog.
     * @param {LocalLogDeleteArgs} args - Arguments to delete one LocalLog.
     * @example
     * // Delete one LocalLog
     * const LocalLog = await prisma.localLog.delete({
     *   where: {
     *     // ... filter to delete one LocalLog
     *   }
     * })
     * 
     */
    delete<T extends LocalLogDeleteArgs>(args: SelectSubset<T, LocalLogDeleteArgs<ExtArgs>>): Prisma__LocalLogClient<$Result.GetResult<Prisma.$LocalLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LocalLog.
     * @param {LocalLogUpdateArgs} args - Arguments to update one LocalLog.
     * @example
     * // Update one LocalLog
     * const localLog = await prisma.localLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocalLogUpdateArgs>(args: SelectSubset<T, LocalLogUpdateArgs<ExtArgs>>): Prisma__LocalLogClient<$Result.GetResult<Prisma.$LocalLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LocalLogs.
     * @param {LocalLogDeleteManyArgs} args - Arguments to filter LocalLogs to delete.
     * @example
     * // Delete a few LocalLogs
     * const { count } = await prisma.localLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocalLogDeleteManyArgs>(args?: SelectSubset<T, LocalLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocalLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LocalLogs
     * const localLog = await prisma.localLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocalLogUpdateManyArgs>(args: SelectSubset<T, LocalLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LocalLog.
     * @param {LocalLogUpsertArgs} args - Arguments to update or create a LocalLog.
     * @example
     * // Update or create a LocalLog
     * const localLog = await prisma.localLog.upsert({
     *   create: {
     *     // ... data to create a LocalLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LocalLog we want to update
     *   }
     * })
     */
    upsert<T extends LocalLogUpsertArgs>(args: SelectSubset<T, LocalLogUpsertArgs<ExtArgs>>): Prisma__LocalLogClient<$Result.GetResult<Prisma.$LocalLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LocalLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalLogCountArgs} args - Arguments to filter LocalLogs to count.
     * @example
     * // Count the number of LocalLogs
     * const count = await prisma.localLog.count({
     *   where: {
     *     // ... the filter for the LocalLogs we want to count
     *   }
     * })
    **/
    count<T extends LocalLogCountArgs>(
      args?: Subset<T, LocalLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocalLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LocalLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocalLogAggregateArgs>(args: Subset<T, LocalLogAggregateArgs>): Prisma.PrismaPromise<GetLocalLogAggregateType<T>>

    /**
     * Group by LocalLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocalLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocalLogGroupByArgs['orderBy'] }
        : { orderBy?: LocalLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocalLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocalLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LocalLog model
   */
  readonly fields: LocalLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LocalLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocalLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LocalLog model
   */ 
  interface LocalLogFieldRefs {
    readonly id: FieldRef<"LocalLog", 'Int'>
    readonly level: FieldRef<"LocalLog", 'String'>
    readonly module: FieldRef<"LocalLog", 'String'>
    readonly action: FieldRef<"LocalLog", 'String'>
    readonly message: FieldRef<"LocalLog", 'String'>
    readonly data: FieldRef<"LocalLog", 'String'>
    readonly syncStatus: FieldRef<"LocalLog", 'String'>
    readonly timestamp: FieldRef<"LocalLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LocalLog findUnique
   */
  export type LocalLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalLog
     */
    select?: LocalLogSelect<ExtArgs> | null
    /**
     * Filter, which LocalLog to fetch.
     */
    where: LocalLogWhereUniqueInput
  }

  /**
   * LocalLog findUniqueOrThrow
   */
  export type LocalLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalLog
     */
    select?: LocalLogSelect<ExtArgs> | null
    /**
     * Filter, which LocalLog to fetch.
     */
    where: LocalLogWhereUniqueInput
  }

  /**
   * LocalLog findFirst
   */
  export type LocalLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalLog
     */
    select?: LocalLogSelect<ExtArgs> | null
    /**
     * Filter, which LocalLog to fetch.
     */
    where?: LocalLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalLogs to fetch.
     */
    orderBy?: LocalLogOrderByWithRelationInput | LocalLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocalLogs.
     */
    cursor?: LocalLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocalLogs.
     */
    distinct?: LocalLogScalarFieldEnum | LocalLogScalarFieldEnum[]
  }

  /**
   * LocalLog findFirstOrThrow
   */
  export type LocalLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalLog
     */
    select?: LocalLogSelect<ExtArgs> | null
    /**
     * Filter, which LocalLog to fetch.
     */
    where?: LocalLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalLogs to fetch.
     */
    orderBy?: LocalLogOrderByWithRelationInput | LocalLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocalLogs.
     */
    cursor?: LocalLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocalLogs.
     */
    distinct?: LocalLogScalarFieldEnum | LocalLogScalarFieldEnum[]
  }

  /**
   * LocalLog findMany
   */
  export type LocalLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalLog
     */
    select?: LocalLogSelect<ExtArgs> | null
    /**
     * Filter, which LocalLogs to fetch.
     */
    where?: LocalLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalLogs to fetch.
     */
    orderBy?: LocalLogOrderByWithRelationInput | LocalLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LocalLogs.
     */
    cursor?: LocalLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalLogs.
     */
    skip?: number
    distinct?: LocalLogScalarFieldEnum | LocalLogScalarFieldEnum[]
  }

  /**
   * LocalLog create
   */
  export type LocalLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalLog
     */
    select?: LocalLogSelect<ExtArgs> | null
    /**
     * The data needed to create a LocalLog.
     */
    data: XOR<LocalLogCreateInput, LocalLogUncheckedCreateInput>
  }

  /**
   * LocalLog createMany
   */
  export type LocalLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LocalLogs.
     */
    data: LocalLogCreateManyInput | LocalLogCreateManyInput[]
  }

  /**
   * LocalLog createManyAndReturn
   */
  export type LocalLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalLog
     */
    select?: LocalLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LocalLogs.
     */
    data: LocalLogCreateManyInput | LocalLogCreateManyInput[]
  }

  /**
   * LocalLog update
   */
  export type LocalLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalLog
     */
    select?: LocalLogSelect<ExtArgs> | null
    /**
     * The data needed to update a LocalLog.
     */
    data: XOR<LocalLogUpdateInput, LocalLogUncheckedUpdateInput>
    /**
     * Choose, which LocalLog to update.
     */
    where: LocalLogWhereUniqueInput
  }

  /**
   * LocalLog updateMany
   */
  export type LocalLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LocalLogs.
     */
    data: XOR<LocalLogUpdateManyMutationInput, LocalLogUncheckedUpdateManyInput>
    /**
     * Filter which LocalLogs to update
     */
    where?: LocalLogWhereInput
  }

  /**
   * LocalLog upsert
   */
  export type LocalLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalLog
     */
    select?: LocalLogSelect<ExtArgs> | null
    /**
     * The filter to search for the LocalLog to update in case it exists.
     */
    where: LocalLogWhereUniqueInput
    /**
     * In case the LocalLog found by the `where` argument doesn't exist, create a new LocalLog with this data.
     */
    create: XOR<LocalLogCreateInput, LocalLogUncheckedCreateInput>
    /**
     * In case the LocalLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocalLogUpdateInput, LocalLogUncheckedUpdateInput>
  }

  /**
   * LocalLog delete
   */
  export type LocalLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalLog
     */
    select?: LocalLogSelect<ExtArgs> | null
    /**
     * Filter which LocalLog to delete.
     */
    where: LocalLogWhereUniqueInput
  }

  /**
   * LocalLog deleteMany
   */
  export type LocalLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocalLogs to delete
     */
    where?: LocalLogWhereInput
  }

  /**
   * LocalLog without action
   */
  export type LocalLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalLog
     */
    select?: LocalLogSelect<ExtArgs> | null
  }


  /**
   * Model SyncQueue
   */

  export type AggregateSyncQueue = {
    _count: SyncQueueCountAggregateOutputType | null
    _avg: SyncQueueAvgAggregateOutputType | null
    _sum: SyncQueueSumAggregateOutputType | null
    _min: SyncQueueMinAggregateOutputType | null
    _max: SyncQueueMaxAggregateOutputType | null
  }

  export type SyncQueueAvgAggregateOutputType = {
    id: number | null
    retryCount: number | null
  }

  export type SyncQueueSumAggregateOutputType = {
    id: number | null
    retryCount: number | null
  }

  export type SyncQueueMinAggregateOutputType = {
    id: number | null
    type: string | null
    data: string | null
    status: string | null
    retryCount: number | null
    lastError: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SyncQueueMaxAggregateOutputType = {
    id: number | null
    type: string | null
    data: string | null
    status: string | null
    retryCount: number | null
    lastError: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SyncQueueCountAggregateOutputType = {
    id: number
    type: number
    data: number
    status: number
    retryCount: number
    lastError: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SyncQueueAvgAggregateInputType = {
    id?: true
    retryCount?: true
  }

  export type SyncQueueSumAggregateInputType = {
    id?: true
    retryCount?: true
  }

  export type SyncQueueMinAggregateInputType = {
    id?: true
    type?: true
    data?: true
    status?: true
    retryCount?: true
    lastError?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SyncQueueMaxAggregateInputType = {
    id?: true
    type?: true
    data?: true
    status?: true
    retryCount?: true
    lastError?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SyncQueueCountAggregateInputType = {
    id?: true
    type?: true
    data?: true
    status?: true
    retryCount?: true
    lastError?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SyncQueueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncQueue to aggregate.
     */
    where?: SyncQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncQueues to fetch.
     */
    orderBy?: SyncQueueOrderByWithRelationInput | SyncQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SyncQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SyncQueues
    **/
    _count?: true | SyncQueueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SyncQueueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SyncQueueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyncQueueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyncQueueMaxAggregateInputType
  }

  export type GetSyncQueueAggregateType<T extends SyncQueueAggregateArgs> = {
        [P in keyof T & keyof AggregateSyncQueue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyncQueue[P]>
      : GetScalarType<T[P], AggregateSyncQueue[P]>
  }




  export type SyncQueueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyncQueueWhereInput
    orderBy?: SyncQueueOrderByWithAggregationInput | SyncQueueOrderByWithAggregationInput[]
    by: SyncQueueScalarFieldEnum[] | SyncQueueScalarFieldEnum
    having?: SyncQueueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyncQueueCountAggregateInputType | true
    _avg?: SyncQueueAvgAggregateInputType
    _sum?: SyncQueueSumAggregateInputType
    _min?: SyncQueueMinAggregateInputType
    _max?: SyncQueueMaxAggregateInputType
  }

  export type SyncQueueGroupByOutputType = {
    id: number
    type: string
    data: string
    status: string
    retryCount: number
    lastError: string | null
    createdAt: Date
    updatedAt: Date
    _count: SyncQueueCountAggregateOutputType | null
    _avg: SyncQueueAvgAggregateOutputType | null
    _sum: SyncQueueSumAggregateOutputType | null
    _min: SyncQueueMinAggregateOutputType | null
    _max: SyncQueueMaxAggregateOutputType | null
  }

  type GetSyncQueueGroupByPayload<T extends SyncQueueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SyncQueueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyncQueueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyncQueueGroupByOutputType[P]>
            : GetScalarType<T[P], SyncQueueGroupByOutputType[P]>
        }
      >
    >


  export type SyncQueueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    data?: boolean
    status?: boolean
    retryCount?: boolean
    lastError?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["syncQueue"]>

  export type SyncQueueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    data?: boolean
    status?: boolean
    retryCount?: boolean
    lastError?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["syncQueue"]>

  export type SyncQueueSelectScalar = {
    id?: boolean
    type?: boolean
    data?: boolean
    status?: boolean
    retryCount?: boolean
    lastError?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $SyncQueuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SyncQueue"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
      data: string
      status: string
      retryCount: number
      lastError: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["syncQueue"]>
    composites: {}
  }

  type SyncQueueGetPayload<S extends boolean | null | undefined | SyncQueueDefaultArgs> = $Result.GetResult<Prisma.$SyncQueuePayload, S>

  type SyncQueueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SyncQueueFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SyncQueueCountAggregateInputType | true
    }

  export interface SyncQueueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SyncQueue'], meta: { name: 'SyncQueue' } }
    /**
     * Find zero or one SyncQueue that matches the filter.
     * @param {SyncQueueFindUniqueArgs} args - Arguments to find a SyncQueue
     * @example
     * // Get one SyncQueue
     * const syncQueue = await prisma.syncQueue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SyncQueueFindUniqueArgs>(args: SelectSubset<T, SyncQueueFindUniqueArgs<ExtArgs>>): Prisma__SyncQueueClient<$Result.GetResult<Prisma.$SyncQueuePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SyncQueue that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SyncQueueFindUniqueOrThrowArgs} args - Arguments to find a SyncQueue
     * @example
     * // Get one SyncQueue
     * const syncQueue = await prisma.syncQueue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SyncQueueFindUniqueOrThrowArgs>(args: SelectSubset<T, SyncQueueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SyncQueueClient<$Result.GetResult<Prisma.$SyncQueuePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SyncQueue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncQueueFindFirstArgs} args - Arguments to find a SyncQueue
     * @example
     * // Get one SyncQueue
     * const syncQueue = await prisma.syncQueue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SyncQueueFindFirstArgs>(args?: SelectSubset<T, SyncQueueFindFirstArgs<ExtArgs>>): Prisma__SyncQueueClient<$Result.GetResult<Prisma.$SyncQueuePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SyncQueue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncQueueFindFirstOrThrowArgs} args - Arguments to find a SyncQueue
     * @example
     * // Get one SyncQueue
     * const syncQueue = await prisma.syncQueue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SyncQueueFindFirstOrThrowArgs>(args?: SelectSubset<T, SyncQueueFindFirstOrThrowArgs<ExtArgs>>): Prisma__SyncQueueClient<$Result.GetResult<Prisma.$SyncQueuePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SyncQueues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncQueueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SyncQueues
     * const syncQueues = await prisma.syncQueue.findMany()
     * 
     * // Get first 10 SyncQueues
     * const syncQueues = await prisma.syncQueue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const syncQueueWithIdOnly = await prisma.syncQueue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SyncQueueFindManyArgs>(args?: SelectSubset<T, SyncQueueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncQueuePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SyncQueue.
     * @param {SyncQueueCreateArgs} args - Arguments to create a SyncQueue.
     * @example
     * // Create one SyncQueue
     * const SyncQueue = await prisma.syncQueue.create({
     *   data: {
     *     // ... data to create a SyncQueue
     *   }
     * })
     * 
     */
    create<T extends SyncQueueCreateArgs>(args: SelectSubset<T, SyncQueueCreateArgs<ExtArgs>>): Prisma__SyncQueueClient<$Result.GetResult<Prisma.$SyncQueuePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SyncQueues.
     * @param {SyncQueueCreateManyArgs} args - Arguments to create many SyncQueues.
     * @example
     * // Create many SyncQueues
     * const syncQueue = await prisma.syncQueue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SyncQueueCreateManyArgs>(args?: SelectSubset<T, SyncQueueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SyncQueues and returns the data saved in the database.
     * @param {SyncQueueCreateManyAndReturnArgs} args - Arguments to create many SyncQueues.
     * @example
     * // Create many SyncQueues
     * const syncQueue = await prisma.syncQueue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SyncQueues and only return the `id`
     * const syncQueueWithIdOnly = await prisma.syncQueue.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SyncQueueCreateManyAndReturnArgs>(args?: SelectSubset<T, SyncQueueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncQueuePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SyncQueue.
     * @param {SyncQueueDeleteArgs} args - Arguments to delete one SyncQueue.
     * @example
     * // Delete one SyncQueue
     * const SyncQueue = await prisma.syncQueue.delete({
     *   where: {
     *     // ... filter to delete one SyncQueue
     *   }
     * })
     * 
     */
    delete<T extends SyncQueueDeleteArgs>(args: SelectSubset<T, SyncQueueDeleteArgs<ExtArgs>>): Prisma__SyncQueueClient<$Result.GetResult<Prisma.$SyncQueuePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SyncQueue.
     * @param {SyncQueueUpdateArgs} args - Arguments to update one SyncQueue.
     * @example
     * // Update one SyncQueue
     * const syncQueue = await prisma.syncQueue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SyncQueueUpdateArgs>(args: SelectSubset<T, SyncQueueUpdateArgs<ExtArgs>>): Prisma__SyncQueueClient<$Result.GetResult<Prisma.$SyncQueuePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SyncQueues.
     * @param {SyncQueueDeleteManyArgs} args - Arguments to filter SyncQueues to delete.
     * @example
     * // Delete a few SyncQueues
     * const { count } = await prisma.syncQueue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SyncQueueDeleteManyArgs>(args?: SelectSubset<T, SyncQueueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyncQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncQueueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SyncQueues
     * const syncQueue = await prisma.syncQueue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SyncQueueUpdateManyArgs>(args: SelectSubset<T, SyncQueueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SyncQueue.
     * @param {SyncQueueUpsertArgs} args - Arguments to update or create a SyncQueue.
     * @example
     * // Update or create a SyncQueue
     * const syncQueue = await prisma.syncQueue.upsert({
     *   create: {
     *     // ... data to create a SyncQueue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SyncQueue we want to update
     *   }
     * })
     */
    upsert<T extends SyncQueueUpsertArgs>(args: SelectSubset<T, SyncQueueUpsertArgs<ExtArgs>>): Prisma__SyncQueueClient<$Result.GetResult<Prisma.$SyncQueuePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SyncQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncQueueCountArgs} args - Arguments to filter SyncQueues to count.
     * @example
     * // Count the number of SyncQueues
     * const count = await prisma.syncQueue.count({
     *   where: {
     *     // ... the filter for the SyncQueues we want to count
     *   }
     * })
    **/
    count<T extends SyncQueueCountArgs>(
      args?: Subset<T, SyncQueueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyncQueueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SyncQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncQueueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyncQueueAggregateArgs>(args: Subset<T, SyncQueueAggregateArgs>): Prisma.PrismaPromise<GetSyncQueueAggregateType<T>>

    /**
     * Group by SyncQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncQueueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SyncQueueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SyncQueueGroupByArgs['orderBy'] }
        : { orderBy?: SyncQueueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SyncQueueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyncQueueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SyncQueue model
   */
  readonly fields: SyncQueueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SyncQueue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SyncQueueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SyncQueue model
   */ 
  interface SyncQueueFieldRefs {
    readonly id: FieldRef<"SyncQueue", 'Int'>
    readonly type: FieldRef<"SyncQueue", 'String'>
    readonly data: FieldRef<"SyncQueue", 'String'>
    readonly status: FieldRef<"SyncQueue", 'String'>
    readonly retryCount: FieldRef<"SyncQueue", 'Int'>
    readonly lastError: FieldRef<"SyncQueue", 'String'>
    readonly createdAt: FieldRef<"SyncQueue", 'DateTime'>
    readonly updatedAt: FieldRef<"SyncQueue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SyncQueue findUnique
   */
  export type SyncQueueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueue
     */
    select?: SyncQueueSelect<ExtArgs> | null
    /**
     * Filter, which SyncQueue to fetch.
     */
    where: SyncQueueWhereUniqueInput
  }

  /**
   * SyncQueue findUniqueOrThrow
   */
  export type SyncQueueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueue
     */
    select?: SyncQueueSelect<ExtArgs> | null
    /**
     * Filter, which SyncQueue to fetch.
     */
    where: SyncQueueWhereUniqueInput
  }

  /**
   * SyncQueue findFirst
   */
  export type SyncQueueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueue
     */
    select?: SyncQueueSelect<ExtArgs> | null
    /**
     * Filter, which SyncQueue to fetch.
     */
    where?: SyncQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncQueues to fetch.
     */
    orderBy?: SyncQueueOrderByWithRelationInput | SyncQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncQueues.
     */
    cursor?: SyncQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncQueues.
     */
    distinct?: SyncQueueScalarFieldEnum | SyncQueueScalarFieldEnum[]
  }

  /**
   * SyncQueue findFirstOrThrow
   */
  export type SyncQueueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueue
     */
    select?: SyncQueueSelect<ExtArgs> | null
    /**
     * Filter, which SyncQueue to fetch.
     */
    where?: SyncQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncQueues to fetch.
     */
    orderBy?: SyncQueueOrderByWithRelationInput | SyncQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncQueues.
     */
    cursor?: SyncQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncQueues.
     */
    distinct?: SyncQueueScalarFieldEnum | SyncQueueScalarFieldEnum[]
  }

  /**
   * SyncQueue findMany
   */
  export type SyncQueueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueue
     */
    select?: SyncQueueSelect<ExtArgs> | null
    /**
     * Filter, which SyncQueues to fetch.
     */
    where?: SyncQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncQueues to fetch.
     */
    orderBy?: SyncQueueOrderByWithRelationInput | SyncQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SyncQueues.
     */
    cursor?: SyncQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncQueues.
     */
    skip?: number
    distinct?: SyncQueueScalarFieldEnum | SyncQueueScalarFieldEnum[]
  }

  /**
   * SyncQueue create
   */
  export type SyncQueueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueue
     */
    select?: SyncQueueSelect<ExtArgs> | null
    /**
     * The data needed to create a SyncQueue.
     */
    data: XOR<SyncQueueCreateInput, SyncQueueUncheckedCreateInput>
  }

  /**
   * SyncQueue createMany
   */
  export type SyncQueueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SyncQueues.
     */
    data: SyncQueueCreateManyInput | SyncQueueCreateManyInput[]
  }

  /**
   * SyncQueue createManyAndReturn
   */
  export type SyncQueueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueue
     */
    select?: SyncQueueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SyncQueues.
     */
    data: SyncQueueCreateManyInput | SyncQueueCreateManyInput[]
  }

  /**
   * SyncQueue update
   */
  export type SyncQueueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueue
     */
    select?: SyncQueueSelect<ExtArgs> | null
    /**
     * The data needed to update a SyncQueue.
     */
    data: XOR<SyncQueueUpdateInput, SyncQueueUncheckedUpdateInput>
    /**
     * Choose, which SyncQueue to update.
     */
    where: SyncQueueWhereUniqueInput
  }

  /**
   * SyncQueue updateMany
   */
  export type SyncQueueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SyncQueues.
     */
    data: XOR<SyncQueueUpdateManyMutationInput, SyncQueueUncheckedUpdateManyInput>
    /**
     * Filter which SyncQueues to update
     */
    where?: SyncQueueWhereInput
  }

  /**
   * SyncQueue upsert
   */
  export type SyncQueueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueue
     */
    select?: SyncQueueSelect<ExtArgs> | null
    /**
     * The filter to search for the SyncQueue to update in case it exists.
     */
    where: SyncQueueWhereUniqueInput
    /**
     * In case the SyncQueue found by the `where` argument doesn't exist, create a new SyncQueue with this data.
     */
    create: XOR<SyncQueueCreateInput, SyncQueueUncheckedCreateInput>
    /**
     * In case the SyncQueue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SyncQueueUpdateInput, SyncQueueUncheckedUpdateInput>
  }

  /**
   * SyncQueue delete
   */
  export type SyncQueueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueue
     */
    select?: SyncQueueSelect<ExtArgs> | null
    /**
     * Filter which SyncQueue to delete.
     */
    where: SyncQueueWhereUniqueInput
  }

  /**
   * SyncQueue deleteMany
   */
  export type SyncQueueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncQueues to delete
     */
    where?: SyncQueueWhereInput
  }

  /**
   * SyncQueue without action
   */
  export type SyncQueueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueue
     */
    select?: SyncQueueSelect<ExtArgs> | null
  }


  /**
   * Model SyncStatus
   */

  export type AggregateSyncStatus = {
    _count: SyncStatusCountAggregateOutputType | null
    _avg: SyncStatusAvgAggregateOutputType | null
    _sum: SyncStatusSumAggregateOutputType | null
    _min: SyncStatusMinAggregateOutputType | null
    _max: SyncStatusMaxAggregateOutputType | null
  }

  export type SyncStatusAvgAggregateOutputType = {
    id: number | null
    syncCount: number | null
    errorCount: number | null
  }

  export type SyncStatusSumAggregateOutputType = {
    id: number | null
    syncCount: number | null
    errorCount: number | null
  }

  export type SyncStatusMinAggregateOutputType = {
    id: number | null
    type: string | null
    status: string | null
    lastSync: Date | null
    lastError: string | null
    syncCount: number | null
    errorCount: number | null
    updatedAt: Date | null
  }

  export type SyncStatusMaxAggregateOutputType = {
    id: number | null
    type: string | null
    status: string | null
    lastSync: Date | null
    lastError: string | null
    syncCount: number | null
    errorCount: number | null
    updatedAt: Date | null
  }

  export type SyncStatusCountAggregateOutputType = {
    id: number
    type: number
    status: number
    lastSync: number
    lastError: number
    syncCount: number
    errorCount: number
    updatedAt: number
    _all: number
  }


  export type SyncStatusAvgAggregateInputType = {
    id?: true
    syncCount?: true
    errorCount?: true
  }

  export type SyncStatusSumAggregateInputType = {
    id?: true
    syncCount?: true
    errorCount?: true
  }

  export type SyncStatusMinAggregateInputType = {
    id?: true
    type?: true
    status?: true
    lastSync?: true
    lastError?: true
    syncCount?: true
    errorCount?: true
    updatedAt?: true
  }

  export type SyncStatusMaxAggregateInputType = {
    id?: true
    type?: true
    status?: true
    lastSync?: true
    lastError?: true
    syncCount?: true
    errorCount?: true
    updatedAt?: true
  }

  export type SyncStatusCountAggregateInputType = {
    id?: true
    type?: true
    status?: true
    lastSync?: true
    lastError?: true
    syncCount?: true
    errorCount?: true
    updatedAt?: true
    _all?: true
  }

  export type SyncStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncStatus to aggregate.
     */
    where?: SyncStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncStatuses to fetch.
     */
    orderBy?: SyncStatusOrderByWithRelationInput | SyncStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SyncStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SyncStatuses
    **/
    _count?: true | SyncStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SyncStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SyncStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyncStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyncStatusMaxAggregateInputType
  }

  export type GetSyncStatusAggregateType<T extends SyncStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateSyncStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyncStatus[P]>
      : GetScalarType<T[P], AggregateSyncStatus[P]>
  }




  export type SyncStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyncStatusWhereInput
    orderBy?: SyncStatusOrderByWithAggregationInput | SyncStatusOrderByWithAggregationInput[]
    by: SyncStatusScalarFieldEnum[] | SyncStatusScalarFieldEnum
    having?: SyncStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyncStatusCountAggregateInputType | true
    _avg?: SyncStatusAvgAggregateInputType
    _sum?: SyncStatusSumAggregateInputType
    _min?: SyncStatusMinAggregateInputType
    _max?: SyncStatusMaxAggregateInputType
  }

  export type SyncStatusGroupByOutputType = {
    id: number
    type: string
    status: string
    lastSync: Date | null
    lastError: string | null
    syncCount: number
    errorCount: number
    updatedAt: Date
    _count: SyncStatusCountAggregateOutputType | null
    _avg: SyncStatusAvgAggregateOutputType | null
    _sum: SyncStatusSumAggregateOutputType | null
    _min: SyncStatusMinAggregateOutputType | null
    _max: SyncStatusMaxAggregateOutputType | null
  }

  type GetSyncStatusGroupByPayload<T extends SyncStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SyncStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyncStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyncStatusGroupByOutputType[P]>
            : GetScalarType<T[P], SyncStatusGroupByOutputType[P]>
        }
      >
    >


  export type SyncStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    lastSync?: boolean
    lastError?: boolean
    syncCount?: boolean
    errorCount?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["syncStatus"]>

  export type SyncStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    lastSync?: boolean
    lastError?: boolean
    syncCount?: boolean
    errorCount?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["syncStatus"]>

  export type SyncStatusSelectScalar = {
    id?: boolean
    type?: boolean
    status?: boolean
    lastSync?: boolean
    lastError?: boolean
    syncCount?: boolean
    errorCount?: boolean
    updatedAt?: boolean
  }


  export type $SyncStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SyncStatus"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
      status: string
      lastSync: Date | null
      lastError: string | null
      syncCount: number
      errorCount: number
      updatedAt: Date
    }, ExtArgs["result"]["syncStatus"]>
    composites: {}
  }

  type SyncStatusGetPayload<S extends boolean | null | undefined | SyncStatusDefaultArgs> = $Result.GetResult<Prisma.$SyncStatusPayload, S>

  type SyncStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SyncStatusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SyncStatusCountAggregateInputType | true
    }

  export interface SyncStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SyncStatus'], meta: { name: 'SyncStatus' } }
    /**
     * Find zero or one SyncStatus that matches the filter.
     * @param {SyncStatusFindUniqueArgs} args - Arguments to find a SyncStatus
     * @example
     * // Get one SyncStatus
     * const syncStatus = await prisma.syncStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SyncStatusFindUniqueArgs>(args: SelectSubset<T, SyncStatusFindUniqueArgs<ExtArgs>>): Prisma__SyncStatusClient<$Result.GetResult<Prisma.$SyncStatusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SyncStatus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SyncStatusFindUniqueOrThrowArgs} args - Arguments to find a SyncStatus
     * @example
     * // Get one SyncStatus
     * const syncStatus = await prisma.syncStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SyncStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, SyncStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SyncStatusClient<$Result.GetResult<Prisma.$SyncStatusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SyncStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncStatusFindFirstArgs} args - Arguments to find a SyncStatus
     * @example
     * // Get one SyncStatus
     * const syncStatus = await prisma.syncStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SyncStatusFindFirstArgs>(args?: SelectSubset<T, SyncStatusFindFirstArgs<ExtArgs>>): Prisma__SyncStatusClient<$Result.GetResult<Prisma.$SyncStatusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SyncStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncStatusFindFirstOrThrowArgs} args - Arguments to find a SyncStatus
     * @example
     * // Get one SyncStatus
     * const syncStatus = await prisma.syncStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SyncStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, SyncStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__SyncStatusClient<$Result.GetResult<Prisma.$SyncStatusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SyncStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SyncStatuses
     * const syncStatuses = await prisma.syncStatus.findMany()
     * 
     * // Get first 10 SyncStatuses
     * const syncStatuses = await prisma.syncStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const syncStatusWithIdOnly = await prisma.syncStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SyncStatusFindManyArgs>(args?: SelectSubset<T, SyncStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncStatusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SyncStatus.
     * @param {SyncStatusCreateArgs} args - Arguments to create a SyncStatus.
     * @example
     * // Create one SyncStatus
     * const SyncStatus = await prisma.syncStatus.create({
     *   data: {
     *     // ... data to create a SyncStatus
     *   }
     * })
     * 
     */
    create<T extends SyncStatusCreateArgs>(args: SelectSubset<T, SyncStatusCreateArgs<ExtArgs>>): Prisma__SyncStatusClient<$Result.GetResult<Prisma.$SyncStatusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SyncStatuses.
     * @param {SyncStatusCreateManyArgs} args - Arguments to create many SyncStatuses.
     * @example
     * // Create many SyncStatuses
     * const syncStatus = await prisma.syncStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SyncStatusCreateManyArgs>(args?: SelectSubset<T, SyncStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SyncStatuses and returns the data saved in the database.
     * @param {SyncStatusCreateManyAndReturnArgs} args - Arguments to create many SyncStatuses.
     * @example
     * // Create many SyncStatuses
     * const syncStatus = await prisma.syncStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SyncStatuses and only return the `id`
     * const syncStatusWithIdOnly = await prisma.syncStatus.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SyncStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, SyncStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncStatusPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SyncStatus.
     * @param {SyncStatusDeleteArgs} args - Arguments to delete one SyncStatus.
     * @example
     * // Delete one SyncStatus
     * const SyncStatus = await prisma.syncStatus.delete({
     *   where: {
     *     // ... filter to delete one SyncStatus
     *   }
     * })
     * 
     */
    delete<T extends SyncStatusDeleteArgs>(args: SelectSubset<T, SyncStatusDeleteArgs<ExtArgs>>): Prisma__SyncStatusClient<$Result.GetResult<Prisma.$SyncStatusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SyncStatus.
     * @param {SyncStatusUpdateArgs} args - Arguments to update one SyncStatus.
     * @example
     * // Update one SyncStatus
     * const syncStatus = await prisma.syncStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SyncStatusUpdateArgs>(args: SelectSubset<T, SyncStatusUpdateArgs<ExtArgs>>): Prisma__SyncStatusClient<$Result.GetResult<Prisma.$SyncStatusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SyncStatuses.
     * @param {SyncStatusDeleteManyArgs} args - Arguments to filter SyncStatuses to delete.
     * @example
     * // Delete a few SyncStatuses
     * const { count } = await prisma.syncStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SyncStatusDeleteManyArgs>(args?: SelectSubset<T, SyncStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyncStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SyncStatuses
     * const syncStatus = await prisma.syncStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SyncStatusUpdateManyArgs>(args: SelectSubset<T, SyncStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SyncStatus.
     * @param {SyncStatusUpsertArgs} args - Arguments to update or create a SyncStatus.
     * @example
     * // Update or create a SyncStatus
     * const syncStatus = await prisma.syncStatus.upsert({
     *   create: {
     *     // ... data to create a SyncStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SyncStatus we want to update
     *   }
     * })
     */
    upsert<T extends SyncStatusUpsertArgs>(args: SelectSubset<T, SyncStatusUpsertArgs<ExtArgs>>): Prisma__SyncStatusClient<$Result.GetResult<Prisma.$SyncStatusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SyncStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncStatusCountArgs} args - Arguments to filter SyncStatuses to count.
     * @example
     * // Count the number of SyncStatuses
     * const count = await prisma.syncStatus.count({
     *   where: {
     *     // ... the filter for the SyncStatuses we want to count
     *   }
     * })
    **/
    count<T extends SyncStatusCountArgs>(
      args?: Subset<T, SyncStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyncStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SyncStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyncStatusAggregateArgs>(args: Subset<T, SyncStatusAggregateArgs>): Prisma.PrismaPromise<GetSyncStatusAggregateType<T>>

    /**
     * Group by SyncStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SyncStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SyncStatusGroupByArgs['orderBy'] }
        : { orderBy?: SyncStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SyncStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyncStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SyncStatus model
   */
  readonly fields: SyncStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SyncStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SyncStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SyncStatus model
   */ 
  interface SyncStatusFieldRefs {
    readonly id: FieldRef<"SyncStatus", 'Int'>
    readonly type: FieldRef<"SyncStatus", 'String'>
    readonly status: FieldRef<"SyncStatus", 'String'>
    readonly lastSync: FieldRef<"SyncStatus", 'DateTime'>
    readonly lastError: FieldRef<"SyncStatus", 'String'>
    readonly syncCount: FieldRef<"SyncStatus", 'Int'>
    readonly errorCount: FieldRef<"SyncStatus", 'Int'>
    readonly updatedAt: FieldRef<"SyncStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SyncStatus findUnique
   */
  export type SyncStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelect<ExtArgs> | null
    /**
     * Filter, which SyncStatus to fetch.
     */
    where: SyncStatusWhereUniqueInput
  }

  /**
   * SyncStatus findUniqueOrThrow
   */
  export type SyncStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelect<ExtArgs> | null
    /**
     * Filter, which SyncStatus to fetch.
     */
    where: SyncStatusWhereUniqueInput
  }

  /**
   * SyncStatus findFirst
   */
  export type SyncStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelect<ExtArgs> | null
    /**
     * Filter, which SyncStatus to fetch.
     */
    where?: SyncStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncStatuses to fetch.
     */
    orderBy?: SyncStatusOrderByWithRelationInput | SyncStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncStatuses.
     */
    cursor?: SyncStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncStatuses.
     */
    distinct?: SyncStatusScalarFieldEnum | SyncStatusScalarFieldEnum[]
  }

  /**
   * SyncStatus findFirstOrThrow
   */
  export type SyncStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelect<ExtArgs> | null
    /**
     * Filter, which SyncStatus to fetch.
     */
    where?: SyncStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncStatuses to fetch.
     */
    orderBy?: SyncStatusOrderByWithRelationInput | SyncStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncStatuses.
     */
    cursor?: SyncStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncStatuses.
     */
    distinct?: SyncStatusScalarFieldEnum | SyncStatusScalarFieldEnum[]
  }

  /**
   * SyncStatus findMany
   */
  export type SyncStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelect<ExtArgs> | null
    /**
     * Filter, which SyncStatuses to fetch.
     */
    where?: SyncStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncStatuses to fetch.
     */
    orderBy?: SyncStatusOrderByWithRelationInput | SyncStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SyncStatuses.
     */
    cursor?: SyncStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncStatuses.
     */
    skip?: number
    distinct?: SyncStatusScalarFieldEnum | SyncStatusScalarFieldEnum[]
  }

  /**
   * SyncStatus create
   */
  export type SyncStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelect<ExtArgs> | null
    /**
     * The data needed to create a SyncStatus.
     */
    data: XOR<SyncStatusCreateInput, SyncStatusUncheckedCreateInput>
  }

  /**
   * SyncStatus createMany
   */
  export type SyncStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SyncStatuses.
     */
    data: SyncStatusCreateManyInput | SyncStatusCreateManyInput[]
  }

  /**
   * SyncStatus createManyAndReturn
   */
  export type SyncStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SyncStatuses.
     */
    data: SyncStatusCreateManyInput | SyncStatusCreateManyInput[]
  }

  /**
   * SyncStatus update
   */
  export type SyncStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelect<ExtArgs> | null
    /**
     * The data needed to update a SyncStatus.
     */
    data: XOR<SyncStatusUpdateInput, SyncStatusUncheckedUpdateInput>
    /**
     * Choose, which SyncStatus to update.
     */
    where: SyncStatusWhereUniqueInput
  }

  /**
   * SyncStatus updateMany
   */
  export type SyncStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SyncStatuses.
     */
    data: XOR<SyncStatusUpdateManyMutationInput, SyncStatusUncheckedUpdateManyInput>
    /**
     * Filter which SyncStatuses to update
     */
    where?: SyncStatusWhereInput
  }

  /**
   * SyncStatus upsert
   */
  export type SyncStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelect<ExtArgs> | null
    /**
     * The filter to search for the SyncStatus to update in case it exists.
     */
    where: SyncStatusWhereUniqueInput
    /**
     * In case the SyncStatus found by the `where` argument doesn't exist, create a new SyncStatus with this data.
     */
    create: XOR<SyncStatusCreateInput, SyncStatusUncheckedCreateInput>
    /**
     * In case the SyncStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SyncStatusUpdateInput, SyncStatusUncheckedUpdateInput>
  }

  /**
   * SyncStatus delete
   */
  export type SyncStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelect<ExtArgs> | null
    /**
     * Filter which SyncStatus to delete.
     */
    where: SyncStatusWhereUniqueInput
  }

  /**
   * SyncStatus deleteMany
   */
  export type SyncStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncStatuses to delete
     */
    where?: SyncStatusWhereInput
  }

  /**
   * SyncStatus without action
   */
  export type SyncStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelect<ExtArgs> | null
  }


  /**
   * Model Recipe
   */

  export type AggregateRecipe = {
    _count: RecipeCountAggregateOutputType | null
    _avg: RecipeAvgAggregateOutputType | null
    _sum: RecipeSumAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  export type RecipeAvgAggregateOutputType = {
    cement: number | null
    water: number | null
    sand: number | null
    gravel: number | null
    additive: number | null
    mixingTime: number | null
  }

  export type RecipeSumAggregateOutputType = {
    cement: number | null
    water: number | null
    sand: number | null
    gravel: number | null
    additive: number | null
    mixingTime: number | null
  }

  export type RecipeMinAggregateOutputType = {
    id: string | null
    name: string | null
    cement: number | null
    water: number | null
    sand: number | null
    gravel: number | null
    additive: number | null
    mixingTime: number | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecipeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    cement: number | null
    water: number | null
    sand: number | null
    gravel: number | null
    additive: number | null
    mixingTime: number | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecipeCountAggregateOutputType = {
    id: number
    name: number
    cement: number
    water: number
    sand: number
    gravel: number
    additive: number
    mixingTime: number
    enabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RecipeAvgAggregateInputType = {
    cement?: true
    water?: true
    sand?: true
    gravel?: true
    additive?: true
    mixingTime?: true
  }

  export type RecipeSumAggregateInputType = {
    cement?: true
    water?: true
    sand?: true
    gravel?: true
    additive?: true
    mixingTime?: true
  }

  export type RecipeMinAggregateInputType = {
    id?: true
    name?: true
    cement?: true
    water?: true
    sand?: true
    gravel?: true
    additive?: true
    mixingTime?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecipeMaxAggregateInputType = {
    id?: true
    name?: true
    cement?: true
    water?: true
    sand?: true
    gravel?: true
    additive?: true
    mixingTime?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecipeCountAggregateInputType = {
    id?: true
    name?: true
    cement?: true
    water?: true
    sand?: true
    gravel?: true
    additive?: true
    mixingTime?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RecipeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recipe to aggregate.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Recipes
    **/
    _count?: true | RecipeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecipeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecipeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeMaxAggregateInputType
  }

  export type GetRecipeAggregateType<T extends RecipeAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipe[P]>
      : GetScalarType<T[P], AggregateRecipe[P]>
  }




  export type RecipeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeWhereInput
    orderBy?: RecipeOrderByWithAggregationInput | RecipeOrderByWithAggregationInput[]
    by: RecipeScalarFieldEnum[] | RecipeScalarFieldEnum
    having?: RecipeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeCountAggregateInputType | true
    _avg?: RecipeAvgAggregateInputType
    _sum?: RecipeSumAggregateInputType
    _min?: RecipeMinAggregateInputType
    _max?: RecipeMaxAggregateInputType
  }

  export type RecipeGroupByOutputType = {
    id: string
    name: string
    cement: number
    water: number
    sand: number
    gravel: number
    additive: number
    mixingTime: number
    enabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: RecipeCountAggregateOutputType | null
    _avg: RecipeAvgAggregateOutputType | null
    _sum: RecipeSumAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  type GetRecipeGroupByPayload<T extends RecipeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeGroupByOutputType[P]>
        }
      >
    >


  export type RecipeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cement?: boolean
    water?: boolean
    sand?: boolean
    gravel?: boolean
    additive?: boolean
    mixingTime?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productionTasks?: boolean | Recipe$productionTasksArgs<ExtArgs>
    _count?: boolean | RecipeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipe"]>

  export type RecipeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    cement?: boolean
    water?: boolean
    sand?: boolean
    gravel?: boolean
    additive?: boolean
    mixingTime?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["recipe"]>

  export type RecipeSelectScalar = {
    id?: boolean
    name?: boolean
    cement?: boolean
    water?: boolean
    sand?: boolean
    gravel?: boolean
    additive?: boolean
    mixingTime?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RecipeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productionTasks?: boolean | Recipe$productionTasksArgs<ExtArgs>
    _count?: boolean | RecipeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RecipeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RecipePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Recipe"
    objects: {
      productionTasks: Prisma.$ProductionTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      cement: number
      water: number
      sand: number
      gravel: number
      additive: number
      mixingTime: number
      enabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["recipe"]>
    composites: {}
  }

  type RecipeGetPayload<S extends boolean | null | undefined | RecipeDefaultArgs> = $Result.GetResult<Prisma.$RecipePayload, S>

  type RecipeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecipeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RecipeCountAggregateInputType | true
    }

  export interface RecipeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Recipe'], meta: { name: 'Recipe' } }
    /**
     * Find zero or one Recipe that matches the filter.
     * @param {RecipeFindUniqueArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecipeFindUniqueArgs>(args: SelectSubset<T, RecipeFindUniqueArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Recipe that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RecipeFindUniqueOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecipeFindUniqueOrThrowArgs>(args: SelectSubset<T, RecipeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Recipe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecipeFindFirstArgs>(args?: SelectSubset<T, RecipeFindFirstArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Recipe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecipeFindFirstOrThrowArgs>(args?: SelectSubset<T, RecipeFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Recipes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recipes
     * const recipes = await prisma.recipe.findMany()
     * 
     * // Get first 10 Recipes
     * const recipes = await prisma.recipe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeWithIdOnly = await prisma.recipe.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecipeFindManyArgs>(args?: SelectSubset<T, RecipeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Recipe.
     * @param {RecipeCreateArgs} args - Arguments to create a Recipe.
     * @example
     * // Create one Recipe
     * const Recipe = await prisma.recipe.create({
     *   data: {
     *     // ... data to create a Recipe
     *   }
     * })
     * 
     */
    create<T extends RecipeCreateArgs>(args: SelectSubset<T, RecipeCreateArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Recipes.
     * @param {RecipeCreateManyArgs} args - Arguments to create many Recipes.
     * @example
     * // Create many Recipes
     * const recipe = await prisma.recipe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecipeCreateManyArgs>(args?: SelectSubset<T, RecipeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Recipes and returns the data saved in the database.
     * @param {RecipeCreateManyAndReturnArgs} args - Arguments to create many Recipes.
     * @example
     * // Create many Recipes
     * const recipe = await prisma.recipe.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Recipes and only return the `id`
     * const recipeWithIdOnly = await prisma.recipe.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecipeCreateManyAndReturnArgs>(args?: SelectSubset<T, RecipeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Recipe.
     * @param {RecipeDeleteArgs} args - Arguments to delete one Recipe.
     * @example
     * // Delete one Recipe
     * const Recipe = await prisma.recipe.delete({
     *   where: {
     *     // ... filter to delete one Recipe
     *   }
     * })
     * 
     */
    delete<T extends RecipeDeleteArgs>(args: SelectSubset<T, RecipeDeleteArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Recipe.
     * @param {RecipeUpdateArgs} args - Arguments to update one Recipe.
     * @example
     * // Update one Recipe
     * const recipe = await prisma.recipe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecipeUpdateArgs>(args: SelectSubset<T, RecipeUpdateArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Recipes.
     * @param {RecipeDeleteManyArgs} args - Arguments to filter Recipes to delete.
     * @example
     * // Delete a few Recipes
     * const { count } = await prisma.recipe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecipeDeleteManyArgs>(args?: SelectSubset<T, RecipeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recipes
     * const recipe = await prisma.recipe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecipeUpdateManyArgs>(args: SelectSubset<T, RecipeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Recipe.
     * @param {RecipeUpsertArgs} args - Arguments to update or create a Recipe.
     * @example
     * // Update or create a Recipe
     * const recipe = await prisma.recipe.upsert({
     *   create: {
     *     // ... data to create a Recipe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recipe we want to update
     *   }
     * })
     */
    upsert<T extends RecipeUpsertArgs>(args: SelectSubset<T, RecipeUpsertArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeCountArgs} args - Arguments to filter Recipes to count.
     * @example
     * // Count the number of Recipes
     * const count = await prisma.recipe.count({
     *   where: {
     *     // ... the filter for the Recipes we want to count
     *   }
     * })
    **/
    count<T extends RecipeCountArgs>(
      args?: Subset<T, RecipeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeAggregateArgs>(args: Subset<T, RecipeAggregateArgs>): Prisma.PrismaPromise<GetRecipeAggregateType<T>>

    /**
     * Group by Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeGroupByArgs['orderBy'] }
        : { orderBy?: RecipeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Recipe model
   */
  readonly fields: RecipeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Recipe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productionTasks<T extends Recipe$productionTasksArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$productionTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionTaskPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Recipe model
   */ 
  interface RecipeFieldRefs {
    readonly id: FieldRef<"Recipe", 'String'>
    readonly name: FieldRef<"Recipe", 'String'>
    readonly cement: FieldRef<"Recipe", 'Float'>
    readonly water: FieldRef<"Recipe", 'Float'>
    readonly sand: FieldRef<"Recipe", 'Float'>
    readonly gravel: FieldRef<"Recipe", 'Float'>
    readonly additive: FieldRef<"Recipe", 'Float'>
    readonly mixingTime: FieldRef<"Recipe", 'Int'>
    readonly enabled: FieldRef<"Recipe", 'Boolean'>
    readonly createdAt: FieldRef<"Recipe", 'DateTime'>
    readonly updatedAt: FieldRef<"Recipe", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Recipe findUnique
   */
  export type RecipeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe findUniqueOrThrow
   */
  export type RecipeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe findFirst
   */
  export type RecipeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipes.
     */
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Recipe findFirstOrThrow
   */
  export type RecipeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipes.
     */
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Recipe findMany
   */
  export type RecipeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipes to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Recipe create
   */
  export type RecipeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The data needed to create a Recipe.
     */
    data: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
  }

  /**
   * Recipe createMany
   */
  export type RecipeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Recipes.
     */
    data: RecipeCreateManyInput | RecipeCreateManyInput[]
  }

  /**
   * Recipe createManyAndReturn
   */
  export type RecipeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Recipes.
     */
    data: RecipeCreateManyInput | RecipeCreateManyInput[]
  }

  /**
   * Recipe update
   */
  export type RecipeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The data needed to update a Recipe.
     */
    data: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
    /**
     * Choose, which Recipe to update.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe updateMany
   */
  export type RecipeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Recipes.
     */
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyInput>
    /**
     * Filter which Recipes to update
     */
    where?: RecipeWhereInput
  }

  /**
   * Recipe upsert
   */
  export type RecipeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The filter to search for the Recipe to update in case it exists.
     */
    where: RecipeWhereUniqueInput
    /**
     * In case the Recipe found by the `where` argument doesn't exist, create a new Recipe with this data.
     */
    create: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
    /**
     * In case the Recipe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
  }

  /**
   * Recipe delete
   */
  export type RecipeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter which Recipe to delete.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe deleteMany
   */
  export type RecipeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recipes to delete
     */
    where?: RecipeWhereInput
  }

  /**
   * Recipe.productionTasks
   */
  export type Recipe$productionTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTask
     */
    select?: ProductionTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskInclude<ExtArgs> | null
    where?: ProductionTaskWhereInput
    orderBy?: ProductionTaskOrderByWithRelationInput | ProductionTaskOrderByWithRelationInput[]
    cursor?: ProductionTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionTaskScalarFieldEnum | ProductionTaskScalarFieldEnum[]
  }

  /**
   * Recipe without action
   */
  export type RecipeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
  }


  /**
   * Model ProductionTask
   */

  export type AggregateProductionTask = {
    _count: ProductionTaskCountAggregateOutputType | null
    _avg: ProductionTaskAvgAggregateOutputType | null
    _sum: ProductionTaskSumAggregateOutputType | null
    _min: ProductionTaskMinAggregateOutputType | null
    _max: ProductionTaskMaxAggregateOutputType | null
  }

  export type ProductionTaskAvgAggregateOutputType = {
    quantity: number | null
    priority: number | null
  }

  export type ProductionTaskSumAggregateOutputType = {
    quantity: number | null
    priority: number | null
  }

  export type ProductionTaskMinAggregateOutputType = {
    id: string | null
    recipeId: string | null
    quantity: number | null
    priority: number | null
    status: string | null
    startTime: Date | null
    endTime: Date | null
    createdAt: Date | null
  }

  export type ProductionTaskMaxAggregateOutputType = {
    id: string | null
    recipeId: string | null
    quantity: number | null
    priority: number | null
    status: string | null
    startTime: Date | null
    endTime: Date | null
    createdAt: Date | null
  }

  export type ProductionTaskCountAggregateOutputType = {
    id: number
    recipeId: number
    quantity: number
    priority: number
    status: number
    startTime: number
    endTime: number
    createdAt: number
    _all: number
  }


  export type ProductionTaskAvgAggregateInputType = {
    quantity?: true
    priority?: true
  }

  export type ProductionTaskSumAggregateInputType = {
    quantity?: true
    priority?: true
  }

  export type ProductionTaskMinAggregateInputType = {
    id?: true
    recipeId?: true
    quantity?: true
    priority?: true
    status?: true
    startTime?: true
    endTime?: true
    createdAt?: true
  }

  export type ProductionTaskMaxAggregateInputType = {
    id?: true
    recipeId?: true
    quantity?: true
    priority?: true
    status?: true
    startTime?: true
    endTime?: true
    createdAt?: true
  }

  export type ProductionTaskCountAggregateInputType = {
    id?: true
    recipeId?: true
    quantity?: true
    priority?: true
    status?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    _all?: true
  }

  export type ProductionTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionTask to aggregate.
     */
    where?: ProductionTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionTasks to fetch.
     */
    orderBy?: ProductionTaskOrderByWithRelationInput | ProductionTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductionTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductionTasks
    **/
    _count?: true | ProductionTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductionTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductionTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductionTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductionTaskMaxAggregateInputType
  }

  export type GetProductionTaskAggregateType<T extends ProductionTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateProductionTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductionTask[P]>
      : GetScalarType<T[P], AggregateProductionTask[P]>
  }




  export type ProductionTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionTaskWhereInput
    orderBy?: ProductionTaskOrderByWithAggregationInput | ProductionTaskOrderByWithAggregationInput[]
    by: ProductionTaskScalarFieldEnum[] | ProductionTaskScalarFieldEnum
    having?: ProductionTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductionTaskCountAggregateInputType | true
    _avg?: ProductionTaskAvgAggregateInputType
    _sum?: ProductionTaskSumAggregateInputType
    _min?: ProductionTaskMinAggregateInputType
    _max?: ProductionTaskMaxAggregateInputType
  }

  export type ProductionTaskGroupByOutputType = {
    id: string
    recipeId: string
    quantity: number
    priority: number
    status: string
    startTime: Date | null
    endTime: Date | null
    createdAt: Date
    _count: ProductionTaskCountAggregateOutputType | null
    _avg: ProductionTaskAvgAggregateOutputType | null
    _sum: ProductionTaskSumAggregateOutputType | null
    _min: ProductionTaskMinAggregateOutputType | null
    _max: ProductionTaskMaxAggregateOutputType | null
  }

  type GetProductionTaskGroupByPayload<T extends ProductionTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductionTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductionTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductionTaskGroupByOutputType[P]>
            : GetScalarType<T[P], ProductionTaskGroupByOutputType[P]>
        }
      >
    >


  export type ProductionTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    quantity?: boolean
    priority?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    productionRecords?: boolean | ProductionTask$productionRecordsArgs<ExtArgs>
    _count?: boolean | ProductionTaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionTask"]>

  export type ProductionTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    quantity?: boolean
    priority?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionTask"]>

  export type ProductionTaskSelectScalar = {
    id?: boolean
    recipeId?: boolean
    quantity?: boolean
    priority?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
  }

  export type ProductionTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    productionRecords?: boolean | ProductionTask$productionRecordsArgs<ExtArgs>
    _count?: boolean | ProductionTaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductionTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }

  export type $ProductionTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductionTask"
    objects: {
      recipe: Prisma.$RecipePayload<ExtArgs>
      productionRecords: Prisma.$ProductionRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      recipeId: string
      quantity: number
      priority: number
      status: string
      startTime: Date | null
      endTime: Date | null
      createdAt: Date
    }, ExtArgs["result"]["productionTask"]>
    composites: {}
  }

  type ProductionTaskGetPayload<S extends boolean | null | undefined | ProductionTaskDefaultArgs> = $Result.GetResult<Prisma.$ProductionTaskPayload, S>

  type ProductionTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductionTaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductionTaskCountAggregateInputType | true
    }

  export interface ProductionTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductionTask'], meta: { name: 'ProductionTask' } }
    /**
     * Find zero or one ProductionTask that matches the filter.
     * @param {ProductionTaskFindUniqueArgs} args - Arguments to find a ProductionTask
     * @example
     * // Get one ProductionTask
     * const productionTask = await prisma.productionTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductionTaskFindUniqueArgs>(args: SelectSubset<T, ProductionTaskFindUniqueArgs<ExtArgs>>): Prisma__ProductionTaskClient<$Result.GetResult<Prisma.$ProductionTaskPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductionTask that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductionTaskFindUniqueOrThrowArgs} args - Arguments to find a ProductionTask
     * @example
     * // Get one ProductionTask
     * const productionTask = await prisma.productionTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductionTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductionTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductionTaskClient<$Result.GetResult<Prisma.$ProductionTaskPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductionTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionTaskFindFirstArgs} args - Arguments to find a ProductionTask
     * @example
     * // Get one ProductionTask
     * const productionTask = await prisma.productionTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductionTaskFindFirstArgs>(args?: SelectSubset<T, ProductionTaskFindFirstArgs<ExtArgs>>): Prisma__ProductionTaskClient<$Result.GetResult<Prisma.$ProductionTaskPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductionTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionTaskFindFirstOrThrowArgs} args - Arguments to find a ProductionTask
     * @example
     * // Get one ProductionTask
     * const productionTask = await prisma.productionTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductionTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductionTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductionTaskClient<$Result.GetResult<Prisma.$ProductionTaskPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductionTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductionTasks
     * const productionTasks = await prisma.productionTask.findMany()
     * 
     * // Get first 10 ProductionTasks
     * const productionTasks = await prisma.productionTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productionTaskWithIdOnly = await prisma.productionTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductionTaskFindManyArgs>(args?: SelectSubset<T, ProductionTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionTaskPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductionTask.
     * @param {ProductionTaskCreateArgs} args - Arguments to create a ProductionTask.
     * @example
     * // Create one ProductionTask
     * const ProductionTask = await prisma.productionTask.create({
     *   data: {
     *     // ... data to create a ProductionTask
     *   }
     * })
     * 
     */
    create<T extends ProductionTaskCreateArgs>(args: SelectSubset<T, ProductionTaskCreateArgs<ExtArgs>>): Prisma__ProductionTaskClient<$Result.GetResult<Prisma.$ProductionTaskPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductionTasks.
     * @param {ProductionTaskCreateManyArgs} args - Arguments to create many ProductionTasks.
     * @example
     * // Create many ProductionTasks
     * const productionTask = await prisma.productionTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductionTaskCreateManyArgs>(args?: SelectSubset<T, ProductionTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductionTasks and returns the data saved in the database.
     * @param {ProductionTaskCreateManyAndReturnArgs} args - Arguments to create many ProductionTasks.
     * @example
     * // Create many ProductionTasks
     * const productionTask = await prisma.productionTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductionTasks and only return the `id`
     * const productionTaskWithIdOnly = await prisma.productionTask.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductionTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductionTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionTaskPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProductionTask.
     * @param {ProductionTaskDeleteArgs} args - Arguments to delete one ProductionTask.
     * @example
     * // Delete one ProductionTask
     * const ProductionTask = await prisma.productionTask.delete({
     *   where: {
     *     // ... filter to delete one ProductionTask
     *   }
     * })
     * 
     */
    delete<T extends ProductionTaskDeleteArgs>(args: SelectSubset<T, ProductionTaskDeleteArgs<ExtArgs>>): Prisma__ProductionTaskClient<$Result.GetResult<Prisma.$ProductionTaskPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductionTask.
     * @param {ProductionTaskUpdateArgs} args - Arguments to update one ProductionTask.
     * @example
     * // Update one ProductionTask
     * const productionTask = await prisma.productionTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductionTaskUpdateArgs>(args: SelectSubset<T, ProductionTaskUpdateArgs<ExtArgs>>): Prisma__ProductionTaskClient<$Result.GetResult<Prisma.$ProductionTaskPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductionTasks.
     * @param {ProductionTaskDeleteManyArgs} args - Arguments to filter ProductionTasks to delete.
     * @example
     * // Delete a few ProductionTasks
     * const { count } = await prisma.productionTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductionTaskDeleteManyArgs>(args?: SelectSubset<T, ProductionTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductionTasks
     * const productionTask = await prisma.productionTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductionTaskUpdateManyArgs>(args: SelectSubset<T, ProductionTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductionTask.
     * @param {ProductionTaskUpsertArgs} args - Arguments to update or create a ProductionTask.
     * @example
     * // Update or create a ProductionTask
     * const productionTask = await prisma.productionTask.upsert({
     *   create: {
     *     // ... data to create a ProductionTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductionTask we want to update
     *   }
     * })
     */
    upsert<T extends ProductionTaskUpsertArgs>(args: SelectSubset<T, ProductionTaskUpsertArgs<ExtArgs>>): Prisma__ProductionTaskClient<$Result.GetResult<Prisma.$ProductionTaskPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductionTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionTaskCountArgs} args - Arguments to filter ProductionTasks to count.
     * @example
     * // Count the number of ProductionTasks
     * const count = await prisma.productionTask.count({
     *   where: {
     *     // ... the filter for the ProductionTasks we want to count
     *   }
     * })
    **/
    count<T extends ProductionTaskCountArgs>(
      args?: Subset<T, ProductionTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductionTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductionTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductionTaskAggregateArgs>(args: Subset<T, ProductionTaskAggregateArgs>): Prisma.PrismaPromise<GetProductionTaskAggregateType<T>>

    /**
     * Group by ProductionTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductionTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductionTaskGroupByArgs['orderBy'] }
        : { orderBy?: ProductionTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductionTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductionTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductionTask model
   */
  readonly fields: ProductionTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductionTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductionTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipe<T extends RecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeDefaultArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    productionRecords<T extends ProductionTask$productionRecordsArgs<ExtArgs> = {}>(args?: Subset<T, ProductionTask$productionRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionRecordPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductionTask model
   */ 
  interface ProductionTaskFieldRefs {
    readonly id: FieldRef<"ProductionTask", 'String'>
    readonly recipeId: FieldRef<"ProductionTask", 'String'>
    readonly quantity: FieldRef<"ProductionTask", 'Float'>
    readonly priority: FieldRef<"ProductionTask", 'Int'>
    readonly status: FieldRef<"ProductionTask", 'String'>
    readonly startTime: FieldRef<"ProductionTask", 'DateTime'>
    readonly endTime: FieldRef<"ProductionTask", 'DateTime'>
    readonly createdAt: FieldRef<"ProductionTask", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductionTask findUnique
   */
  export type ProductionTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTask
     */
    select?: ProductionTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskInclude<ExtArgs> | null
    /**
     * Filter, which ProductionTask to fetch.
     */
    where: ProductionTaskWhereUniqueInput
  }

  /**
   * ProductionTask findUniqueOrThrow
   */
  export type ProductionTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTask
     */
    select?: ProductionTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskInclude<ExtArgs> | null
    /**
     * Filter, which ProductionTask to fetch.
     */
    where: ProductionTaskWhereUniqueInput
  }

  /**
   * ProductionTask findFirst
   */
  export type ProductionTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTask
     */
    select?: ProductionTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskInclude<ExtArgs> | null
    /**
     * Filter, which ProductionTask to fetch.
     */
    where?: ProductionTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionTasks to fetch.
     */
    orderBy?: ProductionTaskOrderByWithRelationInput | ProductionTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionTasks.
     */
    cursor?: ProductionTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionTasks.
     */
    distinct?: ProductionTaskScalarFieldEnum | ProductionTaskScalarFieldEnum[]
  }

  /**
   * ProductionTask findFirstOrThrow
   */
  export type ProductionTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTask
     */
    select?: ProductionTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskInclude<ExtArgs> | null
    /**
     * Filter, which ProductionTask to fetch.
     */
    where?: ProductionTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionTasks to fetch.
     */
    orderBy?: ProductionTaskOrderByWithRelationInput | ProductionTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionTasks.
     */
    cursor?: ProductionTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionTasks.
     */
    distinct?: ProductionTaskScalarFieldEnum | ProductionTaskScalarFieldEnum[]
  }

  /**
   * ProductionTask findMany
   */
  export type ProductionTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTask
     */
    select?: ProductionTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskInclude<ExtArgs> | null
    /**
     * Filter, which ProductionTasks to fetch.
     */
    where?: ProductionTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionTasks to fetch.
     */
    orderBy?: ProductionTaskOrderByWithRelationInput | ProductionTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductionTasks.
     */
    cursor?: ProductionTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionTasks.
     */
    skip?: number
    distinct?: ProductionTaskScalarFieldEnum | ProductionTaskScalarFieldEnum[]
  }

  /**
   * ProductionTask create
   */
  export type ProductionTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTask
     */
    select?: ProductionTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductionTask.
     */
    data: XOR<ProductionTaskCreateInput, ProductionTaskUncheckedCreateInput>
  }

  /**
   * ProductionTask createMany
   */
  export type ProductionTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductionTasks.
     */
    data: ProductionTaskCreateManyInput | ProductionTaskCreateManyInput[]
  }

  /**
   * ProductionTask createManyAndReturn
   */
  export type ProductionTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTask
     */
    select?: ProductionTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProductionTasks.
     */
    data: ProductionTaskCreateManyInput | ProductionTaskCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionTask update
   */
  export type ProductionTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTask
     */
    select?: ProductionTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductionTask.
     */
    data: XOR<ProductionTaskUpdateInput, ProductionTaskUncheckedUpdateInput>
    /**
     * Choose, which ProductionTask to update.
     */
    where: ProductionTaskWhereUniqueInput
  }

  /**
   * ProductionTask updateMany
   */
  export type ProductionTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductionTasks.
     */
    data: XOR<ProductionTaskUpdateManyMutationInput, ProductionTaskUncheckedUpdateManyInput>
    /**
     * Filter which ProductionTasks to update
     */
    where?: ProductionTaskWhereInput
  }

  /**
   * ProductionTask upsert
   */
  export type ProductionTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTask
     */
    select?: ProductionTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductionTask to update in case it exists.
     */
    where: ProductionTaskWhereUniqueInput
    /**
     * In case the ProductionTask found by the `where` argument doesn't exist, create a new ProductionTask with this data.
     */
    create: XOR<ProductionTaskCreateInput, ProductionTaskUncheckedCreateInput>
    /**
     * In case the ProductionTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductionTaskUpdateInput, ProductionTaskUncheckedUpdateInput>
  }

  /**
   * ProductionTask delete
   */
  export type ProductionTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTask
     */
    select?: ProductionTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskInclude<ExtArgs> | null
    /**
     * Filter which ProductionTask to delete.
     */
    where: ProductionTaskWhereUniqueInput
  }

  /**
   * ProductionTask deleteMany
   */
  export type ProductionTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionTasks to delete
     */
    where?: ProductionTaskWhereInput
  }

  /**
   * ProductionTask.productionRecords
   */
  export type ProductionTask$productionRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRecord
     */
    select?: ProductionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRecordInclude<ExtArgs> | null
    where?: ProductionRecordWhereInput
    orderBy?: ProductionRecordOrderByWithRelationInput | ProductionRecordOrderByWithRelationInput[]
    cursor?: ProductionRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductionRecordScalarFieldEnum | ProductionRecordScalarFieldEnum[]
  }

  /**
   * ProductionTask without action
   */
  export type ProductionTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionTask
     */
    select?: ProductionTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionTaskInclude<ExtArgs> | null
  }


  /**
   * Model ProductionRecord
   */

  export type AggregateProductionRecord = {
    _count: ProductionRecordCountAggregateOutputType | null
    _avg: ProductionRecordAvgAggregateOutputType | null
    _sum: ProductionRecordSumAggregateOutputType | null
    _min: ProductionRecordMinAggregateOutputType | null
    _max: ProductionRecordMaxAggregateOutputType | null
  }

  export type ProductionRecordAvgAggregateOutputType = {
    quantity: number | null
  }

  export type ProductionRecordSumAggregateOutputType = {
    quantity: number | null
  }

  export type ProductionRecordMinAggregateOutputType = {
    id: string | null
    taskId: string | null
    recipeId: string | null
    quantity: number | null
    status: string | null
    startTime: Date | null
    endTime: Date | null
    createdAt: Date | null
  }

  export type ProductionRecordMaxAggregateOutputType = {
    id: string | null
    taskId: string | null
    recipeId: string | null
    quantity: number | null
    status: string | null
    startTime: Date | null
    endTime: Date | null
    createdAt: Date | null
  }

  export type ProductionRecordCountAggregateOutputType = {
    id: number
    taskId: number
    recipeId: number
    quantity: number
    status: number
    startTime: number
    endTime: number
    createdAt: number
    _all: number
  }


  export type ProductionRecordAvgAggregateInputType = {
    quantity?: true
  }

  export type ProductionRecordSumAggregateInputType = {
    quantity?: true
  }

  export type ProductionRecordMinAggregateInputType = {
    id?: true
    taskId?: true
    recipeId?: true
    quantity?: true
    status?: true
    startTime?: true
    endTime?: true
    createdAt?: true
  }

  export type ProductionRecordMaxAggregateInputType = {
    id?: true
    taskId?: true
    recipeId?: true
    quantity?: true
    status?: true
    startTime?: true
    endTime?: true
    createdAt?: true
  }

  export type ProductionRecordCountAggregateInputType = {
    id?: true
    taskId?: true
    recipeId?: true
    quantity?: true
    status?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    _all?: true
  }

  export type ProductionRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionRecord to aggregate.
     */
    where?: ProductionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionRecords to fetch.
     */
    orderBy?: ProductionRecordOrderByWithRelationInput | ProductionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductionRecords
    **/
    _count?: true | ProductionRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductionRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductionRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductionRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductionRecordMaxAggregateInputType
  }

  export type GetProductionRecordAggregateType<T extends ProductionRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateProductionRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductionRecord[P]>
      : GetScalarType<T[P], AggregateProductionRecord[P]>
  }




  export type ProductionRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductionRecordWhereInput
    orderBy?: ProductionRecordOrderByWithAggregationInput | ProductionRecordOrderByWithAggregationInput[]
    by: ProductionRecordScalarFieldEnum[] | ProductionRecordScalarFieldEnum
    having?: ProductionRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductionRecordCountAggregateInputType | true
    _avg?: ProductionRecordAvgAggregateInputType
    _sum?: ProductionRecordSumAggregateInputType
    _min?: ProductionRecordMinAggregateInputType
    _max?: ProductionRecordMaxAggregateInputType
  }

  export type ProductionRecordGroupByOutputType = {
    id: string
    taskId: string
    recipeId: string
    quantity: number
    status: string
    startTime: Date
    endTime: Date
    createdAt: Date
    _count: ProductionRecordCountAggregateOutputType | null
    _avg: ProductionRecordAvgAggregateOutputType | null
    _sum: ProductionRecordSumAggregateOutputType | null
    _min: ProductionRecordMinAggregateOutputType | null
    _max: ProductionRecordMaxAggregateOutputType | null
  }

  type GetProductionRecordGroupByPayload<T extends ProductionRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductionRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductionRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductionRecordGroupByOutputType[P]>
            : GetScalarType<T[P], ProductionRecordGroupByOutputType[P]>
        }
      >
    >


  export type ProductionRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    recipeId?: boolean
    quantity?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    task?: boolean | ProductionTaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionRecord"]>

  export type ProductionRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    recipeId?: boolean
    quantity?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    task?: boolean | ProductionTaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productionRecord"]>

  export type ProductionRecordSelectScalar = {
    id?: boolean
    taskId?: boolean
    recipeId?: boolean
    quantity?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
  }

  export type ProductionRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | ProductionTaskDefaultArgs<ExtArgs>
  }
  export type ProductionRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | ProductionTaskDefaultArgs<ExtArgs>
  }

  export type $ProductionRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductionRecord"
    objects: {
      task: Prisma.$ProductionTaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskId: string
      recipeId: string
      quantity: number
      status: string
      startTime: Date
      endTime: Date
      createdAt: Date
    }, ExtArgs["result"]["productionRecord"]>
    composites: {}
  }

  type ProductionRecordGetPayload<S extends boolean | null | undefined | ProductionRecordDefaultArgs> = $Result.GetResult<Prisma.$ProductionRecordPayload, S>

  type ProductionRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductionRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductionRecordCountAggregateInputType | true
    }

  export interface ProductionRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductionRecord'], meta: { name: 'ProductionRecord' } }
    /**
     * Find zero or one ProductionRecord that matches the filter.
     * @param {ProductionRecordFindUniqueArgs} args - Arguments to find a ProductionRecord
     * @example
     * // Get one ProductionRecord
     * const productionRecord = await prisma.productionRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductionRecordFindUniqueArgs>(args: SelectSubset<T, ProductionRecordFindUniqueArgs<ExtArgs>>): Prisma__ProductionRecordClient<$Result.GetResult<Prisma.$ProductionRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductionRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductionRecordFindUniqueOrThrowArgs} args - Arguments to find a ProductionRecord
     * @example
     * // Get one ProductionRecord
     * const productionRecord = await prisma.productionRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductionRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductionRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductionRecordClient<$Result.GetResult<Prisma.$ProductionRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductionRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRecordFindFirstArgs} args - Arguments to find a ProductionRecord
     * @example
     * // Get one ProductionRecord
     * const productionRecord = await prisma.productionRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductionRecordFindFirstArgs>(args?: SelectSubset<T, ProductionRecordFindFirstArgs<ExtArgs>>): Prisma__ProductionRecordClient<$Result.GetResult<Prisma.$ProductionRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductionRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRecordFindFirstOrThrowArgs} args - Arguments to find a ProductionRecord
     * @example
     * // Get one ProductionRecord
     * const productionRecord = await prisma.productionRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductionRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductionRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductionRecordClient<$Result.GetResult<Prisma.$ProductionRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductionRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductionRecords
     * const productionRecords = await prisma.productionRecord.findMany()
     * 
     * // Get first 10 ProductionRecords
     * const productionRecords = await prisma.productionRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productionRecordWithIdOnly = await prisma.productionRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductionRecordFindManyArgs>(args?: SelectSubset<T, ProductionRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductionRecord.
     * @param {ProductionRecordCreateArgs} args - Arguments to create a ProductionRecord.
     * @example
     * // Create one ProductionRecord
     * const ProductionRecord = await prisma.productionRecord.create({
     *   data: {
     *     // ... data to create a ProductionRecord
     *   }
     * })
     * 
     */
    create<T extends ProductionRecordCreateArgs>(args: SelectSubset<T, ProductionRecordCreateArgs<ExtArgs>>): Prisma__ProductionRecordClient<$Result.GetResult<Prisma.$ProductionRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductionRecords.
     * @param {ProductionRecordCreateManyArgs} args - Arguments to create many ProductionRecords.
     * @example
     * // Create many ProductionRecords
     * const productionRecord = await prisma.productionRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductionRecordCreateManyArgs>(args?: SelectSubset<T, ProductionRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductionRecords and returns the data saved in the database.
     * @param {ProductionRecordCreateManyAndReturnArgs} args - Arguments to create many ProductionRecords.
     * @example
     * // Create many ProductionRecords
     * const productionRecord = await prisma.productionRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductionRecords and only return the `id`
     * const productionRecordWithIdOnly = await prisma.productionRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductionRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductionRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductionRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProductionRecord.
     * @param {ProductionRecordDeleteArgs} args - Arguments to delete one ProductionRecord.
     * @example
     * // Delete one ProductionRecord
     * const ProductionRecord = await prisma.productionRecord.delete({
     *   where: {
     *     // ... filter to delete one ProductionRecord
     *   }
     * })
     * 
     */
    delete<T extends ProductionRecordDeleteArgs>(args: SelectSubset<T, ProductionRecordDeleteArgs<ExtArgs>>): Prisma__ProductionRecordClient<$Result.GetResult<Prisma.$ProductionRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductionRecord.
     * @param {ProductionRecordUpdateArgs} args - Arguments to update one ProductionRecord.
     * @example
     * // Update one ProductionRecord
     * const productionRecord = await prisma.productionRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductionRecordUpdateArgs>(args: SelectSubset<T, ProductionRecordUpdateArgs<ExtArgs>>): Prisma__ProductionRecordClient<$Result.GetResult<Prisma.$ProductionRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductionRecords.
     * @param {ProductionRecordDeleteManyArgs} args - Arguments to filter ProductionRecords to delete.
     * @example
     * // Delete a few ProductionRecords
     * const { count } = await prisma.productionRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductionRecordDeleteManyArgs>(args?: SelectSubset<T, ProductionRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductionRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductionRecords
     * const productionRecord = await prisma.productionRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductionRecordUpdateManyArgs>(args: SelectSubset<T, ProductionRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductionRecord.
     * @param {ProductionRecordUpsertArgs} args - Arguments to update or create a ProductionRecord.
     * @example
     * // Update or create a ProductionRecord
     * const productionRecord = await prisma.productionRecord.upsert({
     *   create: {
     *     // ... data to create a ProductionRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductionRecord we want to update
     *   }
     * })
     */
    upsert<T extends ProductionRecordUpsertArgs>(args: SelectSubset<T, ProductionRecordUpsertArgs<ExtArgs>>): Prisma__ProductionRecordClient<$Result.GetResult<Prisma.$ProductionRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductionRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRecordCountArgs} args - Arguments to filter ProductionRecords to count.
     * @example
     * // Count the number of ProductionRecords
     * const count = await prisma.productionRecord.count({
     *   where: {
     *     // ... the filter for the ProductionRecords we want to count
     *   }
     * })
    **/
    count<T extends ProductionRecordCountArgs>(
      args?: Subset<T, ProductionRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductionRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductionRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductionRecordAggregateArgs>(args: Subset<T, ProductionRecordAggregateArgs>): Prisma.PrismaPromise<GetProductionRecordAggregateType<T>>

    /**
     * Group by ProductionRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductionRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductionRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductionRecordGroupByArgs['orderBy'] }
        : { orderBy?: ProductionRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductionRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductionRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductionRecord model
   */
  readonly fields: ProductionRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductionRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductionRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends ProductionTaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductionTaskDefaultArgs<ExtArgs>>): Prisma__ProductionTaskClient<$Result.GetResult<Prisma.$ProductionTaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductionRecord model
   */ 
  interface ProductionRecordFieldRefs {
    readonly id: FieldRef<"ProductionRecord", 'String'>
    readonly taskId: FieldRef<"ProductionRecord", 'String'>
    readonly recipeId: FieldRef<"ProductionRecord", 'String'>
    readonly quantity: FieldRef<"ProductionRecord", 'Float'>
    readonly status: FieldRef<"ProductionRecord", 'String'>
    readonly startTime: FieldRef<"ProductionRecord", 'DateTime'>
    readonly endTime: FieldRef<"ProductionRecord", 'DateTime'>
    readonly createdAt: FieldRef<"ProductionRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductionRecord findUnique
   */
  export type ProductionRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRecord
     */
    select?: ProductionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRecordInclude<ExtArgs> | null
    /**
     * Filter, which ProductionRecord to fetch.
     */
    where: ProductionRecordWhereUniqueInput
  }

  /**
   * ProductionRecord findUniqueOrThrow
   */
  export type ProductionRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRecord
     */
    select?: ProductionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRecordInclude<ExtArgs> | null
    /**
     * Filter, which ProductionRecord to fetch.
     */
    where: ProductionRecordWhereUniqueInput
  }

  /**
   * ProductionRecord findFirst
   */
  export type ProductionRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRecord
     */
    select?: ProductionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRecordInclude<ExtArgs> | null
    /**
     * Filter, which ProductionRecord to fetch.
     */
    where?: ProductionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionRecords to fetch.
     */
    orderBy?: ProductionRecordOrderByWithRelationInput | ProductionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionRecords.
     */
    cursor?: ProductionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionRecords.
     */
    distinct?: ProductionRecordScalarFieldEnum | ProductionRecordScalarFieldEnum[]
  }

  /**
   * ProductionRecord findFirstOrThrow
   */
  export type ProductionRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRecord
     */
    select?: ProductionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRecordInclude<ExtArgs> | null
    /**
     * Filter, which ProductionRecord to fetch.
     */
    where?: ProductionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionRecords to fetch.
     */
    orderBy?: ProductionRecordOrderByWithRelationInput | ProductionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductionRecords.
     */
    cursor?: ProductionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductionRecords.
     */
    distinct?: ProductionRecordScalarFieldEnum | ProductionRecordScalarFieldEnum[]
  }

  /**
   * ProductionRecord findMany
   */
  export type ProductionRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRecord
     */
    select?: ProductionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRecordInclude<ExtArgs> | null
    /**
     * Filter, which ProductionRecords to fetch.
     */
    where?: ProductionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductionRecords to fetch.
     */
    orderBy?: ProductionRecordOrderByWithRelationInput | ProductionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductionRecords.
     */
    cursor?: ProductionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductionRecords.
     */
    skip?: number
    distinct?: ProductionRecordScalarFieldEnum | ProductionRecordScalarFieldEnum[]
  }

  /**
   * ProductionRecord create
   */
  export type ProductionRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRecord
     */
    select?: ProductionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductionRecord.
     */
    data: XOR<ProductionRecordCreateInput, ProductionRecordUncheckedCreateInput>
  }

  /**
   * ProductionRecord createMany
   */
  export type ProductionRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductionRecords.
     */
    data: ProductionRecordCreateManyInput | ProductionRecordCreateManyInput[]
  }

  /**
   * ProductionRecord createManyAndReturn
   */
  export type ProductionRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRecord
     */
    select?: ProductionRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProductionRecords.
     */
    data: ProductionRecordCreateManyInput | ProductionRecordCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductionRecord update
   */
  export type ProductionRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRecord
     */
    select?: ProductionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductionRecord.
     */
    data: XOR<ProductionRecordUpdateInput, ProductionRecordUncheckedUpdateInput>
    /**
     * Choose, which ProductionRecord to update.
     */
    where: ProductionRecordWhereUniqueInput
  }

  /**
   * ProductionRecord updateMany
   */
  export type ProductionRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductionRecords.
     */
    data: XOR<ProductionRecordUpdateManyMutationInput, ProductionRecordUncheckedUpdateManyInput>
    /**
     * Filter which ProductionRecords to update
     */
    where?: ProductionRecordWhereInput
  }

  /**
   * ProductionRecord upsert
   */
  export type ProductionRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRecord
     */
    select?: ProductionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductionRecord to update in case it exists.
     */
    where: ProductionRecordWhereUniqueInput
    /**
     * In case the ProductionRecord found by the `where` argument doesn't exist, create a new ProductionRecord with this data.
     */
    create: XOR<ProductionRecordCreateInput, ProductionRecordUncheckedCreateInput>
    /**
     * In case the ProductionRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductionRecordUpdateInput, ProductionRecordUncheckedUpdateInput>
  }

  /**
   * ProductionRecord delete
   */
  export type ProductionRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRecord
     */
    select?: ProductionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRecordInclude<ExtArgs> | null
    /**
     * Filter which ProductionRecord to delete.
     */
    where: ProductionRecordWhereUniqueInput
  }

  /**
   * ProductionRecord deleteMany
   */
  export type ProductionRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductionRecords to delete
     */
    where?: ProductionRecordWhereInput
  }

  /**
   * ProductionRecord without action
   */
  export type ProductionRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductionRecord
     */
    select?: ProductionRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductionRecordInclude<ExtArgs> | null
  }


  /**
   * Model Alarm
   */

  export type AggregateAlarm = {
    _count: AlarmCountAggregateOutputType | null
    _min: AlarmMinAggregateOutputType | null
    _max: AlarmMaxAggregateOutputType | null
  }

  export type AlarmMinAggregateOutputType = {
    id: string | null
    type: string | null
    source: string | null
    message: string | null
    severity: string | null
    status: string | null
    data: string | null
    acknowledgedAt: Date | null
    acknowledgedBy: string | null
    resolvedAt: Date | null
    resolvedBy: string | null
    resolution: string | null
    createdAt: Date | null
  }

  export type AlarmMaxAggregateOutputType = {
    id: string | null
    type: string | null
    source: string | null
    message: string | null
    severity: string | null
    status: string | null
    data: string | null
    acknowledgedAt: Date | null
    acknowledgedBy: string | null
    resolvedAt: Date | null
    resolvedBy: string | null
    resolution: string | null
    createdAt: Date | null
  }

  export type AlarmCountAggregateOutputType = {
    id: number
    type: number
    source: number
    message: number
    severity: number
    status: number
    data: number
    acknowledgedAt: number
    acknowledgedBy: number
    resolvedAt: number
    resolvedBy: number
    resolution: number
    createdAt: number
    _all: number
  }


  export type AlarmMinAggregateInputType = {
    id?: true
    type?: true
    source?: true
    message?: true
    severity?: true
    status?: true
    data?: true
    acknowledgedAt?: true
    acknowledgedBy?: true
    resolvedAt?: true
    resolvedBy?: true
    resolution?: true
    createdAt?: true
  }

  export type AlarmMaxAggregateInputType = {
    id?: true
    type?: true
    source?: true
    message?: true
    severity?: true
    status?: true
    data?: true
    acknowledgedAt?: true
    acknowledgedBy?: true
    resolvedAt?: true
    resolvedBy?: true
    resolution?: true
    createdAt?: true
  }

  export type AlarmCountAggregateInputType = {
    id?: true
    type?: true
    source?: true
    message?: true
    severity?: true
    status?: true
    data?: true
    acknowledgedAt?: true
    acknowledgedBy?: true
    resolvedAt?: true
    resolvedBy?: true
    resolution?: true
    createdAt?: true
    _all?: true
  }

  export type AlarmAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alarm to aggregate.
     */
    where?: AlarmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alarms to fetch.
     */
    orderBy?: AlarmOrderByWithRelationInput | AlarmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlarmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alarms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alarms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alarms
    **/
    _count?: true | AlarmCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlarmMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlarmMaxAggregateInputType
  }

  export type GetAlarmAggregateType<T extends AlarmAggregateArgs> = {
        [P in keyof T & keyof AggregateAlarm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlarm[P]>
      : GetScalarType<T[P], AggregateAlarm[P]>
  }




  export type AlarmGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlarmWhereInput
    orderBy?: AlarmOrderByWithAggregationInput | AlarmOrderByWithAggregationInput[]
    by: AlarmScalarFieldEnum[] | AlarmScalarFieldEnum
    having?: AlarmScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlarmCountAggregateInputType | true
    _min?: AlarmMinAggregateInputType
    _max?: AlarmMaxAggregateInputType
  }

  export type AlarmGroupByOutputType = {
    id: string
    type: string
    source: string
    message: string
    severity: string
    status: string
    data: string | null
    acknowledgedAt: Date | null
    acknowledgedBy: string | null
    resolvedAt: Date | null
    resolvedBy: string | null
    resolution: string | null
    createdAt: Date
    _count: AlarmCountAggregateOutputType | null
    _min: AlarmMinAggregateOutputType | null
    _max: AlarmMaxAggregateOutputType | null
  }

  type GetAlarmGroupByPayload<T extends AlarmGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlarmGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlarmGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlarmGroupByOutputType[P]>
            : GetScalarType<T[P], AlarmGroupByOutputType[P]>
        }
      >
    >


  export type AlarmSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    source?: boolean
    message?: boolean
    severity?: boolean
    status?: boolean
    data?: boolean
    acknowledgedAt?: boolean
    acknowledgedBy?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    resolution?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["alarm"]>

  export type AlarmSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    source?: boolean
    message?: boolean
    severity?: boolean
    status?: boolean
    data?: boolean
    acknowledgedAt?: boolean
    acknowledgedBy?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    resolution?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["alarm"]>

  export type AlarmSelectScalar = {
    id?: boolean
    type?: boolean
    source?: boolean
    message?: boolean
    severity?: boolean
    status?: boolean
    data?: boolean
    acknowledgedAt?: boolean
    acknowledgedBy?: boolean
    resolvedAt?: boolean
    resolvedBy?: boolean
    resolution?: boolean
    createdAt?: boolean
  }


  export type $AlarmPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Alarm"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      source: string
      message: string
      severity: string
      status: string
      data: string | null
      acknowledgedAt: Date | null
      acknowledgedBy: string | null
      resolvedAt: Date | null
      resolvedBy: string | null
      resolution: string | null
      createdAt: Date
    }, ExtArgs["result"]["alarm"]>
    composites: {}
  }

  type AlarmGetPayload<S extends boolean | null | undefined | AlarmDefaultArgs> = $Result.GetResult<Prisma.$AlarmPayload, S>

  type AlarmCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AlarmFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AlarmCountAggregateInputType | true
    }

  export interface AlarmDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Alarm'], meta: { name: 'Alarm' } }
    /**
     * Find zero or one Alarm that matches the filter.
     * @param {AlarmFindUniqueArgs} args - Arguments to find a Alarm
     * @example
     * // Get one Alarm
     * const alarm = await prisma.alarm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlarmFindUniqueArgs>(args: SelectSubset<T, AlarmFindUniqueArgs<ExtArgs>>): Prisma__AlarmClient<$Result.GetResult<Prisma.$AlarmPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Alarm that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AlarmFindUniqueOrThrowArgs} args - Arguments to find a Alarm
     * @example
     * // Get one Alarm
     * const alarm = await prisma.alarm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlarmFindUniqueOrThrowArgs>(args: SelectSubset<T, AlarmFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlarmClient<$Result.GetResult<Prisma.$AlarmPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Alarm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmFindFirstArgs} args - Arguments to find a Alarm
     * @example
     * // Get one Alarm
     * const alarm = await prisma.alarm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlarmFindFirstArgs>(args?: SelectSubset<T, AlarmFindFirstArgs<ExtArgs>>): Prisma__AlarmClient<$Result.GetResult<Prisma.$AlarmPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Alarm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmFindFirstOrThrowArgs} args - Arguments to find a Alarm
     * @example
     * // Get one Alarm
     * const alarm = await prisma.alarm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlarmFindFirstOrThrowArgs>(args?: SelectSubset<T, AlarmFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlarmClient<$Result.GetResult<Prisma.$AlarmPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Alarms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alarms
     * const alarms = await prisma.alarm.findMany()
     * 
     * // Get first 10 Alarms
     * const alarms = await prisma.alarm.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alarmWithIdOnly = await prisma.alarm.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlarmFindManyArgs>(args?: SelectSubset<T, AlarmFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlarmPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Alarm.
     * @param {AlarmCreateArgs} args - Arguments to create a Alarm.
     * @example
     * // Create one Alarm
     * const Alarm = await prisma.alarm.create({
     *   data: {
     *     // ... data to create a Alarm
     *   }
     * })
     * 
     */
    create<T extends AlarmCreateArgs>(args: SelectSubset<T, AlarmCreateArgs<ExtArgs>>): Prisma__AlarmClient<$Result.GetResult<Prisma.$AlarmPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Alarms.
     * @param {AlarmCreateManyArgs} args - Arguments to create many Alarms.
     * @example
     * // Create many Alarms
     * const alarm = await prisma.alarm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlarmCreateManyArgs>(args?: SelectSubset<T, AlarmCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Alarms and returns the data saved in the database.
     * @param {AlarmCreateManyAndReturnArgs} args - Arguments to create many Alarms.
     * @example
     * // Create many Alarms
     * const alarm = await prisma.alarm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Alarms and only return the `id`
     * const alarmWithIdOnly = await prisma.alarm.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlarmCreateManyAndReturnArgs>(args?: SelectSubset<T, AlarmCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlarmPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Alarm.
     * @param {AlarmDeleteArgs} args - Arguments to delete one Alarm.
     * @example
     * // Delete one Alarm
     * const Alarm = await prisma.alarm.delete({
     *   where: {
     *     // ... filter to delete one Alarm
     *   }
     * })
     * 
     */
    delete<T extends AlarmDeleteArgs>(args: SelectSubset<T, AlarmDeleteArgs<ExtArgs>>): Prisma__AlarmClient<$Result.GetResult<Prisma.$AlarmPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Alarm.
     * @param {AlarmUpdateArgs} args - Arguments to update one Alarm.
     * @example
     * // Update one Alarm
     * const alarm = await prisma.alarm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlarmUpdateArgs>(args: SelectSubset<T, AlarmUpdateArgs<ExtArgs>>): Prisma__AlarmClient<$Result.GetResult<Prisma.$AlarmPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Alarms.
     * @param {AlarmDeleteManyArgs} args - Arguments to filter Alarms to delete.
     * @example
     * // Delete a few Alarms
     * const { count } = await prisma.alarm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlarmDeleteManyArgs>(args?: SelectSubset<T, AlarmDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alarms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alarms
     * const alarm = await prisma.alarm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlarmUpdateManyArgs>(args: SelectSubset<T, AlarmUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Alarm.
     * @param {AlarmUpsertArgs} args - Arguments to update or create a Alarm.
     * @example
     * // Update or create a Alarm
     * const alarm = await prisma.alarm.upsert({
     *   create: {
     *     // ... data to create a Alarm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alarm we want to update
     *   }
     * })
     */
    upsert<T extends AlarmUpsertArgs>(args: SelectSubset<T, AlarmUpsertArgs<ExtArgs>>): Prisma__AlarmClient<$Result.GetResult<Prisma.$AlarmPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Alarms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmCountArgs} args - Arguments to filter Alarms to count.
     * @example
     * // Count the number of Alarms
     * const count = await prisma.alarm.count({
     *   where: {
     *     // ... the filter for the Alarms we want to count
     *   }
     * })
    **/
    count<T extends AlarmCountArgs>(
      args?: Subset<T, AlarmCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlarmCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alarm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlarmAggregateArgs>(args: Subset<T, AlarmAggregateArgs>): Prisma.PrismaPromise<GetAlarmAggregateType<T>>

    /**
     * Group by Alarm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlarmGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlarmGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlarmGroupByArgs['orderBy'] }
        : { orderBy?: AlarmGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlarmGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlarmGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Alarm model
   */
  readonly fields: AlarmFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Alarm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlarmClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Alarm model
   */ 
  interface AlarmFieldRefs {
    readonly id: FieldRef<"Alarm", 'String'>
    readonly type: FieldRef<"Alarm", 'String'>
    readonly source: FieldRef<"Alarm", 'String'>
    readonly message: FieldRef<"Alarm", 'String'>
    readonly severity: FieldRef<"Alarm", 'String'>
    readonly status: FieldRef<"Alarm", 'String'>
    readonly data: FieldRef<"Alarm", 'String'>
    readonly acknowledgedAt: FieldRef<"Alarm", 'DateTime'>
    readonly acknowledgedBy: FieldRef<"Alarm", 'String'>
    readonly resolvedAt: FieldRef<"Alarm", 'DateTime'>
    readonly resolvedBy: FieldRef<"Alarm", 'String'>
    readonly resolution: FieldRef<"Alarm", 'String'>
    readonly createdAt: FieldRef<"Alarm", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Alarm findUnique
   */
  export type AlarmFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alarm
     */
    select?: AlarmSelect<ExtArgs> | null
    /**
     * Filter, which Alarm to fetch.
     */
    where: AlarmWhereUniqueInput
  }

  /**
   * Alarm findUniqueOrThrow
   */
  export type AlarmFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alarm
     */
    select?: AlarmSelect<ExtArgs> | null
    /**
     * Filter, which Alarm to fetch.
     */
    where: AlarmWhereUniqueInput
  }

  /**
   * Alarm findFirst
   */
  export type AlarmFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alarm
     */
    select?: AlarmSelect<ExtArgs> | null
    /**
     * Filter, which Alarm to fetch.
     */
    where?: AlarmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alarms to fetch.
     */
    orderBy?: AlarmOrderByWithRelationInput | AlarmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alarms.
     */
    cursor?: AlarmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alarms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alarms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alarms.
     */
    distinct?: AlarmScalarFieldEnum | AlarmScalarFieldEnum[]
  }

  /**
   * Alarm findFirstOrThrow
   */
  export type AlarmFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alarm
     */
    select?: AlarmSelect<ExtArgs> | null
    /**
     * Filter, which Alarm to fetch.
     */
    where?: AlarmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alarms to fetch.
     */
    orderBy?: AlarmOrderByWithRelationInput | AlarmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alarms.
     */
    cursor?: AlarmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alarms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alarms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alarms.
     */
    distinct?: AlarmScalarFieldEnum | AlarmScalarFieldEnum[]
  }

  /**
   * Alarm findMany
   */
  export type AlarmFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alarm
     */
    select?: AlarmSelect<ExtArgs> | null
    /**
     * Filter, which Alarms to fetch.
     */
    where?: AlarmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alarms to fetch.
     */
    orderBy?: AlarmOrderByWithRelationInput | AlarmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alarms.
     */
    cursor?: AlarmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alarms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alarms.
     */
    skip?: number
    distinct?: AlarmScalarFieldEnum | AlarmScalarFieldEnum[]
  }

  /**
   * Alarm create
   */
  export type AlarmCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alarm
     */
    select?: AlarmSelect<ExtArgs> | null
    /**
     * The data needed to create a Alarm.
     */
    data: XOR<AlarmCreateInput, AlarmUncheckedCreateInput>
  }

  /**
   * Alarm createMany
   */
  export type AlarmCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alarms.
     */
    data: AlarmCreateManyInput | AlarmCreateManyInput[]
  }

  /**
   * Alarm createManyAndReturn
   */
  export type AlarmCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alarm
     */
    select?: AlarmSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Alarms.
     */
    data: AlarmCreateManyInput | AlarmCreateManyInput[]
  }

  /**
   * Alarm update
   */
  export type AlarmUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alarm
     */
    select?: AlarmSelect<ExtArgs> | null
    /**
     * The data needed to update a Alarm.
     */
    data: XOR<AlarmUpdateInput, AlarmUncheckedUpdateInput>
    /**
     * Choose, which Alarm to update.
     */
    where: AlarmWhereUniqueInput
  }

  /**
   * Alarm updateMany
   */
  export type AlarmUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alarms.
     */
    data: XOR<AlarmUpdateManyMutationInput, AlarmUncheckedUpdateManyInput>
    /**
     * Filter which Alarms to update
     */
    where?: AlarmWhereInput
  }

  /**
   * Alarm upsert
   */
  export type AlarmUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alarm
     */
    select?: AlarmSelect<ExtArgs> | null
    /**
     * The filter to search for the Alarm to update in case it exists.
     */
    where: AlarmWhereUniqueInput
    /**
     * In case the Alarm found by the `where` argument doesn't exist, create a new Alarm with this data.
     */
    create: XOR<AlarmCreateInput, AlarmUncheckedCreateInput>
    /**
     * In case the Alarm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlarmUpdateInput, AlarmUncheckedUpdateInput>
  }

  /**
   * Alarm delete
   */
  export type AlarmDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alarm
     */
    select?: AlarmSelect<ExtArgs> | null
    /**
     * Filter which Alarm to delete.
     */
    where: AlarmWhereUniqueInput
  }

  /**
   * Alarm deleteMany
   */
  export type AlarmDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alarms to delete
     */
    where?: AlarmWhereInput
  }

  /**
   * Alarm without action
   */
  export type AlarmDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alarm
     */
    select?: AlarmSelect<ExtArgs> | null
  }


  /**
   * Model SafetyEvent
   */

  export type AggregateSafetyEvent = {
    _count: SafetyEventCountAggregateOutputType | null
    _min: SafetyEventMinAggregateOutputType | null
    _max: SafetyEventMaxAggregateOutputType | null
  }

  export type SafetyEventMinAggregateOutputType = {
    id: string | null
    type: string | null
    description: string | null
    severity: string | null
    data: string | null
    createdAt: Date | null
  }

  export type SafetyEventMaxAggregateOutputType = {
    id: string | null
    type: string | null
    description: string | null
    severity: string | null
    data: string | null
    createdAt: Date | null
  }

  export type SafetyEventCountAggregateOutputType = {
    id: number
    type: number
    description: number
    severity: number
    data: number
    createdAt: number
    _all: number
  }


  export type SafetyEventMinAggregateInputType = {
    id?: true
    type?: true
    description?: true
    severity?: true
    data?: true
    createdAt?: true
  }

  export type SafetyEventMaxAggregateInputType = {
    id?: true
    type?: true
    description?: true
    severity?: true
    data?: true
    createdAt?: true
  }

  export type SafetyEventCountAggregateInputType = {
    id?: true
    type?: true
    description?: true
    severity?: true
    data?: true
    createdAt?: true
    _all?: true
  }

  export type SafetyEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SafetyEvent to aggregate.
     */
    where?: SafetyEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SafetyEvents to fetch.
     */
    orderBy?: SafetyEventOrderByWithRelationInput | SafetyEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SafetyEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SafetyEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SafetyEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SafetyEvents
    **/
    _count?: true | SafetyEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SafetyEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SafetyEventMaxAggregateInputType
  }

  export type GetSafetyEventAggregateType<T extends SafetyEventAggregateArgs> = {
        [P in keyof T & keyof AggregateSafetyEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSafetyEvent[P]>
      : GetScalarType<T[P], AggregateSafetyEvent[P]>
  }




  export type SafetyEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SafetyEventWhereInput
    orderBy?: SafetyEventOrderByWithAggregationInput | SafetyEventOrderByWithAggregationInput[]
    by: SafetyEventScalarFieldEnum[] | SafetyEventScalarFieldEnum
    having?: SafetyEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SafetyEventCountAggregateInputType | true
    _min?: SafetyEventMinAggregateInputType
    _max?: SafetyEventMaxAggregateInputType
  }

  export type SafetyEventGroupByOutputType = {
    id: string
    type: string
    description: string
    severity: string
    data: string | null
    createdAt: Date
    _count: SafetyEventCountAggregateOutputType | null
    _min: SafetyEventMinAggregateOutputType | null
    _max: SafetyEventMaxAggregateOutputType | null
  }

  type GetSafetyEventGroupByPayload<T extends SafetyEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SafetyEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SafetyEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SafetyEventGroupByOutputType[P]>
            : GetScalarType<T[P], SafetyEventGroupByOutputType[P]>
        }
      >
    >


  export type SafetyEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    description?: boolean
    severity?: boolean
    data?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["safetyEvent"]>

  export type SafetyEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    description?: boolean
    severity?: boolean
    data?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["safetyEvent"]>

  export type SafetyEventSelectScalar = {
    id?: boolean
    type?: boolean
    description?: boolean
    severity?: boolean
    data?: boolean
    createdAt?: boolean
  }


  export type $SafetyEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SafetyEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      description: string
      severity: string
      data: string | null
      createdAt: Date
    }, ExtArgs["result"]["safetyEvent"]>
    composites: {}
  }

  type SafetyEventGetPayload<S extends boolean | null | undefined | SafetyEventDefaultArgs> = $Result.GetResult<Prisma.$SafetyEventPayload, S>

  type SafetyEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SafetyEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SafetyEventCountAggregateInputType | true
    }

  export interface SafetyEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SafetyEvent'], meta: { name: 'SafetyEvent' } }
    /**
     * Find zero or one SafetyEvent that matches the filter.
     * @param {SafetyEventFindUniqueArgs} args - Arguments to find a SafetyEvent
     * @example
     * // Get one SafetyEvent
     * const safetyEvent = await prisma.safetyEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SafetyEventFindUniqueArgs>(args: SelectSubset<T, SafetyEventFindUniqueArgs<ExtArgs>>): Prisma__SafetyEventClient<$Result.GetResult<Prisma.$SafetyEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SafetyEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SafetyEventFindUniqueOrThrowArgs} args - Arguments to find a SafetyEvent
     * @example
     * // Get one SafetyEvent
     * const safetyEvent = await prisma.safetyEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SafetyEventFindUniqueOrThrowArgs>(args: SelectSubset<T, SafetyEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SafetyEventClient<$Result.GetResult<Prisma.$SafetyEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SafetyEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyEventFindFirstArgs} args - Arguments to find a SafetyEvent
     * @example
     * // Get one SafetyEvent
     * const safetyEvent = await prisma.safetyEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SafetyEventFindFirstArgs>(args?: SelectSubset<T, SafetyEventFindFirstArgs<ExtArgs>>): Prisma__SafetyEventClient<$Result.GetResult<Prisma.$SafetyEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SafetyEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyEventFindFirstOrThrowArgs} args - Arguments to find a SafetyEvent
     * @example
     * // Get one SafetyEvent
     * const safetyEvent = await prisma.safetyEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SafetyEventFindFirstOrThrowArgs>(args?: SelectSubset<T, SafetyEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__SafetyEventClient<$Result.GetResult<Prisma.$SafetyEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SafetyEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SafetyEvents
     * const safetyEvents = await prisma.safetyEvent.findMany()
     * 
     * // Get first 10 SafetyEvents
     * const safetyEvents = await prisma.safetyEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const safetyEventWithIdOnly = await prisma.safetyEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SafetyEventFindManyArgs>(args?: SelectSubset<T, SafetyEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SafetyEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SafetyEvent.
     * @param {SafetyEventCreateArgs} args - Arguments to create a SafetyEvent.
     * @example
     * // Create one SafetyEvent
     * const SafetyEvent = await prisma.safetyEvent.create({
     *   data: {
     *     // ... data to create a SafetyEvent
     *   }
     * })
     * 
     */
    create<T extends SafetyEventCreateArgs>(args: SelectSubset<T, SafetyEventCreateArgs<ExtArgs>>): Prisma__SafetyEventClient<$Result.GetResult<Prisma.$SafetyEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SafetyEvents.
     * @param {SafetyEventCreateManyArgs} args - Arguments to create many SafetyEvents.
     * @example
     * // Create many SafetyEvents
     * const safetyEvent = await prisma.safetyEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SafetyEventCreateManyArgs>(args?: SelectSubset<T, SafetyEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SafetyEvents and returns the data saved in the database.
     * @param {SafetyEventCreateManyAndReturnArgs} args - Arguments to create many SafetyEvents.
     * @example
     * // Create many SafetyEvents
     * const safetyEvent = await prisma.safetyEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SafetyEvents and only return the `id`
     * const safetyEventWithIdOnly = await prisma.safetyEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SafetyEventCreateManyAndReturnArgs>(args?: SelectSubset<T, SafetyEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SafetyEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SafetyEvent.
     * @param {SafetyEventDeleteArgs} args - Arguments to delete one SafetyEvent.
     * @example
     * // Delete one SafetyEvent
     * const SafetyEvent = await prisma.safetyEvent.delete({
     *   where: {
     *     // ... filter to delete one SafetyEvent
     *   }
     * })
     * 
     */
    delete<T extends SafetyEventDeleteArgs>(args: SelectSubset<T, SafetyEventDeleteArgs<ExtArgs>>): Prisma__SafetyEventClient<$Result.GetResult<Prisma.$SafetyEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SafetyEvent.
     * @param {SafetyEventUpdateArgs} args - Arguments to update one SafetyEvent.
     * @example
     * // Update one SafetyEvent
     * const safetyEvent = await prisma.safetyEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SafetyEventUpdateArgs>(args: SelectSubset<T, SafetyEventUpdateArgs<ExtArgs>>): Prisma__SafetyEventClient<$Result.GetResult<Prisma.$SafetyEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SafetyEvents.
     * @param {SafetyEventDeleteManyArgs} args - Arguments to filter SafetyEvents to delete.
     * @example
     * // Delete a few SafetyEvents
     * const { count } = await prisma.safetyEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SafetyEventDeleteManyArgs>(args?: SelectSubset<T, SafetyEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SafetyEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SafetyEvents
     * const safetyEvent = await prisma.safetyEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SafetyEventUpdateManyArgs>(args: SelectSubset<T, SafetyEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SafetyEvent.
     * @param {SafetyEventUpsertArgs} args - Arguments to update or create a SafetyEvent.
     * @example
     * // Update or create a SafetyEvent
     * const safetyEvent = await prisma.safetyEvent.upsert({
     *   create: {
     *     // ... data to create a SafetyEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SafetyEvent we want to update
     *   }
     * })
     */
    upsert<T extends SafetyEventUpsertArgs>(args: SelectSubset<T, SafetyEventUpsertArgs<ExtArgs>>): Prisma__SafetyEventClient<$Result.GetResult<Prisma.$SafetyEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SafetyEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyEventCountArgs} args - Arguments to filter SafetyEvents to count.
     * @example
     * // Count the number of SafetyEvents
     * const count = await prisma.safetyEvent.count({
     *   where: {
     *     // ... the filter for the SafetyEvents we want to count
     *   }
     * })
    **/
    count<T extends SafetyEventCountArgs>(
      args?: Subset<T, SafetyEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SafetyEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SafetyEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SafetyEventAggregateArgs>(args: Subset<T, SafetyEventAggregateArgs>): Prisma.PrismaPromise<GetSafetyEventAggregateType<T>>

    /**
     * Group by SafetyEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SafetyEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SafetyEventGroupByArgs['orderBy'] }
        : { orderBy?: SafetyEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SafetyEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSafetyEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SafetyEvent model
   */
  readonly fields: SafetyEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SafetyEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SafetyEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SafetyEvent model
   */ 
  interface SafetyEventFieldRefs {
    readonly id: FieldRef<"SafetyEvent", 'String'>
    readonly type: FieldRef<"SafetyEvent", 'String'>
    readonly description: FieldRef<"SafetyEvent", 'String'>
    readonly severity: FieldRef<"SafetyEvent", 'String'>
    readonly data: FieldRef<"SafetyEvent", 'String'>
    readonly createdAt: FieldRef<"SafetyEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SafetyEvent findUnique
   */
  export type SafetyEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyEvent
     */
    select?: SafetyEventSelect<ExtArgs> | null
    /**
     * Filter, which SafetyEvent to fetch.
     */
    where: SafetyEventWhereUniqueInput
  }

  /**
   * SafetyEvent findUniqueOrThrow
   */
  export type SafetyEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyEvent
     */
    select?: SafetyEventSelect<ExtArgs> | null
    /**
     * Filter, which SafetyEvent to fetch.
     */
    where: SafetyEventWhereUniqueInput
  }

  /**
   * SafetyEvent findFirst
   */
  export type SafetyEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyEvent
     */
    select?: SafetyEventSelect<ExtArgs> | null
    /**
     * Filter, which SafetyEvent to fetch.
     */
    where?: SafetyEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SafetyEvents to fetch.
     */
    orderBy?: SafetyEventOrderByWithRelationInput | SafetyEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SafetyEvents.
     */
    cursor?: SafetyEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SafetyEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SafetyEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SafetyEvents.
     */
    distinct?: SafetyEventScalarFieldEnum | SafetyEventScalarFieldEnum[]
  }

  /**
   * SafetyEvent findFirstOrThrow
   */
  export type SafetyEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyEvent
     */
    select?: SafetyEventSelect<ExtArgs> | null
    /**
     * Filter, which SafetyEvent to fetch.
     */
    where?: SafetyEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SafetyEvents to fetch.
     */
    orderBy?: SafetyEventOrderByWithRelationInput | SafetyEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SafetyEvents.
     */
    cursor?: SafetyEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SafetyEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SafetyEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SafetyEvents.
     */
    distinct?: SafetyEventScalarFieldEnum | SafetyEventScalarFieldEnum[]
  }

  /**
   * SafetyEvent findMany
   */
  export type SafetyEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyEvent
     */
    select?: SafetyEventSelect<ExtArgs> | null
    /**
     * Filter, which SafetyEvents to fetch.
     */
    where?: SafetyEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SafetyEvents to fetch.
     */
    orderBy?: SafetyEventOrderByWithRelationInput | SafetyEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SafetyEvents.
     */
    cursor?: SafetyEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SafetyEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SafetyEvents.
     */
    skip?: number
    distinct?: SafetyEventScalarFieldEnum | SafetyEventScalarFieldEnum[]
  }

  /**
   * SafetyEvent create
   */
  export type SafetyEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyEvent
     */
    select?: SafetyEventSelect<ExtArgs> | null
    /**
     * The data needed to create a SafetyEvent.
     */
    data: XOR<SafetyEventCreateInput, SafetyEventUncheckedCreateInput>
  }

  /**
   * SafetyEvent createMany
   */
  export type SafetyEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SafetyEvents.
     */
    data: SafetyEventCreateManyInput | SafetyEventCreateManyInput[]
  }

  /**
   * SafetyEvent createManyAndReturn
   */
  export type SafetyEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyEvent
     */
    select?: SafetyEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SafetyEvents.
     */
    data: SafetyEventCreateManyInput | SafetyEventCreateManyInput[]
  }

  /**
   * SafetyEvent update
   */
  export type SafetyEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyEvent
     */
    select?: SafetyEventSelect<ExtArgs> | null
    /**
     * The data needed to update a SafetyEvent.
     */
    data: XOR<SafetyEventUpdateInput, SafetyEventUncheckedUpdateInput>
    /**
     * Choose, which SafetyEvent to update.
     */
    where: SafetyEventWhereUniqueInput
  }

  /**
   * SafetyEvent updateMany
   */
  export type SafetyEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SafetyEvents.
     */
    data: XOR<SafetyEventUpdateManyMutationInput, SafetyEventUncheckedUpdateManyInput>
    /**
     * Filter which SafetyEvents to update
     */
    where?: SafetyEventWhereInput
  }

  /**
   * SafetyEvent upsert
   */
  export type SafetyEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyEvent
     */
    select?: SafetyEventSelect<ExtArgs> | null
    /**
     * The filter to search for the SafetyEvent to update in case it exists.
     */
    where: SafetyEventWhereUniqueInput
    /**
     * In case the SafetyEvent found by the `where` argument doesn't exist, create a new SafetyEvent with this data.
     */
    create: XOR<SafetyEventCreateInput, SafetyEventUncheckedCreateInput>
    /**
     * In case the SafetyEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SafetyEventUpdateInput, SafetyEventUncheckedUpdateInput>
  }

  /**
   * SafetyEvent delete
   */
  export type SafetyEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyEvent
     */
    select?: SafetyEventSelect<ExtArgs> | null
    /**
     * Filter which SafetyEvent to delete.
     */
    where: SafetyEventWhereUniqueInput
  }

  /**
   * SafetyEvent deleteMany
   */
  export type SafetyEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SafetyEvents to delete
     */
    where?: SafetyEventWhereInput
  }

  /**
   * SafetyEvent without action
   */
  export type SafetyEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyEvent
     */
    select?: SafetyEventSelect<ExtArgs> | null
  }


  /**
   * Model SafetyRule
   */

  export type AggregateSafetyRule = {
    _count: SafetyRuleCountAggregateOutputType | null
    _avg: SafetyRuleAvgAggregateOutputType | null
    _sum: SafetyRuleSumAggregateOutputType | null
    _min: SafetyRuleMinAggregateOutputType | null
    _max: SafetyRuleMaxAggregateOutputType | null
  }

  export type SafetyRuleAvgAggregateOutputType = {
    threshold: number | null
  }

  export type SafetyRuleSumAggregateOutputType = {
    threshold: number | null
  }

  export type SafetyRuleMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    condition: string | null
    threshold: number | null
    action: string | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SafetyRuleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    condition: string | null
    threshold: number | null
    action: string | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SafetyRuleCountAggregateOutputType = {
    id: number
    name: number
    type: number
    condition: number
    threshold: number
    action: number
    enabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SafetyRuleAvgAggregateInputType = {
    threshold?: true
  }

  export type SafetyRuleSumAggregateInputType = {
    threshold?: true
  }

  export type SafetyRuleMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    condition?: true
    threshold?: true
    action?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SafetyRuleMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    condition?: true
    threshold?: true
    action?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SafetyRuleCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    condition?: true
    threshold?: true
    action?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SafetyRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SafetyRule to aggregate.
     */
    where?: SafetyRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SafetyRules to fetch.
     */
    orderBy?: SafetyRuleOrderByWithRelationInput | SafetyRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SafetyRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SafetyRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SafetyRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SafetyRules
    **/
    _count?: true | SafetyRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SafetyRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SafetyRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SafetyRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SafetyRuleMaxAggregateInputType
  }

  export type GetSafetyRuleAggregateType<T extends SafetyRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateSafetyRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSafetyRule[P]>
      : GetScalarType<T[P], AggregateSafetyRule[P]>
  }




  export type SafetyRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SafetyRuleWhereInput
    orderBy?: SafetyRuleOrderByWithAggregationInput | SafetyRuleOrderByWithAggregationInput[]
    by: SafetyRuleScalarFieldEnum[] | SafetyRuleScalarFieldEnum
    having?: SafetyRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SafetyRuleCountAggregateInputType | true
    _avg?: SafetyRuleAvgAggregateInputType
    _sum?: SafetyRuleSumAggregateInputType
    _min?: SafetyRuleMinAggregateInputType
    _max?: SafetyRuleMaxAggregateInputType
  }

  export type SafetyRuleGroupByOutputType = {
    id: string
    name: string
    type: string
    condition: string
    threshold: number
    action: string
    enabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: SafetyRuleCountAggregateOutputType | null
    _avg: SafetyRuleAvgAggregateOutputType | null
    _sum: SafetyRuleSumAggregateOutputType | null
    _min: SafetyRuleMinAggregateOutputType | null
    _max: SafetyRuleMaxAggregateOutputType | null
  }

  type GetSafetyRuleGroupByPayload<T extends SafetyRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SafetyRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SafetyRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SafetyRuleGroupByOutputType[P]>
            : GetScalarType<T[P], SafetyRuleGroupByOutputType[P]>
        }
      >
    >


  export type SafetyRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    condition?: boolean
    threshold?: boolean
    action?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["safetyRule"]>

  export type SafetyRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    condition?: boolean
    threshold?: boolean
    action?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["safetyRule"]>

  export type SafetyRuleSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    condition?: boolean
    threshold?: boolean
    action?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $SafetyRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SafetyRule"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      condition: string
      threshold: number
      action: string
      enabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["safetyRule"]>
    composites: {}
  }

  type SafetyRuleGetPayload<S extends boolean | null | undefined | SafetyRuleDefaultArgs> = $Result.GetResult<Prisma.$SafetyRulePayload, S>

  type SafetyRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SafetyRuleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SafetyRuleCountAggregateInputType | true
    }

  export interface SafetyRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SafetyRule'], meta: { name: 'SafetyRule' } }
    /**
     * Find zero or one SafetyRule that matches the filter.
     * @param {SafetyRuleFindUniqueArgs} args - Arguments to find a SafetyRule
     * @example
     * // Get one SafetyRule
     * const safetyRule = await prisma.safetyRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SafetyRuleFindUniqueArgs>(args: SelectSubset<T, SafetyRuleFindUniqueArgs<ExtArgs>>): Prisma__SafetyRuleClient<$Result.GetResult<Prisma.$SafetyRulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SafetyRule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SafetyRuleFindUniqueOrThrowArgs} args - Arguments to find a SafetyRule
     * @example
     * // Get one SafetyRule
     * const safetyRule = await prisma.safetyRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SafetyRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, SafetyRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SafetyRuleClient<$Result.GetResult<Prisma.$SafetyRulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SafetyRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyRuleFindFirstArgs} args - Arguments to find a SafetyRule
     * @example
     * // Get one SafetyRule
     * const safetyRule = await prisma.safetyRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SafetyRuleFindFirstArgs>(args?: SelectSubset<T, SafetyRuleFindFirstArgs<ExtArgs>>): Prisma__SafetyRuleClient<$Result.GetResult<Prisma.$SafetyRulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SafetyRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyRuleFindFirstOrThrowArgs} args - Arguments to find a SafetyRule
     * @example
     * // Get one SafetyRule
     * const safetyRule = await prisma.safetyRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SafetyRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, SafetyRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__SafetyRuleClient<$Result.GetResult<Prisma.$SafetyRulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SafetyRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SafetyRules
     * const safetyRules = await prisma.safetyRule.findMany()
     * 
     * // Get first 10 SafetyRules
     * const safetyRules = await prisma.safetyRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const safetyRuleWithIdOnly = await prisma.safetyRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SafetyRuleFindManyArgs>(args?: SelectSubset<T, SafetyRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SafetyRulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SafetyRule.
     * @param {SafetyRuleCreateArgs} args - Arguments to create a SafetyRule.
     * @example
     * // Create one SafetyRule
     * const SafetyRule = await prisma.safetyRule.create({
     *   data: {
     *     // ... data to create a SafetyRule
     *   }
     * })
     * 
     */
    create<T extends SafetyRuleCreateArgs>(args: SelectSubset<T, SafetyRuleCreateArgs<ExtArgs>>): Prisma__SafetyRuleClient<$Result.GetResult<Prisma.$SafetyRulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SafetyRules.
     * @param {SafetyRuleCreateManyArgs} args - Arguments to create many SafetyRules.
     * @example
     * // Create many SafetyRules
     * const safetyRule = await prisma.safetyRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SafetyRuleCreateManyArgs>(args?: SelectSubset<T, SafetyRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SafetyRules and returns the data saved in the database.
     * @param {SafetyRuleCreateManyAndReturnArgs} args - Arguments to create many SafetyRules.
     * @example
     * // Create many SafetyRules
     * const safetyRule = await prisma.safetyRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SafetyRules and only return the `id`
     * const safetyRuleWithIdOnly = await prisma.safetyRule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SafetyRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, SafetyRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SafetyRulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SafetyRule.
     * @param {SafetyRuleDeleteArgs} args - Arguments to delete one SafetyRule.
     * @example
     * // Delete one SafetyRule
     * const SafetyRule = await prisma.safetyRule.delete({
     *   where: {
     *     // ... filter to delete one SafetyRule
     *   }
     * })
     * 
     */
    delete<T extends SafetyRuleDeleteArgs>(args: SelectSubset<T, SafetyRuleDeleteArgs<ExtArgs>>): Prisma__SafetyRuleClient<$Result.GetResult<Prisma.$SafetyRulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SafetyRule.
     * @param {SafetyRuleUpdateArgs} args - Arguments to update one SafetyRule.
     * @example
     * // Update one SafetyRule
     * const safetyRule = await prisma.safetyRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SafetyRuleUpdateArgs>(args: SelectSubset<T, SafetyRuleUpdateArgs<ExtArgs>>): Prisma__SafetyRuleClient<$Result.GetResult<Prisma.$SafetyRulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SafetyRules.
     * @param {SafetyRuleDeleteManyArgs} args - Arguments to filter SafetyRules to delete.
     * @example
     * // Delete a few SafetyRules
     * const { count } = await prisma.safetyRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SafetyRuleDeleteManyArgs>(args?: SelectSubset<T, SafetyRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SafetyRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SafetyRules
     * const safetyRule = await prisma.safetyRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SafetyRuleUpdateManyArgs>(args: SelectSubset<T, SafetyRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SafetyRule.
     * @param {SafetyRuleUpsertArgs} args - Arguments to update or create a SafetyRule.
     * @example
     * // Update or create a SafetyRule
     * const safetyRule = await prisma.safetyRule.upsert({
     *   create: {
     *     // ... data to create a SafetyRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SafetyRule we want to update
     *   }
     * })
     */
    upsert<T extends SafetyRuleUpsertArgs>(args: SelectSubset<T, SafetyRuleUpsertArgs<ExtArgs>>): Prisma__SafetyRuleClient<$Result.GetResult<Prisma.$SafetyRulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SafetyRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyRuleCountArgs} args - Arguments to filter SafetyRules to count.
     * @example
     * // Count the number of SafetyRules
     * const count = await prisma.safetyRule.count({
     *   where: {
     *     // ... the filter for the SafetyRules we want to count
     *   }
     * })
    **/
    count<T extends SafetyRuleCountArgs>(
      args?: Subset<T, SafetyRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SafetyRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SafetyRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SafetyRuleAggregateArgs>(args: Subset<T, SafetyRuleAggregateArgs>): Prisma.PrismaPromise<GetSafetyRuleAggregateType<T>>

    /**
     * Group by SafetyRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SafetyRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SafetyRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SafetyRuleGroupByArgs['orderBy'] }
        : { orderBy?: SafetyRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SafetyRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSafetyRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SafetyRule model
   */
  readonly fields: SafetyRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SafetyRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SafetyRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SafetyRule model
   */ 
  interface SafetyRuleFieldRefs {
    readonly id: FieldRef<"SafetyRule", 'String'>
    readonly name: FieldRef<"SafetyRule", 'String'>
    readonly type: FieldRef<"SafetyRule", 'String'>
    readonly condition: FieldRef<"SafetyRule", 'String'>
    readonly threshold: FieldRef<"SafetyRule", 'Float'>
    readonly action: FieldRef<"SafetyRule", 'String'>
    readonly enabled: FieldRef<"SafetyRule", 'Boolean'>
    readonly createdAt: FieldRef<"SafetyRule", 'DateTime'>
    readonly updatedAt: FieldRef<"SafetyRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SafetyRule findUnique
   */
  export type SafetyRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyRule
     */
    select?: SafetyRuleSelect<ExtArgs> | null
    /**
     * Filter, which SafetyRule to fetch.
     */
    where: SafetyRuleWhereUniqueInput
  }

  /**
   * SafetyRule findUniqueOrThrow
   */
  export type SafetyRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyRule
     */
    select?: SafetyRuleSelect<ExtArgs> | null
    /**
     * Filter, which SafetyRule to fetch.
     */
    where: SafetyRuleWhereUniqueInput
  }

  /**
   * SafetyRule findFirst
   */
  export type SafetyRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyRule
     */
    select?: SafetyRuleSelect<ExtArgs> | null
    /**
     * Filter, which SafetyRule to fetch.
     */
    where?: SafetyRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SafetyRules to fetch.
     */
    orderBy?: SafetyRuleOrderByWithRelationInput | SafetyRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SafetyRules.
     */
    cursor?: SafetyRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SafetyRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SafetyRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SafetyRules.
     */
    distinct?: SafetyRuleScalarFieldEnum | SafetyRuleScalarFieldEnum[]
  }

  /**
   * SafetyRule findFirstOrThrow
   */
  export type SafetyRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyRule
     */
    select?: SafetyRuleSelect<ExtArgs> | null
    /**
     * Filter, which SafetyRule to fetch.
     */
    where?: SafetyRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SafetyRules to fetch.
     */
    orderBy?: SafetyRuleOrderByWithRelationInput | SafetyRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SafetyRules.
     */
    cursor?: SafetyRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SafetyRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SafetyRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SafetyRules.
     */
    distinct?: SafetyRuleScalarFieldEnum | SafetyRuleScalarFieldEnum[]
  }

  /**
   * SafetyRule findMany
   */
  export type SafetyRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyRule
     */
    select?: SafetyRuleSelect<ExtArgs> | null
    /**
     * Filter, which SafetyRules to fetch.
     */
    where?: SafetyRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SafetyRules to fetch.
     */
    orderBy?: SafetyRuleOrderByWithRelationInput | SafetyRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SafetyRules.
     */
    cursor?: SafetyRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SafetyRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SafetyRules.
     */
    skip?: number
    distinct?: SafetyRuleScalarFieldEnum | SafetyRuleScalarFieldEnum[]
  }

  /**
   * SafetyRule create
   */
  export type SafetyRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyRule
     */
    select?: SafetyRuleSelect<ExtArgs> | null
    /**
     * The data needed to create a SafetyRule.
     */
    data: XOR<SafetyRuleCreateInput, SafetyRuleUncheckedCreateInput>
  }

  /**
   * SafetyRule createMany
   */
  export type SafetyRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SafetyRules.
     */
    data: SafetyRuleCreateManyInput | SafetyRuleCreateManyInput[]
  }

  /**
   * SafetyRule createManyAndReturn
   */
  export type SafetyRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyRule
     */
    select?: SafetyRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SafetyRules.
     */
    data: SafetyRuleCreateManyInput | SafetyRuleCreateManyInput[]
  }

  /**
   * SafetyRule update
   */
  export type SafetyRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyRule
     */
    select?: SafetyRuleSelect<ExtArgs> | null
    /**
     * The data needed to update a SafetyRule.
     */
    data: XOR<SafetyRuleUpdateInput, SafetyRuleUncheckedUpdateInput>
    /**
     * Choose, which SafetyRule to update.
     */
    where: SafetyRuleWhereUniqueInput
  }

  /**
   * SafetyRule updateMany
   */
  export type SafetyRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SafetyRules.
     */
    data: XOR<SafetyRuleUpdateManyMutationInput, SafetyRuleUncheckedUpdateManyInput>
    /**
     * Filter which SafetyRules to update
     */
    where?: SafetyRuleWhereInput
  }

  /**
   * SafetyRule upsert
   */
  export type SafetyRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyRule
     */
    select?: SafetyRuleSelect<ExtArgs> | null
    /**
     * The filter to search for the SafetyRule to update in case it exists.
     */
    where: SafetyRuleWhereUniqueInput
    /**
     * In case the SafetyRule found by the `where` argument doesn't exist, create a new SafetyRule with this data.
     */
    create: XOR<SafetyRuleCreateInput, SafetyRuleUncheckedCreateInput>
    /**
     * In case the SafetyRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SafetyRuleUpdateInput, SafetyRuleUncheckedUpdateInput>
  }

  /**
   * SafetyRule delete
   */
  export type SafetyRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyRule
     */
    select?: SafetyRuleSelect<ExtArgs> | null
    /**
     * Filter which SafetyRule to delete.
     */
    where: SafetyRuleWhereUniqueInput
  }

  /**
   * SafetyRule deleteMany
   */
  export type SafetyRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SafetyRules to delete
     */
    where?: SafetyRuleWhereInput
  }

  /**
   * SafetyRule without action
   */
  export type SafetyRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SafetyRule
     */
    select?: SafetyRuleSelect<ExtArgs> | null
  }


  /**
   * Model SystemMetrics
   */

  export type AggregateSystemMetrics = {
    _count: SystemMetricsCountAggregateOutputType | null
    _min: SystemMetricsMinAggregateOutputType | null
    _max: SystemMetricsMaxAggregateOutputType | null
  }

  export type SystemMetricsMinAggregateOutputType = {
    id: string | null
    type: string | null
    data: string | null
    timestamp: Date | null
  }

  export type SystemMetricsMaxAggregateOutputType = {
    id: string | null
    type: string | null
    data: string | null
    timestamp: Date | null
  }

  export type SystemMetricsCountAggregateOutputType = {
    id: number
    type: number
    data: number
    timestamp: number
    _all: number
  }


  export type SystemMetricsMinAggregateInputType = {
    id?: true
    type?: true
    data?: true
    timestamp?: true
  }

  export type SystemMetricsMaxAggregateInputType = {
    id?: true
    type?: true
    data?: true
    timestamp?: true
  }

  export type SystemMetricsCountAggregateInputType = {
    id?: true
    type?: true
    data?: true
    timestamp?: true
    _all?: true
  }

  export type SystemMetricsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemMetrics to aggregate.
     */
    where?: SystemMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemMetrics to fetch.
     */
    orderBy?: SystemMetricsOrderByWithRelationInput | SystemMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemMetrics
    **/
    _count?: true | SystemMetricsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemMetricsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemMetricsMaxAggregateInputType
  }

  export type GetSystemMetricsAggregateType<T extends SystemMetricsAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemMetrics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemMetrics[P]>
      : GetScalarType<T[P], AggregateSystemMetrics[P]>
  }




  export type SystemMetricsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemMetricsWhereInput
    orderBy?: SystemMetricsOrderByWithAggregationInput | SystemMetricsOrderByWithAggregationInput[]
    by: SystemMetricsScalarFieldEnum[] | SystemMetricsScalarFieldEnum
    having?: SystemMetricsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemMetricsCountAggregateInputType | true
    _min?: SystemMetricsMinAggregateInputType
    _max?: SystemMetricsMaxAggregateInputType
  }

  export type SystemMetricsGroupByOutputType = {
    id: string
    type: string
    data: string
    timestamp: Date
    _count: SystemMetricsCountAggregateOutputType | null
    _min: SystemMetricsMinAggregateOutputType | null
    _max: SystemMetricsMaxAggregateOutputType | null
  }

  type GetSystemMetricsGroupByPayload<T extends SystemMetricsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemMetricsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemMetricsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemMetricsGroupByOutputType[P]>
            : GetScalarType<T[P], SystemMetricsGroupByOutputType[P]>
        }
      >
    >


  export type SystemMetricsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    data?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["systemMetrics"]>

  export type SystemMetricsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    data?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["systemMetrics"]>

  export type SystemMetricsSelectScalar = {
    id?: boolean
    type?: boolean
    data?: boolean
    timestamp?: boolean
  }


  export type $SystemMetricsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemMetrics"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      data: string
      timestamp: Date
    }, ExtArgs["result"]["systemMetrics"]>
    composites: {}
  }

  type SystemMetricsGetPayload<S extends boolean | null | undefined | SystemMetricsDefaultArgs> = $Result.GetResult<Prisma.$SystemMetricsPayload, S>

  type SystemMetricsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemMetricsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemMetricsCountAggregateInputType | true
    }

  export interface SystemMetricsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemMetrics'], meta: { name: 'SystemMetrics' } }
    /**
     * Find zero or one SystemMetrics that matches the filter.
     * @param {SystemMetricsFindUniqueArgs} args - Arguments to find a SystemMetrics
     * @example
     * // Get one SystemMetrics
     * const systemMetrics = await prisma.systemMetrics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemMetricsFindUniqueArgs>(args: SelectSubset<T, SystemMetricsFindUniqueArgs<ExtArgs>>): Prisma__SystemMetricsClient<$Result.GetResult<Prisma.$SystemMetricsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemMetrics that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemMetricsFindUniqueOrThrowArgs} args - Arguments to find a SystemMetrics
     * @example
     * // Get one SystemMetrics
     * const systemMetrics = await prisma.systemMetrics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemMetricsFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemMetricsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemMetricsClient<$Result.GetResult<Prisma.$SystemMetricsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMetricsFindFirstArgs} args - Arguments to find a SystemMetrics
     * @example
     * // Get one SystemMetrics
     * const systemMetrics = await prisma.systemMetrics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemMetricsFindFirstArgs>(args?: SelectSubset<T, SystemMetricsFindFirstArgs<ExtArgs>>): Prisma__SystemMetricsClient<$Result.GetResult<Prisma.$SystemMetricsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemMetrics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMetricsFindFirstOrThrowArgs} args - Arguments to find a SystemMetrics
     * @example
     * // Get one SystemMetrics
     * const systemMetrics = await prisma.systemMetrics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemMetricsFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemMetricsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemMetricsClient<$Result.GetResult<Prisma.$SystemMetricsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMetricsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemMetrics
     * const systemMetrics = await prisma.systemMetrics.findMany()
     * 
     * // Get first 10 SystemMetrics
     * const systemMetrics = await prisma.systemMetrics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemMetricsWithIdOnly = await prisma.systemMetrics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemMetricsFindManyArgs>(args?: SelectSubset<T, SystemMetricsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemMetricsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemMetrics.
     * @param {SystemMetricsCreateArgs} args - Arguments to create a SystemMetrics.
     * @example
     * // Create one SystemMetrics
     * const SystemMetrics = await prisma.systemMetrics.create({
     *   data: {
     *     // ... data to create a SystemMetrics
     *   }
     * })
     * 
     */
    create<T extends SystemMetricsCreateArgs>(args: SelectSubset<T, SystemMetricsCreateArgs<ExtArgs>>): Prisma__SystemMetricsClient<$Result.GetResult<Prisma.$SystemMetricsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemMetrics.
     * @param {SystemMetricsCreateManyArgs} args - Arguments to create many SystemMetrics.
     * @example
     * // Create many SystemMetrics
     * const systemMetrics = await prisma.systemMetrics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemMetricsCreateManyArgs>(args?: SelectSubset<T, SystemMetricsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemMetrics and returns the data saved in the database.
     * @param {SystemMetricsCreateManyAndReturnArgs} args - Arguments to create many SystemMetrics.
     * @example
     * // Create many SystemMetrics
     * const systemMetrics = await prisma.systemMetrics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemMetrics and only return the `id`
     * const systemMetricsWithIdOnly = await prisma.systemMetrics.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemMetricsCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemMetricsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemMetricsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SystemMetrics.
     * @param {SystemMetricsDeleteArgs} args - Arguments to delete one SystemMetrics.
     * @example
     * // Delete one SystemMetrics
     * const SystemMetrics = await prisma.systemMetrics.delete({
     *   where: {
     *     // ... filter to delete one SystemMetrics
     *   }
     * })
     * 
     */
    delete<T extends SystemMetricsDeleteArgs>(args: SelectSubset<T, SystemMetricsDeleteArgs<ExtArgs>>): Prisma__SystemMetricsClient<$Result.GetResult<Prisma.$SystemMetricsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemMetrics.
     * @param {SystemMetricsUpdateArgs} args - Arguments to update one SystemMetrics.
     * @example
     * // Update one SystemMetrics
     * const systemMetrics = await prisma.systemMetrics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemMetricsUpdateArgs>(args: SelectSubset<T, SystemMetricsUpdateArgs<ExtArgs>>): Prisma__SystemMetricsClient<$Result.GetResult<Prisma.$SystemMetricsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemMetrics.
     * @param {SystemMetricsDeleteManyArgs} args - Arguments to filter SystemMetrics to delete.
     * @example
     * // Delete a few SystemMetrics
     * const { count } = await prisma.systemMetrics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemMetricsDeleteManyArgs>(args?: SelectSubset<T, SystemMetricsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMetricsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemMetrics
     * const systemMetrics = await prisma.systemMetrics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemMetricsUpdateManyArgs>(args: SelectSubset<T, SystemMetricsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemMetrics.
     * @param {SystemMetricsUpsertArgs} args - Arguments to update or create a SystemMetrics.
     * @example
     * // Update or create a SystemMetrics
     * const systemMetrics = await prisma.systemMetrics.upsert({
     *   create: {
     *     // ... data to create a SystemMetrics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemMetrics we want to update
     *   }
     * })
     */
    upsert<T extends SystemMetricsUpsertArgs>(args: SelectSubset<T, SystemMetricsUpsertArgs<ExtArgs>>): Prisma__SystemMetricsClient<$Result.GetResult<Prisma.$SystemMetricsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SystemMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMetricsCountArgs} args - Arguments to filter SystemMetrics to count.
     * @example
     * // Count the number of SystemMetrics
     * const count = await prisma.systemMetrics.count({
     *   where: {
     *     // ... the filter for the SystemMetrics we want to count
     *   }
     * })
    **/
    count<T extends SystemMetricsCountArgs>(
      args?: Subset<T, SystemMetricsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemMetricsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMetricsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemMetricsAggregateArgs>(args: Subset<T, SystemMetricsAggregateArgs>): Prisma.PrismaPromise<GetSystemMetricsAggregateType<T>>

    /**
     * Group by SystemMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemMetricsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemMetricsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemMetricsGroupByArgs['orderBy'] }
        : { orderBy?: SystemMetricsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemMetricsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemMetricsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemMetrics model
   */
  readonly fields: SystemMetricsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemMetrics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemMetricsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemMetrics model
   */ 
  interface SystemMetricsFieldRefs {
    readonly id: FieldRef<"SystemMetrics", 'String'>
    readonly type: FieldRef<"SystemMetrics", 'String'>
    readonly data: FieldRef<"SystemMetrics", 'String'>
    readonly timestamp: FieldRef<"SystemMetrics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemMetrics findUnique
   */
  export type SystemMetricsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetrics
     */
    select?: SystemMetricsSelect<ExtArgs> | null
    /**
     * Filter, which SystemMetrics to fetch.
     */
    where: SystemMetricsWhereUniqueInput
  }

  /**
   * SystemMetrics findUniqueOrThrow
   */
  export type SystemMetricsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetrics
     */
    select?: SystemMetricsSelect<ExtArgs> | null
    /**
     * Filter, which SystemMetrics to fetch.
     */
    where: SystemMetricsWhereUniqueInput
  }

  /**
   * SystemMetrics findFirst
   */
  export type SystemMetricsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetrics
     */
    select?: SystemMetricsSelect<ExtArgs> | null
    /**
     * Filter, which SystemMetrics to fetch.
     */
    where?: SystemMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemMetrics to fetch.
     */
    orderBy?: SystemMetricsOrderByWithRelationInput | SystemMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemMetrics.
     */
    cursor?: SystemMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemMetrics.
     */
    distinct?: SystemMetricsScalarFieldEnum | SystemMetricsScalarFieldEnum[]
  }

  /**
   * SystemMetrics findFirstOrThrow
   */
  export type SystemMetricsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetrics
     */
    select?: SystemMetricsSelect<ExtArgs> | null
    /**
     * Filter, which SystemMetrics to fetch.
     */
    where?: SystemMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemMetrics to fetch.
     */
    orderBy?: SystemMetricsOrderByWithRelationInput | SystemMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemMetrics.
     */
    cursor?: SystemMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemMetrics.
     */
    distinct?: SystemMetricsScalarFieldEnum | SystemMetricsScalarFieldEnum[]
  }

  /**
   * SystemMetrics findMany
   */
  export type SystemMetricsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetrics
     */
    select?: SystemMetricsSelect<ExtArgs> | null
    /**
     * Filter, which SystemMetrics to fetch.
     */
    where?: SystemMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemMetrics to fetch.
     */
    orderBy?: SystemMetricsOrderByWithRelationInput | SystemMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemMetrics.
     */
    cursor?: SystemMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemMetrics.
     */
    skip?: number
    distinct?: SystemMetricsScalarFieldEnum | SystemMetricsScalarFieldEnum[]
  }

  /**
   * SystemMetrics create
   */
  export type SystemMetricsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetrics
     */
    select?: SystemMetricsSelect<ExtArgs> | null
    /**
     * The data needed to create a SystemMetrics.
     */
    data: XOR<SystemMetricsCreateInput, SystemMetricsUncheckedCreateInput>
  }

  /**
   * SystemMetrics createMany
   */
  export type SystemMetricsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemMetrics.
     */
    data: SystemMetricsCreateManyInput | SystemMetricsCreateManyInput[]
  }

  /**
   * SystemMetrics createManyAndReturn
   */
  export type SystemMetricsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetrics
     */
    select?: SystemMetricsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SystemMetrics.
     */
    data: SystemMetricsCreateManyInput | SystemMetricsCreateManyInput[]
  }

  /**
   * SystemMetrics update
   */
  export type SystemMetricsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetrics
     */
    select?: SystemMetricsSelect<ExtArgs> | null
    /**
     * The data needed to update a SystemMetrics.
     */
    data: XOR<SystemMetricsUpdateInput, SystemMetricsUncheckedUpdateInput>
    /**
     * Choose, which SystemMetrics to update.
     */
    where: SystemMetricsWhereUniqueInput
  }

  /**
   * SystemMetrics updateMany
   */
  export type SystemMetricsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemMetrics.
     */
    data: XOR<SystemMetricsUpdateManyMutationInput, SystemMetricsUncheckedUpdateManyInput>
    /**
     * Filter which SystemMetrics to update
     */
    where?: SystemMetricsWhereInput
  }

  /**
   * SystemMetrics upsert
   */
  export type SystemMetricsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetrics
     */
    select?: SystemMetricsSelect<ExtArgs> | null
    /**
     * The filter to search for the SystemMetrics to update in case it exists.
     */
    where: SystemMetricsWhereUniqueInput
    /**
     * In case the SystemMetrics found by the `where` argument doesn't exist, create a new SystemMetrics with this data.
     */
    create: XOR<SystemMetricsCreateInput, SystemMetricsUncheckedCreateInput>
    /**
     * In case the SystemMetrics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemMetricsUpdateInput, SystemMetricsUncheckedUpdateInput>
  }

  /**
   * SystemMetrics delete
   */
  export type SystemMetricsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetrics
     */
    select?: SystemMetricsSelect<ExtArgs> | null
    /**
     * Filter which SystemMetrics to delete.
     */
    where: SystemMetricsWhereUniqueInput
  }

  /**
   * SystemMetrics deleteMany
   */
  export type SystemMetricsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemMetrics to delete
     */
    where?: SystemMetricsWhereInput
  }

  /**
   * SystemMetrics without action
   */
  export type SystemMetricsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemMetrics
     */
    select?: SystemMetricsSelect<ExtArgs> | null
  }


  /**
   * Model EquipmentRuntime
   */

  export type AggregateEquipmentRuntime = {
    _count: EquipmentRuntimeCountAggregateOutputType | null
    _avg: EquipmentRuntimeAvgAggregateOutputType | null
    _sum: EquipmentRuntimeSumAggregateOutputType | null
    _min: EquipmentRuntimeMinAggregateOutputType | null
    _max: EquipmentRuntimeMaxAggregateOutputType | null
  }

  export type EquipmentRuntimeAvgAggregateOutputType = {
    runtime: number | null
  }

  export type EquipmentRuntimeSumAggregateOutputType = {
    runtime: number | null
  }

  export type EquipmentRuntimeMinAggregateOutputType = {
    id: string | null
    equipmentName: string | null
    runtime: number | null
    date: Date | null
    createdAt: Date | null
  }

  export type EquipmentRuntimeMaxAggregateOutputType = {
    id: string | null
    equipmentName: string | null
    runtime: number | null
    date: Date | null
    createdAt: Date | null
  }

  export type EquipmentRuntimeCountAggregateOutputType = {
    id: number
    equipmentName: number
    runtime: number
    date: number
    createdAt: number
    _all: number
  }


  export type EquipmentRuntimeAvgAggregateInputType = {
    runtime?: true
  }

  export type EquipmentRuntimeSumAggregateInputType = {
    runtime?: true
  }

  export type EquipmentRuntimeMinAggregateInputType = {
    id?: true
    equipmentName?: true
    runtime?: true
    date?: true
    createdAt?: true
  }

  export type EquipmentRuntimeMaxAggregateInputType = {
    id?: true
    equipmentName?: true
    runtime?: true
    date?: true
    createdAt?: true
  }

  export type EquipmentRuntimeCountAggregateInputType = {
    id?: true
    equipmentName?: true
    runtime?: true
    date?: true
    createdAt?: true
    _all?: true
  }

  export type EquipmentRuntimeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentRuntime to aggregate.
     */
    where?: EquipmentRuntimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentRuntimes to fetch.
     */
    orderBy?: EquipmentRuntimeOrderByWithRelationInput | EquipmentRuntimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipmentRuntimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentRuntimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentRuntimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EquipmentRuntimes
    **/
    _count?: true | EquipmentRuntimeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipmentRuntimeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipmentRuntimeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentRuntimeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentRuntimeMaxAggregateInputType
  }

  export type GetEquipmentRuntimeAggregateType<T extends EquipmentRuntimeAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipmentRuntime]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipmentRuntime[P]>
      : GetScalarType<T[P], AggregateEquipmentRuntime[P]>
  }




  export type EquipmentRuntimeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentRuntimeWhereInput
    orderBy?: EquipmentRuntimeOrderByWithAggregationInput | EquipmentRuntimeOrderByWithAggregationInput[]
    by: EquipmentRuntimeScalarFieldEnum[] | EquipmentRuntimeScalarFieldEnum
    having?: EquipmentRuntimeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentRuntimeCountAggregateInputType | true
    _avg?: EquipmentRuntimeAvgAggregateInputType
    _sum?: EquipmentRuntimeSumAggregateInputType
    _min?: EquipmentRuntimeMinAggregateInputType
    _max?: EquipmentRuntimeMaxAggregateInputType
  }

  export type EquipmentRuntimeGroupByOutputType = {
    id: string
    equipmentName: string
    runtime: number
    date: Date
    createdAt: Date
    _count: EquipmentRuntimeCountAggregateOutputType | null
    _avg: EquipmentRuntimeAvgAggregateOutputType | null
    _sum: EquipmentRuntimeSumAggregateOutputType | null
    _min: EquipmentRuntimeMinAggregateOutputType | null
    _max: EquipmentRuntimeMaxAggregateOutputType | null
  }

  type GetEquipmentRuntimeGroupByPayload<T extends EquipmentRuntimeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipmentRuntimeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentRuntimeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentRuntimeGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentRuntimeGroupByOutputType[P]>
        }
      >
    >


  export type EquipmentRuntimeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipmentName?: boolean
    runtime?: boolean
    date?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["equipmentRuntime"]>

  export type EquipmentRuntimeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipmentName?: boolean
    runtime?: boolean
    date?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["equipmentRuntime"]>

  export type EquipmentRuntimeSelectScalar = {
    id?: boolean
    equipmentName?: boolean
    runtime?: boolean
    date?: boolean
    createdAt?: boolean
  }


  export type $EquipmentRuntimePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EquipmentRuntime"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      equipmentName: string
      runtime: number
      date: Date
      createdAt: Date
    }, ExtArgs["result"]["equipmentRuntime"]>
    composites: {}
  }

  type EquipmentRuntimeGetPayload<S extends boolean | null | undefined | EquipmentRuntimeDefaultArgs> = $Result.GetResult<Prisma.$EquipmentRuntimePayload, S>

  type EquipmentRuntimeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EquipmentRuntimeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EquipmentRuntimeCountAggregateInputType | true
    }

  export interface EquipmentRuntimeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EquipmentRuntime'], meta: { name: 'EquipmentRuntime' } }
    /**
     * Find zero or one EquipmentRuntime that matches the filter.
     * @param {EquipmentRuntimeFindUniqueArgs} args - Arguments to find a EquipmentRuntime
     * @example
     * // Get one EquipmentRuntime
     * const equipmentRuntime = await prisma.equipmentRuntime.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipmentRuntimeFindUniqueArgs>(args: SelectSubset<T, EquipmentRuntimeFindUniqueArgs<ExtArgs>>): Prisma__EquipmentRuntimeClient<$Result.GetResult<Prisma.$EquipmentRuntimePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EquipmentRuntime that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EquipmentRuntimeFindUniqueOrThrowArgs} args - Arguments to find a EquipmentRuntime
     * @example
     * // Get one EquipmentRuntime
     * const equipmentRuntime = await prisma.equipmentRuntime.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipmentRuntimeFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipmentRuntimeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipmentRuntimeClient<$Result.GetResult<Prisma.$EquipmentRuntimePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EquipmentRuntime that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentRuntimeFindFirstArgs} args - Arguments to find a EquipmentRuntime
     * @example
     * // Get one EquipmentRuntime
     * const equipmentRuntime = await prisma.equipmentRuntime.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipmentRuntimeFindFirstArgs>(args?: SelectSubset<T, EquipmentRuntimeFindFirstArgs<ExtArgs>>): Prisma__EquipmentRuntimeClient<$Result.GetResult<Prisma.$EquipmentRuntimePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EquipmentRuntime that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentRuntimeFindFirstOrThrowArgs} args - Arguments to find a EquipmentRuntime
     * @example
     * // Get one EquipmentRuntime
     * const equipmentRuntime = await prisma.equipmentRuntime.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipmentRuntimeFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipmentRuntimeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipmentRuntimeClient<$Result.GetResult<Prisma.$EquipmentRuntimePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EquipmentRuntimes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentRuntimeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EquipmentRuntimes
     * const equipmentRuntimes = await prisma.equipmentRuntime.findMany()
     * 
     * // Get first 10 EquipmentRuntimes
     * const equipmentRuntimes = await prisma.equipmentRuntime.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentRuntimeWithIdOnly = await prisma.equipmentRuntime.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EquipmentRuntimeFindManyArgs>(args?: SelectSubset<T, EquipmentRuntimeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentRuntimePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EquipmentRuntime.
     * @param {EquipmentRuntimeCreateArgs} args - Arguments to create a EquipmentRuntime.
     * @example
     * // Create one EquipmentRuntime
     * const EquipmentRuntime = await prisma.equipmentRuntime.create({
     *   data: {
     *     // ... data to create a EquipmentRuntime
     *   }
     * })
     * 
     */
    create<T extends EquipmentRuntimeCreateArgs>(args: SelectSubset<T, EquipmentRuntimeCreateArgs<ExtArgs>>): Prisma__EquipmentRuntimeClient<$Result.GetResult<Prisma.$EquipmentRuntimePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EquipmentRuntimes.
     * @param {EquipmentRuntimeCreateManyArgs} args - Arguments to create many EquipmentRuntimes.
     * @example
     * // Create many EquipmentRuntimes
     * const equipmentRuntime = await prisma.equipmentRuntime.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipmentRuntimeCreateManyArgs>(args?: SelectSubset<T, EquipmentRuntimeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EquipmentRuntimes and returns the data saved in the database.
     * @param {EquipmentRuntimeCreateManyAndReturnArgs} args - Arguments to create many EquipmentRuntimes.
     * @example
     * // Create many EquipmentRuntimes
     * const equipmentRuntime = await prisma.equipmentRuntime.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EquipmentRuntimes and only return the `id`
     * const equipmentRuntimeWithIdOnly = await prisma.equipmentRuntime.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EquipmentRuntimeCreateManyAndReturnArgs>(args?: SelectSubset<T, EquipmentRuntimeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentRuntimePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EquipmentRuntime.
     * @param {EquipmentRuntimeDeleteArgs} args - Arguments to delete one EquipmentRuntime.
     * @example
     * // Delete one EquipmentRuntime
     * const EquipmentRuntime = await prisma.equipmentRuntime.delete({
     *   where: {
     *     // ... filter to delete one EquipmentRuntime
     *   }
     * })
     * 
     */
    delete<T extends EquipmentRuntimeDeleteArgs>(args: SelectSubset<T, EquipmentRuntimeDeleteArgs<ExtArgs>>): Prisma__EquipmentRuntimeClient<$Result.GetResult<Prisma.$EquipmentRuntimePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EquipmentRuntime.
     * @param {EquipmentRuntimeUpdateArgs} args - Arguments to update one EquipmentRuntime.
     * @example
     * // Update one EquipmentRuntime
     * const equipmentRuntime = await prisma.equipmentRuntime.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipmentRuntimeUpdateArgs>(args: SelectSubset<T, EquipmentRuntimeUpdateArgs<ExtArgs>>): Prisma__EquipmentRuntimeClient<$Result.GetResult<Prisma.$EquipmentRuntimePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EquipmentRuntimes.
     * @param {EquipmentRuntimeDeleteManyArgs} args - Arguments to filter EquipmentRuntimes to delete.
     * @example
     * // Delete a few EquipmentRuntimes
     * const { count } = await prisma.equipmentRuntime.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipmentRuntimeDeleteManyArgs>(args?: SelectSubset<T, EquipmentRuntimeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipmentRuntimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentRuntimeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EquipmentRuntimes
     * const equipmentRuntime = await prisma.equipmentRuntime.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipmentRuntimeUpdateManyArgs>(args: SelectSubset<T, EquipmentRuntimeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EquipmentRuntime.
     * @param {EquipmentRuntimeUpsertArgs} args - Arguments to update or create a EquipmentRuntime.
     * @example
     * // Update or create a EquipmentRuntime
     * const equipmentRuntime = await prisma.equipmentRuntime.upsert({
     *   create: {
     *     // ... data to create a EquipmentRuntime
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EquipmentRuntime we want to update
     *   }
     * })
     */
    upsert<T extends EquipmentRuntimeUpsertArgs>(args: SelectSubset<T, EquipmentRuntimeUpsertArgs<ExtArgs>>): Prisma__EquipmentRuntimeClient<$Result.GetResult<Prisma.$EquipmentRuntimePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EquipmentRuntimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentRuntimeCountArgs} args - Arguments to filter EquipmentRuntimes to count.
     * @example
     * // Count the number of EquipmentRuntimes
     * const count = await prisma.equipmentRuntime.count({
     *   where: {
     *     // ... the filter for the EquipmentRuntimes we want to count
     *   }
     * })
    **/
    count<T extends EquipmentRuntimeCountArgs>(
      args?: Subset<T, EquipmentRuntimeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentRuntimeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EquipmentRuntime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentRuntimeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentRuntimeAggregateArgs>(args: Subset<T, EquipmentRuntimeAggregateArgs>): Prisma.PrismaPromise<GetEquipmentRuntimeAggregateType<T>>

    /**
     * Group by EquipmentRuntime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentRuntimeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipmentRuntimeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipmentRuntimeGroupByArgs['orderBy'] }
        : { orderBy?: EquipmentRuntimeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipmentRuntimeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentRuntimeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EquipmentRuntime model
   */
  readonly fields: EquipmentRuntimeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EquipmentRuntime.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipmentRuntimeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EquipmentRuntime model
   */ 
  interface EquipmentRuntimeFieldRefs {
    readonly id: FieldRef<"EquipmentRuntime", 'String'>
    readonly equipmentName: FieldRef<"EquipmentRuntime", 'String'>
    readonly runtime: FieldRef<"EquipmentRuntime", 'Float'>
    readonly date: FieldRef<"EquipmentRuntime", 'DateTime'>
    readonly createdAt: FieldRef<"EquipmentRuntime", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EquipmentRuntime findUnique
   */
  export type EquipmentRuntimeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentRuntime
     */
    select?: EquipmentRuntimeSelect<ExtArgs> | null
    /**
     * Filter, which EquipmentRuntime to fetch.
     */
    where: EquipmentRuntimeWhereUniqueInput
  }

  /**
   * EquipmentRuntime findUniqueOrThrow
   */
  export type EquipmentRuntimeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentRuntime
     */
    select?: EquipmentRuntimeSelect<ExtArgs> | null
    /**
     * Filter, which EquipmentRuntime to fetch.
     */
    where: EquipmentRuntimeWhereUniqueInput
  }

  /**
   * EquipmentRuntime findFirst
   */
  export type EquipmentRuntimeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentRuntime
     */
    select?: EquipmentRuntimeSelect<ExtArgs> | null
    /**
     * Filter, which EquipmentRuntime to fetch.
     */
    where?: EquipmentRuntimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentRuntimes to fetch.
     */
    orderBy?: EquipmentRuntimeOrderByWithRelationInput | EquipmentRuntimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentRuntimes.
     */
    cursor?: EquipmentRuntimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentRuntimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentRuntimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentRuntimes.
     */
    distinct?: EquipmentRuntimeScalarFieldEnum | EquipmentRuntimeScalarFieldEnum[]
  }

  /**
   * EquipmentRuntime findFirstOrThrow
   */
  export type EquipmentRuntimeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentRuntime
     */
    select?: EquipmentRuntimeSelect<ExtArgs> | null
    /**
     * Filter, which EquipmentRuntime to fetch.
     */
    where?: EquipmentRuntimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentRuntimes to fetch.
     */
    orderBy?: EquipmentRuntimeOrderByWithRelationInput | EquipmentRuntimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentRuntimes.
     */
    cursor?: EquipmentRuntimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentRuntimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentRuntimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentRuntimes.
     */
    distinct?: EquipmentRuntimeScalarFieldEnum | EquipmentRuntimeScalarFieldEnum[]
  }

  /**
   * EquipmentRuntime findMany
   */
  export type EquipmentRuntimeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentRuntime
     */
    select?: EquipmentRuntimeSelect<ExtArgs> | null
    /**
     * Filter, which EquipmentRuntimes to fetch.
     */
    where?: EquipmentRuntimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentRuntimes to fetch.
     */
    orderBy?: EquipmentRuntimeOrderByWithRelationInput | EquipmentRuntimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EquipmentRuntimes.
     */
    cursor?: EquipmentRuntimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentRuntimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentRuntimes.
     */
    skip?: number
    distinct?: EquipmentRuntimeScalarFieldEnum | EquipmentRuntimeScalarFieldEnum[]
  }

  /**
   * EquipmentRuntime create
   */
  export type EquipmentRuntimeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentRuntime
     */
    select?: EquipmentRuntimeSelect<ExtArgs> | null
    /**
     * The data needed to create a EquipmentRuntime.
     */
    data: XOR<EquipmentRuntimeCreateInput, EquipmentRuntimeUncheckedCreateInput>
  }

  /**
   * EquipmentRuntime createMany
   */
  export type EquipmentRuntimeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EquipmentRuntimes.
     */
    data: EquipmentRuntimeCreateManyInput | EquipmentRuntimeCreateManyInput[]
  }

  /**
   * EquipmentRuntime createManyAndReturn
   */
  export type EquipmentRuntimeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentRuntime
     */
    select?: EquipmentRuntimeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EquipmentRuntimes.
     */
    data: EquipmentRuntimeCreateManyInput | EquipmentRuntimeCreateManyInput[]
  }

  /**
   * EquipmentRuntime update
   */
  export type EquipmentRuntimeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentRuntime
     */
    select?: EquipmentRuntimeSelect<ExtArgs> | null
    /**
     * The data needed to update a EquipmentRuntime.
     */
    data: XOR<EquipmentRuntimeUpdateInput, EquipmentRuntimeUncheckedUpdateInput>
    /**
     * Choose, which EquipmentRuntime to update.
     */
    where: EquipmentRuntimeWhereUniqueInput
  }

  /**
   * EquipmentRuntime updateMany
   */
  export type EquipmentRuntimeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EquipmentRuntimes.
     */
    data: XOR<EquipmentRuntimeUpdateManyMutationInput, EquipmentRuntimeUncheckedUpdateManyInput>
    /**
     * Filter which EquipmentRuntimes to update
     */
    where?: EquipmentRuntimeWhereInput
  }

  /**
   * EquipmentRuntime upsert
   */
  export type EquipmentRuntimeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentRuntime
     */
    select?: EquipmentRuntimeSelect<ExtArgs> | null
    /**
     * The filter to search for the EquipmentRuntime to update in case it exists.
     */
    where: EquipmentRuntimeWhereUniqueInput
    /**
     * In case the EquipmentRuntime found by the `where` argument doesn't exist, create a new EquipmentRuntime with this data.
     */
    create: XOR<EquipmentRuntimeCreateInput, EquipmentRuntimeUncheckedCreateInput>
    /**
     * In case the EquipmentRuntime was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipmentRuntimeUpdateInput, EquipmentRuntimeUncheckedUpdateInput>
  }

  /**
   * EquipmentRuntime delete
   */
  export type EquipmentRuntimeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentRuntime
     */
    select?: EquipmentRuntimeSelect<ExtArgs> | null
    /**
     * Filter which EquipmentRuntime to delete.
     */
    where: EquipmentRuntimeWhereUniqueInput
  }

  /**
   * EquipmentRuntime deleteMany
   */
  export type EquipmentRuntimeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentRuntimes to delete
     */
    where?: EquipmentRuntimeWhereInput
  }

  /**
   * EquipmentRuntime without action
   */
  export type EquipmentRuntimeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentRuntime
     */
    select?: EquipmentRuntimeSelect<ExtArgs> | null
  }


  /**
   * Model SystemStatus
   */

  export type AggregateSystemStatus = {
    _count: SystemStatusCountAggregateOutputType | null
    _avg: SystemStatusAvgAggregateOutputType | null
    _sum: SystemStatusSumAggregateOutputType | null
    _min: SystemStatusMinAggregateOutputType | null
    _max: SystemStatusMaxAggregateOutputType | null
  }

  export type SystemStatusAvgAggregateOutputType = {
    id: number | null
    cpuUsage: number | null
    memoryUsage: number | null
    diskUsage: number | null
    temperature: number | null
    uptime: number | null
  }

  export type SystemStatusSumAggregateOutputType = {
    id: number | null
    cpuUsage: number | null
    memoryUsage: number | null
    diskUsage: number | null
    temperature: number | null
    uptime: number | null
  }

  export type SystemStatusMinAggregateOutputType = {
    id: number | null
    cpuUsage: number | null
    memoryUsage: number | null
    diskUsage: number | null
    temperature: number | null
    uptime: number | null
    timestamp: Date | null
  }

  export type SystemStatusMaxAggregateOutputType = {
    id: number | null
    cpuUsage: number | null
    memoryUsage: number | null
    diskUsage: number | null
    temperature: number | null
    uptime: number | null
    timestamp: Date | null
  }

  export type SystemStatusCountAggregateOutputType = {
    id: number
    cpuUsage: number
    memoryUsage: number
    diskUsage: number
    temperature: number
    uptime: number
    timestamp: number
    _all: number
  }


  export type SystemStatusAvgAggregateInputType = {
    id?: true
    cpuUsage?: true
    memoryUsage?: true
    diskUsage?: true
    temperature?: true
    uptime?: true
  }

  export type SystemStatusSumAggregateInputType = {
    id?: true
    cpuUsage?: true
    memoryUsage?: true
    diskUsage?: true
    temperature?: true
    uptime?: true
  }

  export type SystemStatusMinAggregateInputType = {
    id?: true
    cpuUsage?: true
    memoryUsage?: true
    diskUsage?: true
    temperature?: true
    uptime?: true
    timestamp?: true
  }

  export type SystemStatusMaxAggregateInputType = {
    id?: true
    cpuUsage?: true
    memoryUsage?: true
    diskUsage?: true
    temperature?: true
    uptime?: true
    timestamp?: true
  }

  export type SystemStatusCountAggregateInputType = {
    id?: true
    cpuUsage?: true
    memoryUsage?: true
    diskUsage?: true
    temperature?: true
    uptime?: true
    timestamp?: true
    _all?: true
  }

  export type SystemStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemStatus to aggregate.
     */
    where?: SystemStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemStatuses to fetch.
     */
    orderBy?: SystemStatusOrderByWithRelationInput | SystemStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemStatuses
    **/
    _count?: true | SystemStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemStatusMaxAggregateInputType
  }

  export type GetSystemStatusAggregateType<T extends SystemStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemStatus[P]>
      : GetScalarType<T[P], AggregateSystemStatus[P]>
  }




  export type SystemStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemStatusWhereInput
    orderBy?: SystemStatusOrderByWithAggregationInput | SystemStatusOrderByWithAggregationInput[]
    by: SystemStatusScalarFieldEnum[] | SystemStatusScalarFieldEnum
    having?: SystemStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemStatusCountAggregateInputType | true
    _avg?: SystemStatusAvgAggregateInputType
    _sum?: SystemStatusSumAggregateInputType
    _min?: SystemStatusMinAggregateInputType
    _max?: SystemStatusMaxAggregateInputType
  }

  export type SystemStatusGroupByOutputType = {
    id: number
    cpuUsage: number
    memoryUsage: number
    diskUsage: number
    temperature: number | null
    uptime: number
    timestamp: Date
    _count: SystemStatusCountAggregateOutputType | null
    _avg: SystemStatusAvgAggregateOutputType | null
    _sum: SystemStatusSumAggregateOutputType | null
    _min: SystemStatusMinAggregateOutputType | null
    _max: SystemStatusMaxAggregateOutputType | null
  }

  type GetSystemStatusGroupByPayload<T extends SystemStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemStatusGroupByOutputType[P]>
            : GetScalarType<T[P], SystemStatusGroupByOutputType[P]>
        }
      >
    >


  export type SystemStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cpuUsage?: boolean
    memoryUsage?: boolean
    diskUsage?: boolean
    temperature?: boolean
    uptime?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["systemStatus"]>

  export type SystemStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cpuUsage?: boolean
    memoryUsage?: boolean
    diskUsage?: boolean
    temperature?: boolean
    uptime?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["systemStatus"]>

  export type SystemStatusSelectScalar = {
    id?: boolean
    cpuUsage?: boolean
    memoryUsage?: boolean
    diskUsage?: boolean
    temperature?: boolean
    uptime?: boolean
    timestamp?: boolean
  }


  export type $SystemStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemStatus"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cpuUsage: number
      memoryUsage: number
      diskUsage: number
      temperature: number | null
      uptime: number
      timestamp: Date
    }, ExtArgs["result"]["systemStatus"]>
    composites: {}
  }

  type SystemStatusGetPayload<S extends boolean | null | undefined | SystemStatusDefaultArgs> = $Result.GetResult<Prisma.$SystemStatusPayload, S>

  type SystemStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemStatusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemStatusCountAggregateInputType | true
    }

  export interface SystemStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemStatus'], meta: { name: 'SystemStatus' } }
    /**
     * Find zero or one SystemStatus that matches the filter.
     * @param {SystemStatusFindUniqueArgs} args - Arguments to find a SystemStatus
     * @example
     * // Get one SystemStatus
     * const systemStatus = await prisma.systemStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemStatusFindUniqueArgs>(args: SelectSubset<T, SystemStatusFindUniqueArgs<ExtArgs>>): Prisma__SystemStatusClient<$Result.GetResult<Prisma.$SystemStatusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemStatus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemStatusFindUniqueOrThrowArgs} args - Arguments to find a SystemStatus
     * @example
     * // Get one SystemStatus
     * const systemStatus = await prisma.systemStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemStatusClient<$Result.GetResult<Prisma.$SystemStatusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemStatusFindFirstArgs} args - Arguments to find a SystemStatus
     * @example
     * // Get one SystemStatus
     * const systemStatus = await prisma.systemStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemStatusFindFirstArgs>(args?: SelectSubset<T, SystemStatusFindFirstArgs<ExtArgs>>): Prisma__SystemStatusClient<$Result.GetResult<Prisma.$SystemStatusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemStatusFindFirstOrThrowArgs} args - Arguments to find a SystemStatus
     * @example
     * // Get one SystemStatus
     * const systemStatus = await prisma.systemStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemStatusClient<$Result.GetResult<Prisma.$SystemStatusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemStatuses
     * const systemStatuses = await prisma.systemStatus.findMany()
     * 
     * // Get first 10 SystemStatuses
     * const systemStatuses = await prisma.systemStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemStatusWithIdOnly = await prisma.systemStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemStatusFindManyArgs>(args?: SelectSubset<T, SystemStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemStatusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemStatus.
     * @param {SystemStatusCreateArgs} args - Arguments to create a SystemStatus.
     * @example
     * // Create one SystemStatus
     * const SystemStatus = await prisma.systemStatus.create({
     *   data: {
     *     // ... data to create a SystemStatus
     *   }
     * })
     * 
     */
    create<T extends SystemStatusCreateArgs>(args: SelectSubset<T, SystemStatusCreateArgs<ExtArgs>>): Prisma__SystemStatusClient<$Result.GetResult<Prisma.$SystemStatusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemStatuses.
     * @param {SystemStatusCreateManyArgs} args - Arguments to create many SystemStatuses.
     * @example
     * // Create many SystemStatuses
     * const systemStatus = await prisma.systemStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemStatusCreateManyArgs>(args?: SelectSubset<T, SystemStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemStatuses and returns the data saved in the database.
     * @param {SystemStatusCreateManyAndReturnArgs} args - Arguments to create many SystemStatuses.
     * @example
     * // Create many SystemStatuses
     * const systemStatus = await prisma.systemStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemStatuses and only return the `id`
     * const systemStatusWithIdOnly = await prisma.systemStatus.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemStatusPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SystemStatus.
     * @param {SystemStatusDeleteArgs} args - Arguments to delete one SystemStatus.
     * @example
     * // Delete one SystemStatus
     * const SystemStatus = await prisma.systemStatus.delete({
     *   where: {
     *     // ... filter to delete one SystemStatus
     *   }
     * })
     * 
     */
    delete<T extends SystemStatusDeleteArgs>(args: SelectSubset<T, SystemStatusDeleteArgs<ExtArgs>>): Prisma__SystemStatusClient<$Result.GetResult<Prisma.$SystemStatusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemStatus.
     * @param {SystemStatusUpdateArgs} args - Arguments to update one SystemStatus.
     * @example
     * // Update one SystemStatus
     * const systemStatus = await prisma.systemStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemStatusUpdateArgs>(args: SelectSubset<T, SystemStatusUpdateArgs<ExtArgs>>): Prisma__SystemStatusClient<$Result.GetResult<Prisma.$SystemStatusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemStatuses.
     * @param {SystemStatusDeleteManyArgs} args - Arguments to filter SystemStatuses to delete.
     * @example
     * // Delete a few SystemStatuses
     * const { count } = await prisma.systemStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemStatusDeleteManyArgs>(args?: SelectSubset<T, SystemStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemStatuses
     * const systemStatus = await prisma.systemStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemStatusUpdateManyArgs>(args: SelectSubset<T, SystemStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemStatus.
     * @param {SystemStatusUpsertArgs} args - Arguments to update or create a SystemStatus.
     * @example
     * // Update or create a SystemStatus
     * const systemStatus = await prisma.systemStatus.upsert({
     *   create: {
     *     // ... data to create a SystemStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemStatus we want to update
     *   }
     * })
     */
    upsert<T extends SystemStatusUpsertArgs>(args: SelectSubset<T, SystemStatusUpsertArgs<ExtArgs>>): Prisma__SystemStatusClient<$Result.GetResult<Prisma.$SystemStatusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SystemStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemStatusCountArgs} args - Arguments to filter SystemStatuses to count.
     * @example
     * // Count the number of SystemStatuses
     * const count = await prisma.systemStatus.count({
     *   where: {
     *     // ... the filter for the SystemStatuses we want to count
     *   }
     * })
    **/
    count<T extends SystemStatusCountArgs>(
      args?: Subset<T, SystemStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemStatusAggregateArgs>(args: Subset<T, SystemStatusAggregateArgs>): Prisma.PrismaPromise<GetSystemStatusAggregateType<T>>

    /**
     * Group by SystemStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemStatusGroupByArgs['orderBy'] }
        : { orderBy?: SystemStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemStatus model
   */
  readonly fields: SystemStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemStatus model
   */ 
  interface SystemStatusFieldRefs {
    readonly id: FieldRef<"SystemStatus", 'Int'>
    readonly cpuUsage: FieldRef<"SystemStatus", 'Float'>
    readonly memoryUsage: FieldRef<"SystemStatus", 'Float'>
    readonly diskUsage: FieldRef<"SystemStatus", 'Float'>
    readonly temperature: FieldRef<"SystemStatus", 'Float'>
    readonly uptime: FieldRef<"SystemStatus", 'Int'>
    readonly timestamp: FieldRef<"SystemStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemStatus findUnique
   */
  export type SystemStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelect<ExtArgs> | null
    /**
     * Filter, which SystemStatus to fetch.
     */
    where: SystemStatusWhereUniqueInput
  }

  /**
   * SystemStatus findUniqueOrThrow
   */
  export type SystemStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelect<ExtArgs> | null
    /**
     * Filter, which SystemStatus to fetch.
     */
    where: SystemStatusWhereUniqueInput
  }

  /**
   * SystemStatus findFirst
   */
  export type SystemStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelect<ExtArgs> | null
    /**
     * Filter, which SystemStatus to fetch.
     */
    where?: SystemStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemStatuses to fetch.
     */
    orderBy?: SystemStatusOrderByWithRelationInput | SystemStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemStatuses.
     */
    cursor?: SystemStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemStatuses.
     */
    distinct?: SystemStatusScalarFieldEnum | SystemStatusScalarFieldEnum[]
  }

  /**
   * SystemStatus findFirstOrThrow
   */
  export type SystemStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelect<ExtArgs> | null
    /**
     * Filter, which SystemStatus to fetch.
     */
    where?: SystemStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemStatuses to fetch.
     */
    orderBy?: SystemStatusOrderByWithRelationInput | SystemStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemStatuses.
     */
    cursor?: SystemStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemStatuses.
     */
    distinct?: SystemStatusScalarFieldEnum | SystemStatusScalarFieldEnum[]
  }

  /**
   * SystemStatus findMany
   */
  export type SystemStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelect<ExtArgs> | null
    /**
     * Filter, which SystemStatuses to fetch.
     */
    where?: SystemStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemStatuses to fetch.
     */
    orderBy?: SystemStatusOrderByWithRelationInput | SystemStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemStatuses.
     */
    cursor?: SystemStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemStatuses.
     */
    skip?: number
    distinct?: SystemStatusScalarFieldEnum | SystemStatusScalarFieldEnum[]
  }

  /**
   * SystemStatus create
   */
  export type SystemStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelect<ExtArgs> | null
    /**
     * The data needed to create a SystemStatus.
     */
    data: XOR<SystemStatusCreateInput, SystemStatusUncheckedCreateInput>
  }

  /**
   * SystemStatus createMany
   */
  export type SystemStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemStatuses.
     */
    data: SystemStatusCreateManyInput | SystemStatusCreateManyInput[]
  }

  /**
   * SystemStatus createManyAndReturn
   */
  export type SystemStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SystemStatuses.
     */
    data: SystemStatusCreateManyInput | SystemStatusCreateManyInput[]
  }

  /**
   * SystemStatus update
   */
  export type SystemStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelect<ExtArgs> | null
    /**
     * The data needed to update a SystemStatus.
     */
    data: XOR<SystemStatusUpdateInput, SystemStatusUncheckedUpdateInput>
    /**
     * Choose, which SystemStatus to update.
     */
    where: SystemStatusWhereUniqueInput
  }

  /**
   * SystemStatus updateMany
   */
  export type SystemStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemStatuses.
     */
    data: XOR<SystemStatusUpdateManyMutationInput, SystemStatusUncheckedUpdateManyInput>
    /**
     * Filter which SystemStatuses to update
     */
    where?: SystemStatusWhereInput
  }

  /**
   * SystemStatus upsert
   */
  export type SystemStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelect<ExtArgs> | null
    /**
     * The filter to search for the SystemStatus to update in case it exists.
     */
    where: SystemStatusWhereUniqueInput
    /**
     * In case the SystemStatus found by the `where` argument doesn't exist, create a new SystemStatus with this data.
     */
    create: XOR<SystemStatusCreateInput, SystemStatusUncheckedCreateInput>
    /**
     * In case the SystemStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemStatusUpdateInput, SystemStatusUncheckedUpdateInput>
  }

  /**
   * SystemStatus delete
   */
  export type SystemStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelect<ExtArgs> | null
    /**
     * Filter which SystemStatus to delete.
     */
    where: SystemStatusWhereUniqueInput
  }

  /**
   * SystemStatus deleteMany
   */
  export type SystemStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemStatuses to delete
     */
    where?: SystemStatusWhereInput
  }

  /**
   * SystemStatus without action
   */
  export type SystemStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelect<ExtArgs> | null
  }


  /**
   * Model DeviceStats
   */

  export type AggregateDeviceStats = {
    _count: DeviceStatsCountAggregateOutputType | null
    _avg: DeviceStatsAvgAggregateOutputType | null
    _sum: DeviceStatsSumAggregateOutputType | null
    _min: DeviceStatsMinAggregateOutputType | null
    _max: DeviceStatsMaxAggregateOutputType | null
  }

  export type DeviceStatsAvgAggregateOutputType = {
    id: number | null
    connectTime: number | null
    disconnectTime: number | null
    errorCount: number | null
    dataPointCount: number | null
  }

  export type DeviceStatsSumAggregateOutputType = {
    id: number | null
    connectTime: number | null
    disconnectTime: number | null
    errorCount: number | null
    dataPointCount: number | null
  }

  export type DeviceStatsMinAggregateOutputType = {
    id: number | null
    deviceId: string | null
    connectTime: number | null
    disconnectTime: number | null
    errorCount: number | null
    dataPointCount: number | null
    lastUpdate: Date | null
    date: string | null
  }

  export type DeviceStatsMaxAggregateOutputType = {
    id: number | null
    deviceId: string | null
    connectTime: number | null
    disconnectTime: number | null
    errorCount: number | null
    dataPointCount: number | null
    lastUpdate: Date | null
    date: string | null
  }

  export type DeviceStatsCountAggregateOutputType = {
    id: number
    deviceId: number
    connectTime: number
    disconnectTime: number
    errorCount: number
    dataPointCount: number
    lastUpdate: number
    date: number
    _all: number
  }


  export type DeviceStatsAvgAggregateInputType = {
    id?: true
    connectTime?: true
    disconnectTime?: true
    errorCount?: true
    dataPointCount?: true
  }

  export type DeviceStatsSumAggregateInputType = {
    id?: true
    connectTime?: true
    disconnectTime?: true
    errorCount?: true
    dataPointCount?: true
  }

  export type DeviceStatsMinAggregateInputType = {
    id?: true
    deviceId?: true
    connectTime?: true
    disconnectTime?: true
    errorCount?: true
    dataPointCount?: true
    lastUpdate?: true
    date?: true
  }

  export type DeviceStatsMaxAggregateInputType = {
    id?: true
    deviceId?: true
    connectTime?: true
    disconnectTime?: true
    errorCount?: true
    dataPointCount?: true
    lastUpdate?: true
    date?: true
  }

  export type DeviceStatsCountAggregateInputType = {
    id?: true
    deviceId?: true
    connectTime?: true
    disconnectTime?: true
    errorCount?: true
    dataPointCount?: true
    lastUpdate?: true
    date?: true
    _all?: true
  }

  export type DeviceStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceStats to aggregate.
     */
    where?: DeviceStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceStats to fetch.
     */
    orderBy?: DeviceStatsOrderByWithRelationInput | DeviceStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceStats
    **/
    _count?: true | DeviceStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceStatsMaxAggregateInputType
  }

  export type GetDeviceStatsAggregateType<T extends DeviceStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceStats[P]>
      : GetScalarType<T[P], AggregateDeviceStats[P]>
  }




  export type DeviceStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceStatsWhereInput
    orderBy?: DeviceStatsOrderByWithAggregationInput | DeviceStatsOrderByWithAggregationInput[]
    by: DeviceStatsScalarFieldEnum[] | DeviceStatsScalarFieldEnum
    having?: DeviceStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceStatsCountAggregateInputType | true
    _avg?: DeviceStatsAvgAggregateInputType
    _sum?: DeviceStatsSumAggregateInputType
    _min?: DeviceStatsMinAggregateInputType
    _max?: DeviceStatsMaxAggregateInputType
  }

  export type DeviceStatsGroupByOutputType = {
    id: number
    deviceId: string
    connectTime: number
    disconnectTime: number
    errorCount: number
    dataPointCount: number
    lastUpdate: Date
    date: string
    _count: DeviceStatsCountAggregateOutputType | null
    _avg: DeviceStatsAvgAggregateOutputType | null
    _sum: DeviceStatsSumAggregateOutputType | null
    _min: DeviceStatsMinAggregateOutputType | null
    _max: DeviceStatsMaxAggregateOutputType | null
  }

  type GetDeviceStatsGroupByPayload<T extends DeviceStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceStatsGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceStatsGroupByOutputType[P]>
        }
      >
    >


  export type DeviceStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    connectTime?: boolean
    disconnectTime?: boolean
    errorCount?: boolean
    dataPointCount?: boolean
    lastUpdate?: boolean
    date?: boolean
  }, ExtArgs["result"]["deviceStats"]>

  export type DeviceStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    connectTime?: boolean
    disconnectTime?: boolean
    errorCount?: boolean
    dataPointCount?: boolean
    lastUpdate?: boolean
    date?: boolean
  }, ExtArgs["result"]["deviceStats"]>

  export type DeviceStatsSelectScalar = {
    id?: boolean
    deviceId?: boolean
    connectTime?: boolean
    disconnectTime?: boolean
    errorCount?: boolean
    dataPointCount?: boolean
    lastUpdate?: boolean
    date?: boolean
  }


  export type $DeviceStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceStats"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      deviceId: string
      connectTime: number
      disconnectTime: number
      errorCount: number
      dataPointCount: number
      lastUpdate: Date
      date: string
    }, ExtArgs["result"]["deviceStats"]>
    composites: {}
  }

  type DeviceStatsGetPayload<S extends boolean | null | undefined | DeviceStatsDefaultArgs> = $Result.GetResult<Prisma.$DeviceStatsPayload, S>

  type DeviceStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeviceStatsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeviceStatsCountAggregateInputType | true
    }

  export interface DeviceStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceStats'], meta: { name: 'DeviceStats' } }
    /**
     * Find zero or one DeviceStats that matches the filter.
     * @param {DeviceStatsFindUniqueArgs} args - Arguments to find a DeviceStats
     * @example
     * // Get one DeviceStats
     * const deviceStats = await prisma.deviceStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceStatsFindUniqueArgs>(args: SelectSubset<T, DeviceStatsFindUniqueArgs<ExtArgs>>): Prisma__DeviceStatsClient<$Result.GetResult<Prisma.$DeviceStatsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DeviceStats that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeviceStatsFindUniqueOrThrowArgs} args - Arguments to find a DeviceStats
     * @example
     * // Get one DeviceStats
     * const deviceStats = await prisma.deviceStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceStatsClient<$Result.GetResult<Prisma.$DeviceStatsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DeviceStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceStatsFindFirstArgs} args - Arguments to find a DeviceStats
     * @example
     * // Get one DeviceStats
     * const deviceStats = await prisma.deviceStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceStatsFindFirstArgs>(args?: SelectSubset<T, DeviceStatsFindFirstArgs<ExtArgs>>): Prisma__DeviceStatsClient<$Result.GetResult<Prisma.$DeviceStatsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DeviceStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceStatsFindFirstOrThrowArgs} args - Arguments to find a DeviceStats
     * @example
     * // Get one DeviceStats
     * const deviceStats = await prisma.deviceStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceStatsClient<$Result.GetResult<Prisma.$DeviceStatsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DeviceStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceStats
     * const deviceStats = await prisma.deviceStats.findMany()
     * 
     * // Get first 10 DeviceStats
     * const deviceStats = await prisma.deviceStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceStatsWithIdOnly = await prisma.deviceStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceStatsFindManyArgs>(args?: SelectSubset<T, DeviceStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceStatsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DeviceStats.
     * @param {DeviceStatsCreateArgs} args - Arguments to create a DeviceStats.
     * @example
     * // Create one DeviceStats
     * const DeviceStats = await prisma.deviceStats.create({
     *   data: {
     *     // ... data to create a DeviceStats
     *   }
     * })
     * 
     */
    create<T extends DeviceStatsCreateArgs>(args: SelectSubset<T, DeviceStatsCreateArgs<ExtArgs>>): Prisma__DeviceStatsClient<$Result.GetResult<Prisma.$DeviceStatsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DeviceStats.
     * @param {DeviceStatsCreateManyArgs} args - Arguments to create many DeviceStats.
     * @example
     * // Create many DeviceStats
     * const deviceStats = await prisma.deviceStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceStatsCreateManyArgs>(args?: SelectSubset<T, DeviceStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceStats and returns the data saved in the database.
     * @param {DeviceStatsCreateManyAndReturnArgs} args - Arguments to create many DeviceStats.
     * @example
     * // Create many DeviceStats
     * const deviceStats = await prisma.deviceStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceStats and only return the `id`
     * const deviceStatsWithIdOnly = await prisma.deviceStats.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceStatsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DeviceStats.
     * @param {DeviceStatsDeleteArgs} args - Arguments to delete one DeviceStats.
     * @example
     * // Delete one DeviceStats
     * const DeviceStats = await prisma.deviceStats.delete({
     *   where: {
     *     // ... filter to delete one DeviceStats
     *   }
     * })
     * 
     */
    delete<T extends DeviceStatsDeleteArgs>(args: SelectSubset<T, DeviceStatsDeleteArgs<ExtArgs>>): Prisma__DeviceStatsClient<$Result.GetResult<Prisma.$DeviceStatsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DeviceStats.
     * @param {DeviceStatsUpdateArgs} args - Arguments to update one DeviceStats.
     * @example
     * // Update one DeviceStats
     * const deviceStats = await prisma.deviceStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceStatsUpdateArgs>(args: SelectSubset<T, DeviceStatsUpdateArgs<ExtArgs>>): Prisma__DeviceStatsClient<$Result.GetResult<Prisma.$DeviceStatsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DeviceStats.
     * @param {DeviceStatsDeleteManyArgs} args - Arguments to filter DeviceStats to delete.
     * @example
     * // Delete a few DeviceStats
     * const { count } = await prisma.deviceStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceStatsDeleteManyArgs>(args?: SelectSubset<T, DeviceStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceStats
     * const deviceStats = await prisma.deviceStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceStatsUpdateManyArgs>(args: SelectSubset<T, DeviceStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeviceStats.
     * @param {DeviceStatsUpsertArgs} args - Arguments to update or create a DeviceStats.
     * @example
     * // Update or create a DeviceStats
     * const deviceStats = await prisma.deviceStats.upsert({
     *   create: {
     *     // ... data to create a DeviceStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceStats we want to update
     *   }
     * })
     */
    upsert<T extends DeviceStatsUpsertArgs>(args: SelectSubset<T, DeviceStatsUpsertArgs<ExtArgs>>): Prisma__DeviceStatsClient<$Result.GetResult<Prisma.$DeviceStatsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DeviceStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceStatsCountArgs} args - Arguments to filter DeviceStats to count.
     * @example
     * // Count the number of DeviceStats
     * const count = await prisma.deviceStats.count({
     *   where: {
     *     // ... the filter for the DeviceStats we want to count
     *   }
     * })
    **/
    count<T extends DeviceStatsCountArgs>(
      args?: Subset<T, DeviceStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceStatsAggregateArgs>(args: Subset<T, DeviceStatsAggregateArgs>): Prisma.PrismaPromise<GetDeviceStatsAggregateType<T>>

    /**
     * Group by DeviceStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceStatsGroupByArgs['orderBy'] }
        : { orderBy?: DeviceStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceStats model
   */
  readonly fields: DeviceStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceStats model
   */ 
  interface DeviceStatsFieldRefs {
    readonly id: FieldRef<"DeviceStats", 'Int'>
    readonly deviceId: FieldRef<"DeviceStats", 'String'>
    readonly connectTime: FieldRef<"DeviceStats", 'Int'>
    readonly disconnectTime: FieldRef<"DeviceStats", 'Int'>
    readonly errorCount: FieldRef<"DeviceStats", 'Int'>
    readonly dataPointCount: FieldRef<"DeviceStats", 'Int'>
    readonly lastUpdate: FieldRef<"DeviceStats", 'DateTime'>
    readonly date: FieldRef<"DeviceStats", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DeviceStats findUnique
   */
  export type DeviceStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStats
     */
    select?: DeviceStatsSelect<ExtArgs> | null
    /**
     * Filter, which DeviceStats to fetch.
     */
    where: DeviceStatsWhereUniqueInput
  }

  /**
   * DeviceStats findUniqueOrThrow
   */
  export type DeviceStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStats
     */
    select?: DeviceStatsSelect<ExtArgs> | null
    /**
     * Filter, which DeviceStats to fetch.
     */
    where: DeviceStatsWhereUniqueInput
  }

  /**
   * DeviceStats findFirst
   */
  export type DeviceStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStats
     */
    select?: DeviceStatsSelect<ExtArgs> | null
    /**
     * Filter, which DeviceStats to fetch.
     */
    where?: DeviceStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceStats to fetch.
     */
    orderBy?: DeviceStatsOrderByWithRelationInput | DeviceStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceStats.
     */
    cursor?: DeviceStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceStats.
     */
    distinct?: DeviceStatsScalarFieldEnum | DeviceStatsScalarFieldEnum[]
  }

  /**
   * DeviceStats findFirstOrThrow
   */
  export type DeviceStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStats
     */
    select?: DeviceStatsSelect<ExtArgs> | null
    /**
     * Filter, which DeviceStats to fetch.
     */
    where?: DeviceStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceStats to fetch.
     */
    orderBy?: DeviceStatsOrderByWithRelationInput | DeviceStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceStats.
     */
    cursor?: DeviceStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceStats.
     */
    distinct?: DeviceStatsScalarFieldEnum | DeviceStatsScalarFieldEnum[]
  }

  /**
   * DeviceStats findMany
   */
  export type DeviceStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStats
     */
    select?: DeviceStatsSelect<ExtArgs> | null
    /**
     * Filter, which DeviceStats to fetch.
     */
    where?: DeviceStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceStats to fetch.
     */
    orderBy?: DeviceStatsOrderByWithRelationInput | DeviceStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceStats.
     */
    cursor?: DeviceStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceStats.
     */
    skip?: number
    distinct?: DeviceStatsScalarFieldEnum | DeviceStatsScalarFieldEnum[]
  }

  /**
   * DeviceStats create
   */
  export type DeviceStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStats
     */
    select?: DeviceStatsSelect<ExtArgs> | null
    /**
     * The data needed to create a DeviceStats.
     */
    data: XOR<DeviceStatsCreateInput, DeviceStatsUncheckedCreateInput>
  }

  /**
   * DeviceStats createMany
   */
  export type DeviceStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceStats.
     */
    data: DeviceStatsCreateManyInput | DeviceStatsCreateManyInput[]
  }

  /**
   * DeviceStats createManyAndReturn
   */
  export type DeviceStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStats
     */
    select?: DeviceStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DeviceStats.
     */
    data: DeviceStatsCreateManyInput | DeviceStatsCreateManyInput[]
  }

  /**
   * DeviceStats update
   */
  export type DeviceStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStats
     */
    select?: DeviceStatsSelect<ExtArgs> | null
    /**
     * The data needed to update a DeviceStats.
     */
    data: XOR<DeviceStatsUpdateInput, DeviceStatsUncheckedUpdateInput>
    /**
     * Choose, which DeviceStats to update.
     */
    where: DeviceStatsWhereUniqueInput
  }

  /**
   * DeviceStats updateMany
   */
  export type DeviceStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceStats.
     */
    data: XOR<DeviceStatsUpdateManyMutationInput, DeviceStatsUncheckedUpdateManyInput>
    /**
     * Filter which DeviceStats to update
     */
    where?: DeviceStatsWhereInput
  }

  /**
   * DeviceStats upsert
   */
  export type DeviceStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStats
     */
    select?: DeviceStatsSelect<ExtArgs> | null
    /**
     * The filter to search for the DeviceStats to update in case it exists.
     */
    where: DeviceStatsWhereUniqueInput
    /**
     * In case the DeviceStats found by the `where` argument doesn't exist, create a new DeviceStats with this data.
     */
    create: XOR<DeviceStatsCreateInput, DeviceStatsUncheckedCreateInput>
    /**
     * In case the DeviceStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceStatsUpdateInput, DeviceStatsUncheckedUpdateInput>
  }

  /**
   * DeviceStats delete
   */
  export type DeviceStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStats
     */
    select?: DeviceStatsSelect<ExtArgs> | null
    /**
     * Filter which DeviceStats to delete.
     */
    where: DeviceStatsWhereUniqueInput
  }

  /**
   * DeviceStats deleteMany
   */
  export type DeviceStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceStats to delete
     */
    where?: DeviceStatsWhereInput
  }

  /**
   * DeviceStats without action
   */
  export type DeviceStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceStats
     */
    select?: DeviceStatsSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const EdgeConfigScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    description: 'description',
    updatedAt: 'updatedAt'
  };

  export type EdgeConfigScalarFieldEnum = (typeof EdgeConfigScalarFieldEnum)[keyof typeof EdgeConfigScalarFieldEnum]


  export const DeviceConnectionScalarFieldEnum: {
    id: 'id',
    deviceType: 'deviceType',
    deviceId: 'deviceId',
    host: 'host',
    port: 'port',
    status: 'status',
    lastConnect: 'lastConnect',
    errorMessage: 'errorMessage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeviceConnectionScalarFieldEnum = (typeof DeviceConnectionScalarFieldEnum)[keyof typeof DeviceConnectionScalarFieldEnum]


  export const DataPointScalarFieldEnum: {
    id: 'id',
    tagName: 'tagName',
    deviceId: 'deviceId',
    address: 'address',
    dataType: 'dataType',
    value: 'value',
    quality: 'quality',
    timestamp: 'timestamp',
    description: 'description'
  };

  export type DataPointScalarFieldEnum = (typeof DataPointScalarFieldEnum)[keyof typeof DataPointScalarFieldEnum]


  export const DataHistoryScalarFieldEnum: {
    id: 'id',
    pointId: 'pointId',
    value: 'value',
    quality: 'quality',
    timestamp: 'timestamp'
  };

  export type DataHistoryScalarFieldEnum = (typeof DataHistoryScalarFieldEnum)[keyof typeof DataHistoryScalarFieldEnum]


  export const LocalRecipeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    concreteGrade: 'concreteGrade',
    version: 'version',
    isActive: 'isActive',
    recipeData: 'recipeData',
    syncStatus: 'syncStatus',
    remoteId: 'remoteId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LocalRecipeScalarFieldEnum = (typeof LocalRecipeScalarFieldEnum)[keyof typeof LocalRecipeScalarFieldEnum]


  export const LocalBatchScalarFieldEnum: {
    id: 'id',
    batchNumber: 'batchNumber',
    recipeId: 'recipeId',
    volume: 'volume',
    status: 'status',
    startTime: 'startTime',
    endTime: 'endTime',
    operatorName: 'operatorName',
    syncStatus: 'syncStatus',
    remoteId: 'remoteId',
    createdAt: 'createdAt'
  };

  export type LocalBatchScalarFieldEnum = (typeof LocalBatchScalarFieldEnum)[keyof typeof LocalBatchScalarFieldEnum]


  export const LocalBatchingRecordScalarFieldEnum: {
    id: 'id',
    batchId: 'batchId',
    materialName: 'materialName',
    targetWeight: 'targetWeight',
    actualWeight: 'actualWeight',
    deviation: 'deviation',
    toleranceCheck: 'toleranceCheck',
    timestamp: 'timestamp'
  };

  export type LocalBatchingRecordScalarFieldEnum = (typeof LocalBatchingRecordScalarFieldEnum)[keyof typeof LocalBatchingRecordScalarFieldEnum]


  export const LocalAlarmScalarFieldEnum: {
    id: 'id',
    alarmType: 'alarmType',
    source: 'source',
    message: 'message',
    severity: 'severity',
    acknowledged: 'acknowledged',
    resolved: 'resolved',
    syncStatus: 'syncStatus',
    remoteId: 'remoteId',
    timestamp: 'timestamp',
    resolvedAt: 'resolvedAt'
  };

  export type LocalAlarmScalarFieldEnum = (typeof LocalAlarmScalarFieldEnum)[keyof typeof LocalAlarmScalarFieldEnum]


  export const LocalLogScalarFieldEnum: {
    id: 'id',
    level: 'level',
    module: 'module',
    action: 'action',
    message: 'message',
    data: 'data',
    syncStatus: 'syncStatus',
    timestamp: 'timestamp'
  };

  export type LocalLogScalarFieldEnum = (typeof LocalLogScalarFieldEnum)[keyof typeof LocalLogScalarFieldEnum]


  export const SyncQueueScalarFieldEnum: {
    id: 'id',
    type: 'type',
    data: 'data',
    status: 'status',
    retryCount: 'retryCount',
    lastError: 'lastError',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SyncQueueScalarFieldEnum = (typeof SyncQueueScalarFieldEnum)[keyof typeof SyncQueueScalarFieldEnum]


  export const SyncStatusScalarFieldEnum: {
    id: 'id',
    type: 'type',
    status: 'status',
    lastSync: 'lastSync',
    lastError: 'lastError',
    syncCount: 'syncCount',
    errorCount: 'errorCount',
    updatedAt: 'updatedAt'
  };

  export type SyncStatusScalarFieldEnum = (typeof SyncStatusScalarFieldEnum)[keyof typeof SyncStatusScalarFieldEnum]


  export const RecipeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    cement: 'cement',
    water: 'water',
    sand: 'sand',
    gravel: 'gravel',
    additive: 'additive',
    mixingTime: 'mixingTime',
    enabled: 'enabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RecipeScalarFieldEnum = (typeof RecipeScalarFieldEnum)[keyof typeof RecipeScalarFieldEnum]


  export const ProductionTaskScalarFieldEnum: {
    id: 'id',
    recipeId: 'recipeId',
    quantity: 'quantity',
    priority: 'priority',
    status: 'status',
    startTime: 'startTime',
    endTime: 'endTime',
    createdAt: 'createdAt'
  };

  export type ProductionTaskScalarFieldEnum = (typeof ProductionTaskScalarFieldEnum)[keyof typeof ProductionTaskScalarFieldEnum]


  export const ProductionRecordScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    recipeId: 'recipeId',
    quantity: 'quantity',
    status: 'status',
    startTime: 'startTime',
    endTime: 'endTime',
    createdAt: 'createdAt'
  };

  export type ProductionRecordScalarFieldEnum = (typeof ProductionRecordScalarFieldEnum)[keyof typeof ProductionRecordScalarFieldEnum]


  export const AlarmScalarFieldEnum: {
    id: 'id',
    type: 'type',
    source: 'source',
    message: 'message',
    severity: 'severity',
    status: 'status',
    data: 'data',
    acknowledgedAt: 'acknowledgedAt',
    acknowledgedBy: 'acknowledgedBy',
    resolvedAt: 'resolvedAt',
    resolvedBy: 'resolvedBy',
    resolution: 'resolution',
    createdAt: 'createdAt'
  };

  export type AlarmScalarFieldEnum = (typeof AlarmScalarFieldEnum)[keyof typeof AlarmScalarFieldEnum]


  export const SafetyEventScalarFieldEnum: {
    id: 'id',
    type: 'type',
    description: 'description',
    severity: 'severity',
    data: 'data',
    createdAt: 'createdAt'
  };

  export type SafetyEventScalarFieldEnum = (typeof SafetyEventScalarFieldEnum)[keyof typeof SafetyEventScalarFieldEnum]


  export const SafetyRuleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    condition: 'condition',
    threshold: 'threshold',
    action: 'action',
    enabled: 'enabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SafetyRuleScalarFieldEnum = (typeof SafetyRuleScalarFieldEnum)[keyof typeof SafetyRuleScalarFieldEnum]


  export const SystemMetricsScalarFieldEnum: {
    id: 'id',
    type: 'type',
    data: 'data',
    timestamp: 'timestamp'
  };

  export type SystemMetricsScalarFieldEnum = (typeof SystemMetricsScalarFieldEnum)[keyof typeof SystemMetricsScalarFieldEnum]


  export const EquipmentRuntimeScalarFieldEnum: {
    id: 'id',
    equipmentName: 'equipmentName',
    runtime: 'runtime',
    date: 'date',
    createdAt: 'createdAt'
  };

  export type EquipmentRuntimeScalarFieldEnum = (typeof EquipmentRuntimeScalarFieldEnum)[keyof typeof EquipmentRuntimeScalarFieldEnum]


  export const SystemStatusScalarFieldEnum: {
    id: 'id',
    cpuUsage: 'cpuUsage',
    memoryUsage: 'memoryUsage',
    diskUsage: 'diskUsage',
    temperature: 'temperature',
    uptime: 'uptime',
    timestamp: 'timestamp'
  };

  export type SystemStatusScalarFieldEnum = (typeof SystemStatusScalarFieldEnum)[keyof typeof SystemStatusScalarFieldEnum]


  export const DeviceStatsScalarFieldEnum: {
    id: 'id',
    deviceId: 'deviceId',
    connectTime: 'connectTime',
    disconnectTime: 'disconnectTime',
    errorCount: 'errorCount',
    dataPointCount: 'dataPointCount',
    lastUpdate: 'lastUpdate',
    date: 'date'
  };

  export type DeviceStatsScalarFieldEnum = (typeof DeviceStatsScalarFieldEnum)[keyof typeof DeviceStatsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type EdgeConfigWhereInput = {
    AND?: EdgeConfigWhereInput | EdgeConfigWhereInput[]
    OR?: EdgeConfigWhereInput[]
    NOT?: EdgeConfigWhereInput | EdgeConfigWhereInput[]
    id?: IntFilter<"EdgeConfig"> | number
    key?: StringFilter<"EdgeConfig"> | string
    value?: StringFilter<"EdgeConfig"> | string
    description?: StringNullableFilter<"EdgeConfig"> | string | null
    updatedAt?: DateTimeFilter<"EdgeConfig"> | Date | string
  }

  export type EdgeConfigOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
  }

  export type EdgeConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    key?: string
    AND?: EdgeConfigWhereInput | EdgeConfigWhereInput[]
    OR?: EdgeConfigWhereInput[]
    NOT?: EdgeConfigWhereInput | EdgeConfigWhereInput[]
    value?: StringFilter<"EdgeConfig"> | string
    description?: StringNullableFilter<"EdgeConfig"> | string | null
    updatedAt?: DateTimeFilter<"EdgeConfig"> | Date | string
  }, "id" | "key">

  export type EdgeConfigOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: EdgeConfigCountOrderByAggregateInput
    _avg?: EdgeConfigAvgOrderByAggregateInput
    _max?: EdgeConfigMaxOrderByAggregateInput
    _min?: EdgeConfigMinOrderByAggregateInput
    _sum?: EdgeConfigSumOrderByAggregateInput
  }

  export type EdgeConfigScalarWhereWithAggregatesInput = {
    AND?: EdgeConfigScalarWhereWithAggregatesInput | EdgeConfigScalarWhereWithAggregatesInput[]
    OR?: EdgeConfigScalarWhereWithAggregatesInput[]
    NOT?: EdgeConfigScalarWhereWithAggregatesInput | EdgeConfigScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EdgeConfig"> | number
    key?: StringWithAggregatesFilter<"EdgeConfig"> | string
    value?: StringWithAggregatesFilter<"EdgeConfig"> | string
    description?: StringNullableWithAggregatesFilter<"EdgeConfig"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"EdgeConfig"> | Date | string
  }

  export type DeviceConnectionWhereInput = {
    AND?: DeviceConnectionWhereInput | DeviceConnectionWhereInput[]
    OR?: DeviceConnectionWhereInput[]
    NOT?: DeviceConnectionWhereInput | DeviceConnectionWhereInput[]
    id?: IntFilter<"DeviceConnection"> | number
    deviceType?: StringFilter<"DeviceConnection"> | string
    deviceId?: StringFilter<"DeviceConnection"> | string
    host?: StringFilter<"DeviceConnection"> | string
    port?: IntNullableFilter<"DeviceConnection"> | number | null
    status?: StringFilter<"DeviceConnection"> | string
    lastConnect?: DateTimeNullableFilter<"DeviceConnection"> | Date | string | null
    errorMessage?: StringNullableFilter<"DeviceConnection"> | string | null
    createdAt?: DateTimeFilter<"DeviceConnection"> | Date | string
    updatedAt?: DateTimeFilter<"DeviceConnection"> | Date | string
  }

  export type DeviceConnectionOrderByWithRelationInput = {
    id?: SortOrder
    deviceType?: SortOrder
    deviceId?: SortOrder
    host?: SortOrder
    port?: SortOrderInput | SortOrder
    status?: SortOrder
    lastConnect?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviceConnectionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DeviceConnectionWhereInput | DeviceConnectionWhereInput[]
    OR?: DeviceConnectionWhereInput[]
    NOT?: DeviceConnectionWhereInput | DeviceConnectionWhereInput[]
    deviceType?: StringFilter<"DeviceConnection"> | string
    deviceId?: StringFilter<"DeviceConnection"> | string
    host?: StringFilter<"DeviceConnection"> | string
    port?: IntNullableFilter<"DeviceConnection"> | number | null
    status?: StringFilter<"DeviceConnection"> | string
    lastConnect?: DateTimeNullableFilter<"DeviceConnection"> | Date | string | null
    errorMessage?: StringNullableFilter<"DeviceConnection"> | string | null
    createdAt?: DateTimeFilter<"DeviceConnection"> | Date | string
    updatedAt?: DateTimeFilter<"DeviceConnection"> | Date | string
  }, "id">

  export type DeviceConnectionOrderByWithAggregationInput = {
    id?: SortOrder
    deviceType?: SortOrder
    deviceId?: SortOrder
    host?: SortOrder
    port?: SortOrderInput | SortOrder
    status?: SortOrder
    lastConnect?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeviceConnectionCountOrderByAggregateInput
    _avg?: DeviceConnectionAvgOrderByAggregateInput
    _max?: DeviceConnectionMaxOrderByAggregateInput
    _min?: DeviceConnectionMinOrderByAggregateInput
    _sum?: DeviceConnectionSumOrderByAggregateInput
  }

  export type DeviceConnectionScalarWhereWithAggregatesInput = {
    AND?: DeviceConnectionScalarWhereWithAggregatesInput | DeviceConnectionScalarWhereWithAggregatesInput[]
    OR?: DeviceConnectionScalarWhereWithAggregatesInput[]
    NOT?: DeviceConnectionScalarWhereWithAggregatesInput | DeviceConnectionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DeviceConnection"> | number
    deviceType?: StringWithAggregatesFilter<"DeviceConnection"> | string
    deviceId?: StringWithAggregatesFilter<"DeviceConnection"> | string
    host?: StringWithAggregatesFilter<"DeviceConnection"> | string
    port?: IntNullableWithAggregatesFilter<"DeviceConnection"> | number | null
    status?: StringWithAggregatesFilter<"DeviceConnection"> | string
    lastConnect?: DateTimeNullableWithAggregatesFilter<"DeviceConnection"> | Date | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"DeviceConnection"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DeviceConnection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DeviceConnection"> | Date | string
  }

  export type DataPointWhereInput = {
    AND?: DataPointWhereInput | DataPointWhereInput[]
    OR?: DataPointWhereInput[]
    NOT?: DataPointWhereInput | DataPointWhereInput[]
    id?: IntFilter<"DataPoint"> | number
    tagName?: StringFilter<"DataPoint"> | string
    deviceId?: StringFilter<"DataPoint"> | string
    address?: StringFilter<"DataPoint"> | string
    dataType?: StringFilter<"DataPoint"> | string
    value?: StringFilter<"DataPoint"> | string
    quality?: StringFilter<"DataPoint"> | string
    timestamp?: DateTimeFilter<"DataPoint"> | Date | string
    description?: StringNullableFilter<"DataPoint"> | string | null
    history?: DataHistoryListRelationFilter
  }

  export type DataPointOrderByWithRelationInput = {
    id?: SortOrder
    tagName?: SortOrder
    deviceId?: SortOrder
    address?: SortOrder
    dataType?: SortOrder
    value?: SortOrder
    quality?: SortOrder
    timestamp?: SortOrder
    description?: SortOrderInput | SortOrder
    history?: DataHistoryOrderByRelationAggregateInput
  }

  export type DataPointWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    tagName_deviceId?: DataPointTagNameDeviceIdCompoundUniqueInput
    AND?: DataPointWhereInput | DataPointWhereInput[]
    OR?: DataPointWhereInput[]
    NOT?: DataPointWhereInput | DataPointWhereInput[]
    tagName?: StringFilter<"DataPoint"> | string
    deviceId?: StringFilter<"DataPoint"> | string
    address?: StringFilter<"DataPoint"> | string
    dataType?: StringFilter<"DataPoint"> | string
    value?: StringFilter<"DataPoint"> | string
    quality?: StringFilter<"DataPoint"> | string
    timestamp?: DateTimeFilter<"DataPoint"> | Date | string
    description?: StringNullableFilter<"DataPoint"> | string | null
    history?: DataHistoryListRelationFilter
  }, "id" | "tagName_deviceId">

  export type DataPointOrderByWithAggregationInput = {
    id?: SortOrder
    tagName?: SortOrder
    deviceId?: SortOrder
    address?: SortOrder
    dataType?: SortOrder
    value?: SortOrder
    quality?: SortOrder
    timestamp?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: DataPointCountOrderByAggregateInput
    _avg?: DataPointAvgOrderByAggregateInput
    _max?: DataPointMaxOrderByAggregateInput
    _min?: DataPointMinOrderByAggregateInput
    _sum?: DataPointSumOrderByAggregateInput
  }

  export type DataPointScalarWhereWithAggregatesInput = {
    AND?: DataPointScalarWhereWithAggregatesInput | DataPointScalarWhereWithAggregatesInput[]
    OR?: DataPointScalarWhereWithAggregatesInput[]
    NOT?: DataPointScalarWhereWithAggregatesInput | DataPointScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DataPoint"> | number
    tagName?: StringWithAggregatesFilter<"DataPoint"> | string
    deviceId?: StringWithAggregatesFilter<"DataPoint"> | string
    address?: StringWithAggregatesFilter<"DataPoint"> | string
    dataType?: StringWithAggregatesFilter<"DataPoint"> | string
    value?: StringWithAggregatesFilter<"DataPoint"> | string
    quality?: StringWithAggregatesFilter<"DataPoint"> | string
    timestamp?: DateTimeWithAggregatesFilter<"DataPoint"> | Date | string
    description?: StringNullableWithAggregatesFilter<"DataPoint"> | string | null
  }

  export type DataHistoryWhereInput = {
    AND?: DataHistoryWhereInput | DataHistoryWhereInput[]
    OR?: DataHistoryWhereInput[]
    NOT?: DataHistoryWhereInput | DataHistoryWhereInput[]
    id?: IntFilter<"DataHistory"> | number
    pointId?: IntFilter<"DataHistory"> | number
    value?: StringFilter<"DataHistory"> | string
    quality?: StringFilter<"DataHistory"> | string
    timestamp?: DateTimeFilter<"DataHistory"> | Date | string
    dataPoint?: XOR<DataPointRelationFilter, DataPointWhereInput>
  }

  export type DataHistoryOrderByWithRelationInput = {
    id?: SortOrder
    pointId?: SortOrder
    value?: SortOrder
    quality?: SortOrder
    timestamp?: SortOrder
    dataPoint?: DataPointOrderByWithRelationInput
  }

  export type DataHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DataHistoryWhereInput | DataHistoryWhereInput[]
    OR?: DataHistoryWhereInput[]
    NOT?: DataHistoryWhereInput | DataHistoryWhereInput[]
    pointId?: IntFilter<"DataHistory"> | number
    value?: StringFilter<"DataHistory"> | string
    quality?: StringFilter<"DataHistory"> | string
    timestamp?: DateTimeFilter<"DataHistory"> | Date | string
    dataPoint?: XOR<DataPointRelationFilter, DataPointWhereInput>
  }, "id">

  export type DataHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    pointId?: SortOrder
    value?: SortOrder
    quality?: SortOrder
    timestamp?: SortOrder
    _count?: DataHistoryCountOrderByAggregateInput
    _avg?: DataHistoryAvgOrderByAggregateInput
    _max?: DataHistoryMaxOrderByAggregateInput
    _min?: DataHistoryMinOrderByAggregateInput
    _sum?: DataHistorySumOrderByAggregateInput
  }

  export type DataHistoryScalarWhereWithAggregatesInput = {
    AND?: DataHistoryScalarWhereWithAggregatesInput | DataHistoryScalarWhereWithAggregatesInput[]
    OR?: DataHistoryScalarWhereWithAggregatesInput[]
    NOT?: DataHistoryScalarWhereWithAggregatesInput | DataHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DataHistory"> | number
    pointId?: IntWithAggregatesFilter<"DataHistory"> | number
    value?: StringWithAggregatesFilter<"DataHistory"> | string
    quality?: StringWithAggregatesFilter<"DataHistory"> | string
    timestamp?: DateTimeWithAggregatesFilter<"DataHistory"> | Date | string
  }

  export type LocalRecipeWhereInput = {
    AND?: LocalRecipeWhereInput | LocalRecipeWhereInput[]
    OR?: LocalRecipeWhereInput[]
    NOT?: LocalRecipeWhereInput | LocalRecipeWhereInput[]
    id?: IntFilter<"LocalRecipe"> | number
    name?: StringFilter<"LocalRecipe"> | string
    concreteGrade?: StringFilter<"LocalRecipe"> | string
    version?: StringFilter<"LocalRecipe"> | string
    isActive?: BoolFilter<"LocalRecipe"> | boolean
    recipeData?: StringFilter<"LocalRecipe"> | string
    syncStatus?: StringFilter<"LocalRecipe"> | string
    remoteId?: IntNullableFilter<"LocalRecipe"> | number | null
    createdAt?: DateTimeFilter<"LocalRecipe"> | Date | string
    updatedAt?: DateTimeFilter<"LocalRecipe"> | Date | string
    batches?: LocalBatchListRelationFilter
  }

  export type LocalRecipeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    concreteGrade?: SortOrder
    version?: SortOrder
    isActive?: SortOrder
    recipeData?: SortOrder
    syncStatus?: SortOrder
    remoteId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    batches?: LocalBatchOrderByRelationAggregateInput
  }

  export type LocalRecipeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LocalRecipeWhereInput | LocalRecipeWhereInput[]
    OR?: LocalRecipeWhereInput[]
    NOT?: LocalRecipeWhereInput | LocalRecipeWhereInput[]
    name?: StringFilter<"LocalRecipe"> | string
    concreteGrade?: StringFilter<"LocalRecipe"> | string
    version?: StringFilter<"LocalRecipe"> | string
    isActive?: BoolFilter<"LocalRecipe"> | boolean
    recipeData?: StringFilter<"LocalRecipe"> | string
    syncStatus?: StringFilter<"LocalRecipe"> | string
    remoteId?: IntNullableFilter<"LocalRecipe"> | number | null
    createdAt?: DateTimeFilter<"LocalRecipe"> | Date | string
    updatedAt?: DateTimeFilter<"LocalRecipe"> | Date | string
    batches?: LocalBatchListRelationFilter
  }, "id">

  export type LocalRecipeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    concreteGrade?: SortOrder
    version?: SortOrder
    isActive?: SortOrder
    recipeData?: SortOrder
    syncStatus?: SortOrder
    remoteId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LocalRecipeCountOrderByAggregateInput
    _avg?: LocalRecipeAvgOrderByAggregateInput
    _max?: LocalRecipeMaxOrderByAggregateInput
    _min?: LocalRecipeMinOrderByAggregateInput
    _sum?: LocalRecipeSumOrderByAggregateInput
  }

  export type LocalRecipeScalarWhereWithAggregatesInput = {
    AND?: LocalRecipeScalarWhereWithAggregatesInput | LocalRecipeScalarWhereWithAggregatesInput[]
    OR?: LocalRecipeScalarWhereWithAggregatesInput[]
    NOT?: LocalRecipeScalarWhereWithAggregatesInput | LocalRecipeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LocalRecipe"> | number
    name?: StringWithAggregatesFilter<"LocalRecipe"> | string
    concreteGrade?: StringWithAggregatesFilter<"LocalRecipe"> | string
    version?: StringWithAggregatesFilter<"LocalRecipe"> | string
    isActive?: BoolWithAggregatesFilter<"LocalRecipe"> | boolean
    recipeData?: StringWithAggregatesFilter<"LocalRecipe"> | string
    syncStatus?: StringWithAggregatesFilter<"LocalRecipe"> | string
    remoteId?: IntNullableWithAggregatesFilter<"LocalRecipe"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"LocalRecipe"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LocalRecipe"> | Date | string
  }

  export type LocalBatchWhereInput = {
    AND?: LocalBatchWhereInput | LocalBatchWhereInput[]
    OR?: LocalBatchWhereInput[]
    NOT?: LocalBatchWhereInput | LocalBatchWhereInput[]
    id?: IntFilter<"LocalBatch"> | number
    batchNumber?: StringFilter<"LocalBatch"> | string
    recipeId?: IntFilter<"LocalBatch"> | number
    volume?: FloatFilter<"LocalBatch"> | number
    status?: StringFilter<"LocalBatch"> | string
    startTime?: DateTimeNullableFilter<"LocalBatch"> | Date | string | null
    endTime?: DateTimeNullableFilter<"LocalBatch"> | Date | string | null
    operatorName?: StringNullableFilter<"LocalBatch"> | string | null
    syncStatus?: StringFilter<"LocalBatch"> | string
    remoteId?: IntNullableFilter<"LocalBatch"> | number | null
    createdAt?: DateTimeFilter<"LocalBatch"> | Date | string
    recipe?: XOR<LocalRecipeRelationFilter, LocalRecipeWhereInput>
    batchingRecords?: LocalBatchingRecordListRelationFilter
  }

  export type LocalBatchOrderByWithRelationInput = {
    id?: SortOrder
    batchNumber?: SortOrder
    recipeId?: SortOrder
    volume?: SortOrder
    status?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    operatorName?: SortOrderInput | SortOrder
    syncStatus?: SortOrder
    remoteId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    recipe?: LocalRecipeOrderByWithRelationInput
    batchingRecords?: LocalBatchingRecordOrderByRelationAggregateInput
  }

  export type LocalBatchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    batchNumber?: string
    AND?: LocalBatchWhereInput | LocalBatchWhereInput[]
    OR?: LocalBatchWhereInput[]
    NOT?: LocalBatchWhereInput | LocalBatchWhereInput[]
    recipeId?: IntFilter<"LocalBatch"> | number
    volume?: FloatFilter<"LocalBatch"> | number
    status?: StringFilter<"LocalBatch"> | string
    startTime?: DateTimeNullableFilter<"LocalBatch"> | Date | string | null
    endTime?: DateTimeNullableFilter<"LocalBatch"> | Date | string | null
    operatorName?: StringNullableFilter<"LocalBatch"> | string | null
    syncStatus?: StringFilter<"LocalBatch"> | string
    remoteId?: IntNullableFilter<"LocalBatch"> | number | null
    createdAt?: DateTimeFilter<"LocalBatch"> | Date | string
    recipe?: XOR<LocalRecipeRelationFilter, LocalRecipeWhereInput>
    batchingRecords?: LocalBatchingRecordListRelationFilter
  }, "id" | "batchNumber">

  export type LocalBatchOrderByWithAggregationInput = {
    id?: SortOrder
    batchNumber?: SortOrder
    recipeId?: SortOrder
    volume?: SortOrder
    status?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    operatorName?: SortOrderInput | SortOrder
    syncStatus?: SortOrder
    remoteId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LocalBatchCountOrderByAggregateInput
    _avg?: LocalBatchAvgOrderByAggregateInput
    _max?: LocalBatchMaxOrderByAggregateInput
    _min?: LocalBatchMinOrderByAggregateInput
    _sum?: LocalBatchSumOrderByAggregateInput
  }

  export type LocalBatchScalarWhereWithAggregatesInput = {
    AND?: LocalBatchScalarWhereWithAggregatesInput | LocalBatchScalarWhereWithAggregatesInput[]
    OR?: LocalBatchScalarWhereWithAggregatesInput[]
    NOT?: LocalBatchScalarWhereWithAggregatesInput | LocalBatchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LocalBatch"> | number
    batchNumber?: StringWithAggregatesFilter<"LocalBatch"> | string
    recipeId?: IntWithAggregatesFilter<"LocalBatch"> | number
    volume?: FloatWithAggregatesFilter<"LocalBatch"> | number
    status?: StringWithAggregatesFilter<"LocalBatch"> | string
    startTime?: DateTimeNullableWithAggregatesFilter<"LocalBatch"> | Date | string | null
    endTime?: DateTimeNullableWithAggregatesFilter<"LocalBatch"> | Date | string | null
    operatorName?: StringNullableWithAggregatesFilter<"LocalBatch"> | string | null
    syncStatus?: StringWithAggregatesFilter<"LocalBatch"> | string
    remoteId?: IntNullableWithAggregatesFilter<"LocalBatch"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"LocalBatch"> | Date | string
  }

  export type LocalBatchingRecordWhereInput = {
    AND?: LocalBatchingRecordWhereInput | LocalBatchingRecordWhereInput[]
    OR?: LocalBatchingRecordWhereInput[]
    NOT?: LocalBatchingRecordWhereInput | LocalBatchingRecordWhereInput[]
    id?: IntFilter<"LocalBatchingRecord"> | number
    batchId?: IntFilter<"LocalBatchingRecord"> | number
    materialName?: StringFilter<"LocalBatchingRecord"> | string
    targetWeight?: FloatFilter<"LocalBatchingRecord"> | number
    actualWeight?: FloatFilter<"LocalBatchingRecord"> | number
    deviation?: FloatNullableFilter<"LocalBatchingRecord"> | number | null
    toleranceCheck?: StringFilter<"LocalBatchingRecord"> | string
    timestamp?: DateTimeFilter<"LocalBatchingRecord"> | Date | string
    batch?: XOR<LocalBatchRelationFilter, LocalBatchWhereInput>
  }

  export type LocalBatchingRecordOrderByWithRelationInput = {
    id?: SortOrder
    batchId?: SortOrder
    materialName?: SortOrder
    targetWeight?: SortOrder
    actualWeight?: SortOrder
    deviation?: SortOrderInput | SortOrder
    toleranceCheck?: SortOrder
    timestamp?: SortOrder
    batch?: LocalBatchOrderByWithRelationInput
  }

  export type LocalBatchingRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LocalBatchingRecordWhereInput | LocalBatchingRecordWhereInput[]
    OR?: LocalBatchingRecordWhereInput[]
    NOT?: LocalBatchingRecordWhereInput | LocalBatchingRecordWhereInput[]
    batchId?: IntFilter<"LocalBatchingRecord"> | number
    materialName?: StringFilter<"LocalBatchingRecord"> | string
    targetWeight?: FloatFilter<"LocalBatchingRecord"> | number
    actualWeight?: FloatFilter<"LocalBatchingRecord"> | number
    deviation?: FloatNullableFilter<"LocalBatchingRecord"> | number | null
    toleranceCheck?: StringFilter<"LocalBatchingRecord"> | string
    timestamp?: DateTimeFilter<"LocalBatchingRecord"> | Date | string
    batch?: XOR<LocalBatchRelationFilter, LocalBatchWhereInput>
  }, "id">

  export type LocalBatchingRecordOrderByWithAggregationInput = {
    id?: SortOrder
    batchId?: SortOrder
    materialName?: SortOrder
    targetWeight?: SortOrder
    actualWeight?: SortOrder
    deviation?: SortOrderInput | SortOrder
    toleranceCheck?: SortOrder
    timestamp?: SortOrder
    _count?: LocalBatchingRecordCountOrderByAggregateInput
    _avg?: LocalBatchingRecordAvgOrderByAggregateInput
    _max?: LocalBatchingRecordMaxOrderByAggregateInput
    _min?: LocalBatchingRecordMinOrderByAggregateInput
    _sum?: LocalBatchingRecordSumOrderByAggregateInput
  }

  export type LocalBatchingRecordScalarWhereWithAggregatesInput = {
    AND?: LocalBatchingRecordScalarWhereWithAggregatesInput | LocalBatchingRecordScalarWhereWithAggregatesInput[]
    OR?: LocalBatchingRecordScalarWhereWithAggregatesInput[]
    NOT?: LocalBatchingRecordScalarWhereWithAggregatesInput | LocalBatchingRecordScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LocalBatchingRecord"> | number
    batchId?: IntWithAggregatesFilter<"LocalBatchingRecord"> | number
    materialName?: StringWithAggregatesFilter<"LocalBatchingRecord"> | string
    targetWeight?: FloatWithAggregatesFilter<"LocalBatchingRecord"> | number
    actualWeight?: FloatWithAggregatesFilter<"LocalBatchingRecord"> | number
    deviation?: FloatNullableWithAggregatesFilter<"LocalBatchingRecord"> | number | null
    toleranceCheck?: StringWithAggregatesFilter<"LocalBatchingRecord"> | string
    timestamp?: DateTimeWithAggregatesFilter<"LocalBatchingRecord"> | Date | string
  }

  export type LocalAlarmWhereInput = {
    AND?: LocalAlarmWhereInput | LocalAlarmWhereInput[]
    OR?: LocalAlarmWhereInput[]
    NOT?: LocalAlarmWhereInput | LocalAlarmWhereInput[]
    id?: IntFilter<"LocalAlarm"> | number
    alarmType?: StringFilter<"LocalAlarm"> | string
    source?: StringFilter<"LocalAlarm"> | string
    message?: StringFilter<"LocalAlarm"> | string
    severity?: StringFilter<"LocalAlarm"> | string
    acknowledged?: BoolFilter<"LocalAlarm"> | boolean
    resolved?: BoolFilter<"LocalAlarm"> | boolean
    syncStatus?: StringFilter<"LocalAlarm"> | string
    remoteId?: IntNullableFilter<"LocalAlarm"> | number | null
    timestamp?: DateTimeFilter<"LocalAlarm"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"LocalAlarm"> | Date | string | null
  }

  export type LocalAlarmOrderByWithRelationInput = {
    id?: SortOrder
    alarmType?: SortOrder
    source?: SortOrder
    message?: SortOrder
    severity?: SortOrder
    acknowledged?: SortOrder
    resolved?: SortOrder
    syncStatus?: SortOrder
    remoteId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
  }

  export type LocalAlarmWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LocalAlarmWhereInput | LocalAlarmWhereInput[]
    OR?: LocalAlarmWhereInput[]
    NOT?: LocalAlarmWhereInput | LocalAlarmWhereInput[]
    alarmType?: StringFilter<"LocalAlarm"> | string
    source?: StringFilter<"LocalAlarm"> | string
    message?: StringFilter<"LocalAlarm"> | string
    severity?: StringFilter<"LocalAlarm"> | string
    acknowledged?: BoolFilter<"LocalAlarm"> | boolean
    resolved?: BoolFilter<"LocalAlarm"> | boolean
    syncStatus?: StringFilter<"LocalAlarm"> | string
    remoteId?: IntNullableFilter<"LocalAlarm"> | number | null
    timestamp?: DateTimeFilter<"LocalAlarm"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"LocalAlarm"> | Date | string | null
  }, "id">

  export type LocalAlarmOrderByWithAggregationInput = {
    id?: SortOrder
    alarmType?: SortOrder
    source?: SortOrder
    message?: SortOrder
    severity?: SortOrder
    acknowledged?: SortOrder
    resolved?: SortOrder
    syncStatus?: SortOrder
    remoteId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    _count?: LocalAlarmCountOrderByAggregateInput
    _avg?: LocalAlarmAvgOrderByAggregateInput
    _max?: LocalAlarmMaxOrderByAggregateInput
    _min?: LocalAlarmMinOrderByAggregateInput
    _sum?: LocalAlarmSumOrderByAggregateInput
  }

  export type LocalAlarmScalarWhereWithAggregatesInput = {
    AND?: LocalAlarmScalarWhereWithAggregatesInput | LocalAlarmScalarWhereWithAggregatesInput[]
    OR?: LocalAlarmScalarWhereWithAggregatesInput[]
    NOT?: LocalAlarmScalarWhereWithAggregatesInput | LocalAlarmScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LocalAlarm"> | number
    alarmType?: StringWithAggregatesFilter<"LocalAlarm"> | string
    source?: StringWithAggregatesFilter<"LocalAlarm"> | string
    message?: StringWithAggregatesFilter<"LocalAlarm"> | string
    severity?: StringWithAggregatesFilter<"LocalAlarm"> | string
    acknowledged?: BoolWithAggregatesFilter<"LocalAlarm"> | boolean
    resolved?: BoolWithAggregatesFilter<"LocalAlarm"> | boolean
    syncStatus?: StringWithAggregatesFilter<"LocalAlarm"> | string
    remoteId?: IntNullableWithAggregatesFilter<"LocalAlarm"> | number | null
    timestamp?: DateTimeWithAggregatesFilter<"LocalAlarm"> | Date | string
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"LocalAlarm"> | Date | string | null
  }

  export type LocalLogWhereInput = {
    AND?: LocalLogWhereInput | LocalLogWhereInput[]
    OR?: LocalLogWhereInput[]
    NOT?: LocalLogWhereInput | LocalLogWhereInput[]
    id?: IntFilter<"LocalLog"> | number
    level?: StringFilter<"LocalLog"> | string
    module?: StringFilter<"LocalLog"> | string
    action?: StringFilter<"LocalLog"> | string
    message?: StringFilter<"LocalLog"> | string
    data?: StringNullableFilter<"LocalLog"> | string | null
    syncStatus?: StringFilter<"LocalLog"> | string
    timestamp?: DateTimeFilter<"LocalLog"> | Date | string
  }

  export type LocalLogOrderByWithRelationInput = {
    id?: SortOrder
    level?: SortOrder
    module?: SortOrder
    action?: SortOrder
    message?: SortOrder
    data?: SortOrderInput | SortOrder
    syncStatus?: SortOrder
    timestamp?: SortOrder
  }

  export type LocalLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LocalLogWhereInput | LocalLogWhereInput[]
    OR?: LocalLogWhereInput[]
    NOT?: LocalLogWhereInput | LocalLogWhereInput[]
    level?: StringFilter<"LocalLog"> | string
    module?: StringFilter<"LocalLog"> | string
    action?: StringFilter<"LocalLog"> | string
    message?: StringFilter<"LocalLog"> | string
    data?: StringNullableFilter<"LocalLog"> | string | null
    syncStatus?: StringFilter<"LocalLog"> | string
    timestamp?: DateTimeFilter<"LocalLog"> | Date | string
  }, "id">

  export type LocalLogOrderByWithAggregationInput = {
    id?: SortOrder
    level?: SortOrder
    module?: SortOrder
    action?: SortOrder
    message?: SortOrder
    data?: SortOrderInput | SortOrder
    syncStatus?: SortOrder
    timestamp?: SortOrder
    _count?: LocalLogCountOrderByAggregateInput
    _avg?: LocalLogAvgOrderByAggregateInput
    _max?: LocalLogMaxOrderByAggregateInput
    _min?: LocalLogMinOrderByAggregateInput
    _sum?: LocalLogSumOrderByAggregateInput
  }

  export type LocalLogScalarWhereWithAggregatesInput = {
    AND?: LocalLogScalarWhereWithAggregatesInput | LocalLogScalarWhereWithAggregatesInput[]
    OR?: LocalLogScalarWhereWithAggregatesInput[]
    NOT?: LocalLogScalarWhereWithAggregatesInput | LocalLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LocalLog"> | number
    level?: StringWithAggregatesFilter<"LocalLog"> | string
    module?: StringWithAggregatesFilter<"LocalLog"> | string
    action?: StringWithAggregatesFilter<"LocalLog"> | string
    message?: StringWithAggregatesFilter<"LocalLog"> | string
    data?: StringNullableWithAggregatesFilter<"LocalLog"> | string | null
    syncStatus?: StringWithAggregatesFilter<"LocalLog"> | string
    timestamp?: DateTimeWithAggregatesFilter<"LocalLog"> | Date | string
  }

  export type SyncQueueWhereInput = {
    AND?: SyncQueueWhereInput | SyncQueueWhereInput[]
    OR?: SyncQueueWhereInput[]
    NOT?: SyncQueueWhereInput | SyncQueueWhereInput[]
    id?: IntFilter<"SyncQueue"> | number
    type?: StringFilter<"SyncQueue"> | string
    data?: StringFilter<"SyncQueue"> | string
    status?: StringFilter<"SyncQueue"> | string
    retryCount?: IntFilter<"SyncQueue"> | number
    lastError?: StringNullableFilter<"SyncQueue"> | string | null
    createdAt?: DateTimeFilter<"SyncQueue"> | Date | string
    updatedAt?: DateTimeFilter<"SyncQueue"> | Date | string
  }

  export type SyncQueueOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrder
    status?: SortOrder
    retryCount?: SortOrder
    lastError?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SyncQueueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SyncQueueWhereInput | SyncQueueWhereInput[]
    OR?: SyncQueueWhereInput[]
    NOT?: SyncQueueWhereInput | SyncQueueWhereInput[]
    type?: StringFilter<"SyncQueue"> | string
    data?: StringFilter<"SyncQueue"> | string
    status?: StringFilter<"SyncQueue"> | string
    retryCount?: IntFilter<"SyncQueue"> | number
    lastError?: StringNullableFilter<"SyncQueue"> | string | null
    createdAt?: DateTimeFilter<"SyncQueue"> | Date | string
    updatedAt?: DateTimeFilter<"SyncQueue"> | Date | string
  }, "id">

  export type SyncQueueOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrder
    status?: SortOrder
    retryCount?: SortOrder
    lastError?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SyncQueueCountOrderByAggregateInput
    _avg?: SyncQueueAvgOrderByAggregateInput
    _max?: SyncQueueMaxOrderByAggregateInput
    _min?: SyncQueueMinOrderByAggregateInput
    _sum?: SyncQueueSumOrderByAggregateInput
  }

  export type SyncQueueScalarWhereWithAggregatesInput = {
    AND?: SyncQueueScalarWhereWithAggregatesInput | SyncQueueScalarWhereWithAggregatesInput[]
    OR?: SyncQueueScalarWhereWithAggregatesInput[]
    NOT?: SyncQueueScalarWhereWithAggregatesInput | SyncQueueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SyncQueue"> | number
    type?: StringWithAggregatesFilter<"SyncQueue"> | string
    data?: StringWithAggregatesFilter<"SyncQueue"> | string
    status?: StringWithAggregatesFilter<"SyncQueue"> | string
    retryCount?: IntWithAggregatesFilter<"SyncQueue"> | number
    lastError?: StringNullableWithAggregatesFilter<"SyncQueue"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SyncQueue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SyncQueue"> | Date | string
  }

  export type SyncStatusWhereInput = {
    AND?: SyncStatusWhereInput | SyncStatusWhereInput[]
    OR?: SyncStatusWhereInput[]
    NOT?: SyncStatusWhereInput | SyncStatusWhereInput[]
    id?: IntFilter<"SyncStatus"> | number
    type?: StringFilter<"SyncStatus"> | string
    status?: StringFilter<"SyncStatus"> | string
    lastSync?: DateTimeNullableFilter<"SyncStatus"> | Date | string | null
    lastError?: StringNullableFilter<"SyncStatus"> | string | null
    syncCount?: IntFilter<"SyncStatus"> | number
    errorCount?: IntFilter<"SyncStatus"> | number
    updatedAt?: DateTimeFilter<"SyncStatus"> | Date | string
  }

  export type SyncStatusOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    lastSync?: SortOrderInput | SortOrder
    lastError?: SortOrderInput | SortOrder
    syncCount?: SortOrder
    errorCount?: SortOrder
    updatedAt?: SortOrder
  }

  export type SyncStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    type?: string
    AND?: SyncStatusWhereInput | SyncStatusWhereInput[]
    OR?: SyncStatusWhereInput[]
    NOT?: SyncStatusWhereInput | SyncStatusWhereInput[]
    status?: StringFilter<"SyncStatus"> | string
    lastSync?: DateTimeNullableFilter<"SyncStatus"> | Date | string | null
    lastError?: StringNullableFilter<"SyncStatus"> | string | null
    syncCount?: IntFilter<"SyncStatus"> | number
    errorCount?: IntFilter<"SyncStatus"> | number
    updatedAt?: DateTimeFilter<"SyncStatus"> | Date | string
  }, "id" | "type">

  export type SyncStatusOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    lastSync?: SortOrderInput | SortOrder
    lastError?: SortOrderInput | SortOrder
    syncCount?: SortOrder
    errorCount?: SortOrder
    updatedAt?: SortOrder
    _count?: SyncStatusCountOrderByAggregateInput
    _avg?: SyncStatusAvgOrderByAggregateInput
    _max?: SyncStatusMaxOrderByAggregateInput
    _min?: SyncStatusMinOrderByAggregateInput
    _sum?: SyncStatusSumOrderByAggregateInput
  }

  export type SyncStatusScalarWhereWithAggregatesInput = {
    AND?: SyncStatusScalarWhereWithAggregatesInput | SyncStatusScalarWhereWithAggregatesInput[]
    OR?: SyncStatusScalarWhereWithAggregatesInput[]
    NOT?: SyncStatusScalarWhereWithAggregatesInput | SyncStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SyncStatus"> | number
    type?: StringWithAggregatesFilter<"SyncStatus"> | string
    status?: StringWithAggregatesFilter<"SyncStatus"> | string
    lastSync?: DateTimeNullableWithAggregatesFilter<"SyncStatus"> | Date | string | null
    lastError?: StringNullableWithAggregatesFilter<"SyncStatus"> | string | null
    syncCount?: IntWithAggregatesFilter<"SyncStatus"> | number
    errorCount?: IntWithAggregatesFilter<"SyncStatus"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"SyncStatus"> | Date | string
  }

  export type RecipeWhereInput = {
    AND?: RecipeWhereInput | RecipeWhereInput[]
    OR?: RecipeWhereInput[]
    NOT?: RecipeWhereInput | RecipeWhereInput[]
    id?: StringFilter<"Recipe"> | string
    name?: StringFilter<"Recipe"> | string
    cement?: FloatFilter<"Recipe"> | number
    water?: FloatFilter<"Recipe"> | number
    sand?: FloatFilter<"Recipe"> | number
    gravel?: FloatFilter<"Recipe"> | number
    additive?: FloatFilter<"Recipe"> | number
    mixingTime?: IntFilter<"Recipe"> | number
    enabled?: BoolFilter<"Recipe"> | boolean
    createdAt?: DateTimeFilter<"Recipe"> | Date | string
    updatedAt?: DateTimeFilter<"Recipe"> | Date | string
    productionTasks?: ProductionTaskListRelationFilter
  }

  export type RecipeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    cement?: SortOrder
    water?: SortOrder
    sand?: SortOrder
    gravel?: SortOrder
    additive?: SortOrder
    mixingTime?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productionTasks?: ProductionTaskOrderByRelationAggregateInput
  }

  export type RecipeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecipeWhereInput | RecipeWhereInput[]
    OR?: RecipeWhereInput[]
    NOT?: RecipeWhereInput | RecipeWhereInput[]
    name?: StringFilter<"Recipe"> | string
    cement?: FloatFilter<"Recipe"> | number
    water?: FloatFilter<"Recipe"> | number
    sand?: FloatFilter<"Recipe"> | number
    gravel?: FloatFilter<"Recipe"> | number
    additive?: FloatFilter<"Recipe"> | number
    mixingTime?: IntFilter<"Recipe"> | number
    enabled?: BoolFilter<"Recipe"> | boolean
    createdAt?: DateTimeFilter<"Recipe"> | Date | string
    updatedAt?: DateTimeFilter<"Recipe"> | Date | string
    productionTasks?: ProductionTaskListRelationFilter
  }, "id">

  export type RecipeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    cement?: SortOrder
    water?: SortOrder
    sand?: SortOrder
    gravel?: SortOrder
    additive?: SortOrder
    mixingTime?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RecipeCountOrderByAggregateInput
    _avg?: RecipeAvgOrderByAggregateInput
    _max?: RecipeMaxOrderByAggregateInput
    _min?: RecipeMinOrderByAggregateInput
    _sum?: RecipeSumOrderByAggregateInput
  }

  export type RecipeScalarWhereWithAggregatesInput = {
    AND?: RecipeScalarWhereWithAggregatesInput | RecipeScalarWhereWithAggregatesInput[]
    OR?: RecipeScalarWhereWithAggregatesInput[]
    NOT?: RecipeScalarWhereWithAggregatesInput | RecipeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Recipe"> | string
    name?: StringWithAggregatesFilter<"Recipe"> | string
    cement?: FloatWithAggregatesFilter<"Recipe"> | number
    water?: FloatWithAggregatesFilter<"Recipe"> | number
    sand?: FloatWithAggregatesFilter<"Recipe"> | number
    gravel?: FloatWithAggregatesFilter<"Recipe"> | number
    additive?: FloatWithAggregatesFilter<"Recipe"> | number
    mixingTime?: IntWithAggregatesFilter<"Recipe"> | number
    enabled?: BoolWithAggregatesFilter<"Recipe"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Recipe"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Recipe"> | Date | string
  }

  export type ProductionTaskWhereInput = {
    AND?: ProductionTaskWhereInput | ProductionTaskWhereInput[]
    OR?: ProductionTaskWhereInput[]
    NOT?: ProductionTaskWhereInput | ProductionTaskWhereInput[]
    id?: StringFilter<"ProductionTask"> | string
    recipeId?: StringFilter<"ProductionTask"> | string
    quantity?: FloatFilter<"ProductionTask"> | number
    priority?: IntFilter<"ProductionTask"> | number
    status?: StringFilter<"ProductionTask"> | string
    startTime?: DateTimeNullableFilter<"ProductionTask"> | Date | string | null
    endTime?: DateTimeNullableFilter<"ProductionTask"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductionTask"> | Date | string
    recipe?: XOR<RecipeRelationFilter, RecipeWhereInput>
    productionRecords?: ProductionRecordListRelationFilter
  }

  export type ProductionTaskOrderByWithRelationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    quantity?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    recipe?: RecipeOrderByWithRelationInput
    productionRecords?: ProductionRecordOrderByRelationAggregateInput
  }

  export type ProductionTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductionTaskWhereInput | ProductionTaskWhereInput[]
    OR?: ProductionTaskWhereInput[]
    NOT?: ProductionTaskWhereInput | ProductionTaskWhereInput[]
    recipeId?: StringFilter<"ProductionTask"> | string
    quantity?: FloatFilter<"ProductionTask"> | number
    priority?: IntFilter<"ProductionTask"> | number
    status?: StringFilter<"ProductionTask"> | string
    startTime?: DateTimeNullableFilter<"ProductionTask"> | Date | string | null
    endTime?: DateTimeNullableFilter<"ProductionTask"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductionTask"> | Date | string
    recipe?: XOR<RecipeRelationFilter, RecipeWhereInput>
    productionRecords?: ProductionRecordListRelationFilter
  }, "id">

  export type ProductionTaskOrderByWithAggregationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    quantity?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ProductionTaskCountOrderByAggregateInput
    _avg?: ProductionTaskAvgOrderByAggregateInput
    _max?: ProductionTaskMaxOrderByAggregateInput
    _min?: ProductionTaskMinOrderByAggregateInput
    _sum?: ProductionTaskSumOrderByAggregateInput
  }

  export type ProductionTaskScalarWhereWithAggregatesInput = {
    AND?: ProductionTaskScalarWhereWithAggregatesInput | ProductionTaskScalarWhereWithAggregatesInput[]
    OR?: ProductionTaskScalarWhereWithAggregatesInput[]
    NOT?: ProductionTaskScalarWhereWithAggregatesInput | ProductionTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductionTask"> | string
    recipeId?: StringWithAggregatesFilter<"ProductionTask"> | string
    quantity?: FloatWithAggregatesFilter<"ProductionTask"> | number
    priority?: IntWithAggregatesFilter<"ProductionTask"> | number
    status?: StringWithAggregatesFilter<"ProductionTask"> | string
    startTime?: DateTimeNullableWithAggregatesFilter<"ProductionTask"> | Date | string | null
    endTime?: DateTimeNullableWithAggregatesFilter<"ProductionTask"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductionTask"> | Date | string
  }

  export type ProductionRecordWhereInput = {
    AND?: ProductionRecordWhereInput | ProductionRecordWhereInput[]
    OR?: ProductionRecordWhereInput[]
    NOT?: ProductionRecordWhereInput | ProductionRecordWhereInput[]
    id?: StringFilter<"ProductionRecord"> | string
    taskId?: StringFilter<"ProductionRecord"> | string
    recipeId?: StringFilter<"ProductionRecord"> | string
    quantity?: FloatFilter<"ProductionRecord"> | number
    status?: StringFilter<"ProductionRecord"> | string
    startTime?: DateTimeFilter<"ProductionRecord"> | Date | string
    endTime?: DateTimeFilter<"ProductionRecord"> | Date | string
    createdAt?: DateTimeFilter<"ProductionRecord"> | Date | string
    task?: XOR<ProductionTaskRelationFilter, ProductionTaskWhereInput>
  }

  export type ProductionRecordOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    recipeId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    task?: ProductionTaskOrderByWithRelationInput
  }

  export type ProductionRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductionRecordWhereInput | ProductionRecordWhereInput[]
    OR?: ProductionRecordWhereInput[]
    NOT?: ProductionRecordWhereInput | ProductionRecordWhereInput[]
    taskId?: StringFilter<"ProductionRecord"> | string
    recipeId?: StringFilter<"ProductionRecord"> | string
    quantity?: FloatFilter<"ProductionRecord"> | number
    status?: StringFilter<"ProductionRecord"> | string
    startTime?: DateTimeFilter<"ProductionRecord"> | Date | string
    endTime?: DateTimeFilter<"ProductionRecord"> | Date | string
    createdAt?: DateTimeFilter<"ProductionRecord"> | Date | string
    task?: XOR<ProductionTaskRelationFilter, ProductionTaskWhereInput>
  }, "id">

  export type ProductionRecordOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    recipeId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    _count?: ProductionRecordCountOrderByAggregateInput
    _avg?: ProductionRecordAvgOrderByAggregateInput
    _max?: ProductionRecordMaxOrderByAggregateInput
    _min?: ProductionRecordMinOrderByAggregateInput
    _sum?: ProductionRecordSumOrderByAggregateInput
  }

  export type ProductionRecordScalarWhereWithAggregatesInput = {
    AND?: ProductionRecordScalarWhereWithAggregatesInput | ProductionRecordScalarWhereWithAggregatesInput[]
    OR?: ProductionRecordScalarWhereWithAggregatesInput[]
    NOT?: ProductionRecordScalarWhereWithAggregatesInput | ProductionRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductionRecord"> | string
    taskId?: StringWithAggregatesFilter<"ProductionRecord"> | string
    recipeId?: StringWithAggregatesFilter<"ProductionRecord"> | string
    quantity?: FloatWithAggregatesFilter<"ProductionRecord"> | number
    status?: StringWithAggregatesFilter<"ProductionRecord"> | string
    startTime?: DateTimeWithAggregatesFilter<"ProductionRecord"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"ProductionRecord"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"ProductionRecord"> | Date | string
  }

  export type AlarmWhereInput = {
    AND?: AlarmWhereInput | AlarmWhereInput[]
    OR?: AlarmWhereInput[]
    NOT?: AlarmWhereInput | AlarmWhereInput[]
    id?: StringFilter<"Alarm"> | string
    type?: StringFilter<"Alarm"> | string
    source?: StringFilter<"Alarm"> | string
    message?: StringFilter<"Alarm"> | string
    severity?: StringFilter<"Alarm"> | string
    status?: StringFilter<"Alarm"> | string
    data?: StringNullableFilter<"Alarm"> | string | null
    acknowledgedAt?: DateTimeNullableFilter<"Alarm"> | Date | string | null
    acknowledgedBy?: StringNullableFilter<"Alarm"> | string | null
    resolvedAt?: DateTimeNullableFilter<"Alarm"> | Date | string | null
    resolvedBy?: StringNullableFilter<"Alarm"> | string | null
    resolution?: StringNullableFilter<"Alarm"> | string | null
    createdAt?: DateTimeFilter<"Alarm"> | Date | string
  }

  export type AlarmOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    source?: SortOrder
    message?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    data?: SortOrderInput | SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    acknowledgedBy?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    resolution?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type AlarmWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AlarmWhereInput | AlarmWhereInput[]
    OR?: AlarmWhereInput[]
    NOT?: AlarmWhereInput | AlarmWhereInput[]
    type?: StringFilter<"Alarm"> | string
    source?: StringFilter<"Alarm"> | string
    message?: StringFilter<"Alarm"> | string
    severity?: StringFilter<"Alarm"> | string
    status?: StringFilter<"Alarm"> | string
    data?: StringNullableFilter<"Alarm"> | string | null
    acknowledgedAt?: DateTimeNullableFilter<"Alarm"> | Date | string | null
    acknowledgedBy?: StringNullableFilter<"Alarm"> | string | null
    resolvedAt?: DateTimeNullableFilter<"Alarm"> | Date | string | null
    resolvedBy?: StringNullableFilter<"Alarm"> | string | null
    resolution?: StringNullableFilter<"Alarm"> | string | null
    createdAt?: DateTimeFilter<"Alarm"> | Date | string
  }, "id">

  export type AlarmOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    source?: SortOrder
    message?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    data?: SortOrderInput | SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    acknowledgedBy?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    resolvedBy?: SortOrderInput | SortOrder
    resolution?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AlarmCountOrderByAggregateInput
    _max?: AlarmMaxOrderByAggregateInput
    _min?: AlarmMinOrderByAggregateInput
  }

  export type AlarmScalarWhereWithAggregatesInput = {
    AND?: AlarmScalarWhereWithAggregatesInput | AlarmScalarWhereWithAggregatesInput[]
    OR?: AlarmScalarWhereWithAggregatesInput[]
    NOT?: AlarmScalarWhereWithAggregatesInput | AlarmScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Alarm"> | string
    type?: StringWithAggregatesFilter<"Alarm"> | string
    source?: StringWithAggregatesFilter<"Alarm"> | string
    message?: StringWithAggregatesFilter<"Alarm"> | string
    severity?: StringWithAggregatesFilter<"Alarm"> | string
    status?: StringWithAggregatesFilter<"Alarm"> | string
    data?: StringNullableWithAggregatesFilter<"Alarm"> | string | null
    acknowledgedAt?: DateTimeNullableWithAggregatesFilter<"Alarm"> | Date | string | null
    acknowledgedBy?: StringNullableWithAggregatesFilter<"Alarm"> | string | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"Alarm"> | Date | string | null
    resolvedBy?: StringNullableWithAggregatesFilter<"Alarm"> | string | null
    resolution?: StringNullableWithAggregatesFilter<"Alarm"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Alarm"> | Date | string
  }

  export type SafetyEventWhereInput = {
    AND?: SafetyEventWhereInput | SafetyEventWhereInput[]
    OR?: SafetyEventWhereInput[]
    NOT?: SafetyEventWhereInput | SafetyEventWhereInput[]
    id?: StringFilter<"SafetyEvent"> | string
    type?: StringFilter<"SafetyEvent"> | string
    description?: StringFilter<"SafetyEvent"> | string
    severity?: StringFilter<"SafetyEvent"> | string
    data?: StringNullableFilter<"SafetyEvent"> | string | null
    createdAt?: DateTimeFilter<"SafetyEvent"> | Date | string
  }

  export type SafetyEventOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type SafetyEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SafetyEventWhereInput | SafetyEventWhereInput[]
    OR?: SafetyEventWhereInput[]
    NOT?: SafetyEventWhereInput | SafetyEventWhereInput[]
    type?: StringFilter<"SafetyEvent"> | string
    description?: StringFilter<"SafetyEvent"> | string
    severity?: StringFilter<"SafetyEvent"> | string
    data?: StringNullableFilter<"SafetyEvent"> | string | null
    createdAt?: DateTimeFilter<"SafetyEvent"> | Date | string
  }, "id">

  export type SafetyEventOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SafetyEventCountOrderByAggregateInput
    _max?: SafetyEventMaxOrderByAggregateInput
    _min?: SafetyEventMinOrderByAggregateInput
  }

  export type SafetyEventScalarWhereWithAggregatesInput = {
    AND?: SafetyEventScalarWhereWithAggregatesInput | SafetyEventScalarWhereWithAggregatesInput[]
    OR?: SafetyEventScalarWhereWithAggregatesInput[]
    NOT?: SafetyEventScalarWhereWithAggregatesInput | SafetyEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SafetyEvent"> | string
    type?: StringWithAggregatesFilter<"SafetyEvent"> | string
    description?: StringWithAggregatesFilter<"SafetyEvent"> | string
    severity?: StringWithAggregatesFilter<"SafetyEvent"> | string
    data?: StringNullableWithAggregatesFilter<"SafetyEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SafetyEvent"> | Date | string
  }

  export type SafetyRuleWhereInput = {
    AND?: SafetyRuleWhereInput | SafetyRuleWhereInput[]
    OR?: SafetyRuleWhereInput[]
    NOT?: SafetyRuleWhereInput | SafetyRuleWhereInput[]
    id?: StringFilter<"SafetyRule"> | string
    name?: StringFilter<"SafetyRule"> | string
    type?: StringFilter<"SafetyRule"> | string
    condition?: StringFilter<"SafetyRule"> | string
    threshold?: FloatFilter<"SafetyRule"> | number
    action?: StringFilter<"SafetyRule"> | string
    enabled?: BoolFilter<"SafetyRule"> | boolean
    createdAt?: DateTimeFilter<"SafetyRule"> | Date | string
    updatedAt?: DateTimeFilter<"SafetyRule"> | Date | string
  }

  export type SafetyRuleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    condition?: SortOrder
    threshold?: SortOrder
    action?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SafetyRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SafetyRuleWhereInput | SafetyRuleWhereInput[]
    OR?: SafetyRuleWhereInput[]
    NOT?: SafetyRuleWhereInput | SafetyRuleWhereInput[]
    name?: StringFilter<"SafetyRule"> | string
    type?: StringFilter<"SafetyRule"> | string
    condition?: StringFilter<"SafetyRule"> | string
    threshold?: FloatFilter<"SafetyRule"> | number
    action?: StringFilter<"SafetyRule"> | string
    enabled?: BoolFilter<"SafetyRule"> | boolean
    createdAt?: DateTimeFilter<"SafetyRule"> | Date | string
    updatedAt?: DateTimeFilter<"SafetyRule"> | Date | string
  }, "id">

  export type SafetyRuleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    condition?: SortOrder
    threshold?: SortOrder
    action?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SafetyRuleCountOrderByAggregateInput
    _avg?: SafetyRuleAvgOrderByAggregateInput
    _max?: SafetyRuleMaxOrderByAggregateInput
    _min?: SafetyRuleMinOrderByAggregateInput
    _sum?: SafetyRuleSumOrderByAggregateInput
  }

  export type SafetyRuleScalarWhereWithAggregatesInput = {
    AND?: SafetyRuleScalarWhereWithAggregatesInput | SafetyRuleScalarWhereWithAggregatesInput[]
    OR?: SafetyRuleScalarWhereWithAggregatesInput[]
    NOT?: SafetyRuleScalarWhereWithAggregatesInput | SafetyRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SafetyRule"> | string
    name?: StringWithAggregatesFilter<"SafetyRule"> | string
    type?: StringWithAggregatesFilter<"SafetyRule"> | string
    condition?: StringWithAggregatesFilter<"SafetyRule"> | string
    threshold?: FloatWithAggregatesFilter<"SafetyRule"> | number
    action?: StringWithAggregatesFilter<"SafetyRule"> | string
    enabled?: BoolWithAggregatesFilter<"SafetyRule"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SafetyRule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SafetyRule"> | Date | string
  }

  export type SystemMetricsWhereInput = {
    AND?: SystemMetricsWhereInput | SystemMetricsWhereInput[]
    OR?: SystemMetricsWhereInput[]
    NOT?: SystemMetricsWhereInput | SystemMetricsWhereInput[]
    id?: StringFilter<"SystemMetrics"> | string
    type?: StringFilter<"SystemMetrics"> | string
    data?: StringFilter<"SystemMetrics"> | string
    timestamp?: DateTimeFilter<"SystemMetrics"> | Date | string
  }

  export type SystemMetricsOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrder
    timestamp?: SortOrder
  }

  export type SystemMetricsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemMetricsWhereInput | SystemMetricsWhereInput[]
    OR?: SystemMetricsWhereInput[]
    NOT?: SystemMetricsWhereInput | SystemMetricsWhereInput[]
    type?: StringFilter<"SystemMetrics"> | string
    data?: StringFilter<"SystemMetrics"> | string
    timestamp?: DateTimeFilter<"SystemMetrics"> | Date | string
  }, "id">

  export type SystemMetricsOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrder
    timestamp?: SortOrder
    _count?: SystemMetricsCountOrderByAggregateInput
    _max?: SystemMetricsMaxOrderByAggregateInput
    _min?: SystemMetricsMinOrderByAggregateInput
  }

  export type SystemMetricsScalarWhereWithAggregatesInput = {
    AND?: SystemMetricsScalarWhereWithAggregatesInput | SystemMetricsScalarWhereWithAggregatesInput[]
    OR?: SystemMetricsScalarWhereWithAggregatesInput[]
    NOT?: SystemMetricsScalarWhereWithAggregatesInput | SystemMetricsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemMetrics"> | string
    type?: StringWithAggregatesFilter<"SystemMetrics"> | string
    data?: StringWithAggregatesFilter<"SystemMetrics"> | string
    timestamp?: DateTimeWithAggregatesFilter<"SystemMetrics"> | Date | string
  }

  export type EquipmentRuntimeWhereInput = {
    AND?: EquipmentRuntimeWhereInput | EquipmentRuntimeWhereInput[]
    OR?: EquipmentRuntimeWhereInput[]
    NOT?: EquipmentRuntimeWhereInput | EquipmentRuntimeWhereInput[]
    id?: StringFilter<"EquipmentRuntime"> | string
    equipmentName?: StringFilter<"EquipmentRuntime"> | string
    runtime?: FloatFilter<"EquipmentRuntime"> | number
    date?: DateTimeFilter<"EquipmentRuntime"> | Date | string
    createdAt?: DateTimeFilter<"EquipmentRuntime"> | Date | string
  }

  export type EquipmentRuntimeOrderByWithRelationInput = {
    id?: SortOrder
    equipmentName?: SortOrder
    runtime?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
  }

  export type EquipmentRuntimeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    equipmentName_date?: EquipmentRuntimeEquipmentNameDateCompoundUniqueInput
    AND?: EquipmentRuntimeWhereInput | EquipmentRuntimeWhereInput[]
    OR?: EquipmentRuntimeWhereInput[]
    NOT?: EquipmentRuntimeWhereInput | EquipmentRuntimeWhereInput[]
    equipmentName?: StringFilter<"EquipmentRuntime"> | string
    runtime?: FloatFilter<"EquipmentRuntime"> | number
    date?: DateTimeFilter<"EquipmentRuntime"> | Date | string
    createdAt?: DateTimeFilter<"EquipmentRuntime"> | Date | string
  }, "id" | "equipmentName_date">

  export type EquipmentRuntimeOrderByWithAggregationInput = {
    id?: SortOrder
    equipmentName?: SortOrder
    runtime?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    _count?: EquipmentRuntimeCountOrderByAggregateInput
    _avg?: EquipmentRuntimeAvgOrderByAggregateInput
    _max?: EquipmentRuntimeMaxOrderByAggregateInput
    _min?: EquipmentRuntimeMinOrderByAggregateInput
    _sum?: EquipmentRuntimeSumOrderByAggregateInput
  }

  export type EquipmentRuntimeScalarWhereWithAggregatesInput = {
    AND?: EquipmentRuntimeScalarWhereWithAggregatesInput | EquipmentRuntimeScalarWhereWithAggregatesInput[]
    OR?: EquipmentRuntimeScalarWhereWithAggregatesInput[]
    NOT?: EquipmentRuntimeScalarWhereWithAggregatesInput | EquipmentRuntimeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EquipmentRuntime"> | string
    equipmentName?: StringWithAggregatesFilter<"EquipmentRuntime"> | string
    runtime?: FloatWithAggregatesFilter<"EquipmentRuntime"> | number
    date?: DateTimeWithAggregatesFilter<"EquipmentRuntime"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"EquipmentRuntime"> | Date | string
  }

  export type SystemStatusWhereInput = {
    AND?: SystemStatusWhereInput | SystemStatusWhereInput[]
    OR?: SystemStatusWhereInput[]
    NOT?: SystemStatusWhereInput | SystemStatusWhereInput[]
    id?: IntFilter<"SystemStatus"> | number
    cpuUsage?: FloatFilter<"SystemStatus"> | number
    memoryUsage?: FloatFilter<"SystemStatus"> | number
    diskUsage?: FloatFilter<"SystemStatus"> | number
    temperature?: FloatNullableFilter<"SystemStatus"> | number | null
    uptime?: IntFilter<"SystemStatus"> | number
    timestamp?: DateTimeFilter<"SystemStatus"> | Date | string
  }

  export type SystemStatusOrderByWithRelationInput = {
    id?: SortOrder
    cpuUsage?: SortOrder
    memoryUsage?: SortOrder
    diskUsage?: SortOrder
    temperature?: SortOrderInput | SortOrder
    uptime?: SortOrder
    timestamp?: SortOrder
  }

  export type SystemStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SystemStatusWhereInput | SystemStatusWhereInput[]
    OR?: SystemStatusWhereInput[]
    NOT?: SystemStatusWhereInput | SystemStatusWhereInput[]
    cpuUsage?: FloatFilter<"SystemStatus"> | number
    memoryUsage?: FloatFilter<"SystemStatus"> | number
    diskUsage?: FloatFilter<"SystemStatus"> | number
    temperature?: FloatNullableFilter<"SystemStatus"> | number | null
    uptime?: IntFilter<"SystemStatus"> | number
    timestamp?: DateTimeFilter<"SystemStatus"> | Date | string
  }, "id">

  export type SystemStatusOrderByWithAggregationInput = {
    id?: SortOrder
    cpuUsage?: SortOrder
    memoryUsage?: SortOrder
    diskUsage?: SortOrder
    temperature?: SortOrderInput | SortOrder
    uptime?: SortOrder
    timestamp?: SortOrder
    _count?: SystemStatusCountOrderByAggregateInput
    _avg?: SystemStatusAvgOrderByAggregateInput
    _max?: SystemStatusMaxOrderByAggregateInput
    _min?: SystemStatusMinOrderByAggregateInput
    _sum?: SystemStatusSumOrderByAggregateInput
  }

  export type SystemStatusScalarWhereWithAggregatesInput = {
    AND?: SystemStatusScalarWhereWithAggregatesInput | SystemStatusScalarWhereWithAggregatesInput[]
    OR?: SystemStatusScalarWhereWithAggregatesInput[]
    NOT?: SystemStatusScalarWhereWithAggregatesInput | SystemStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SystemStatus"> | number
    cpuUsage?: FloatWithAggregatesFilter<"SystemStatus"> | number
    memoryUsage?: FloatWithAggregatesFilter<"SystemStatus"> | number
    diskUsage?: FloatWithAggregatesFilter<"SystemStatus"> | number
    temperature?: FloatNullableWithAggregatesFilter<"SystemStatus"> | number | null
    uptime?: IntWithAggregatesFilter<"SystemStatus"> | number
    timestamp?: DateTimeWithAggregatesFilter<"SystemStatus"> | Date | string
  }

  export type DeviceStatsWhereInput = {
    AND?: DeviceStatsWhereInput | DeviceStatsWhereInput[]
    OR?: DeviceStatsWhereInput[]
    NOT?: DeviceStatsWhereInput | DeviceStatsWhereInput[]
    id?: IntFilter<"DeviceStats"> | number
    deviceId?: StringFilter<"DeviceStats"> | string
    connectTime?: IntFilter<"DeviceStats"> | number
    disconnectTime?: IntFilter<"DeviceStats"> | number
    errorCount?: IntFilter<"DeviceStats"> | number
    dataPointCount?: IntFilter<"DeviceStats"> | number
    lastUpdate?: DateTimeFilter<"DeviceStats"> | Date | string
    date?: StringFilter<"DeviceStats"> | string
  }

  export type DeviceStatsOrderByWithRelationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    connectTime?: SortOrder
    disconnectTime?: SortOrder
    errorCount?: SortOrder
    dataPointCount?: SortOrder
    lastUpdate?: SortOrder
    date?: SortOrder
  }

  export type DeviceStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    deviceId_date?: DeviceStatsDeviceIdDateCompoundUniqueInput
    AND?: DeviceStatsWhereInput | DeviceStatsWhereInput[]
    OR?: DeviceStatsWhereInput[]
    NOT?: DeviceStatsWhereInput | DeviceStatsWhereInput[]
    deviceId?: StringFilter<"DeviceStats"> | string
    connectTime?: IntFilter<"DeviceStats"> | number
    disconnectTime?: IntFilter<"DeviceStats"> | number
    errorCount?: IntFilter<"DeviceStats"> | number
    dataPointCount?: IntFilter<"DeviceStats"> | number
    lastUpdate?: DateTimeFilter<"DeviceStats"> | Date | string
    date?: StringFilter<"DeviceStats"> | string
  }, "id" | "deviceId_date">

  export type DeviceStatsOrderByWithAggregationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    connectTime?: SortOrder
    disconnectTime?: SortOrder
    errorCount?: SortOrder
    dataPointCount?: SortOrder
    lastUpdate?: SortOrder
    date?: SortOrder
    _count?: DeviceStatsCountOrderByAggregateInput
    _avg?: DeviceStatsAvgOrderByAggregateInput
    _max?: DeviceStatsMaxOrderByAggregateInput
    _min?: DeviceStatsMinOrderByAggregateInput
    _sum?: DeviceStatsSumOrderByAggregateInput
  }

  export type DeviceStatsScalarWhereWithAggregatesInput = {
    AND?: DeviceStatsScalarWhereWithAggregatesInput | DeviceStatsScalarWhereWithAggregatesInput[]
    OR?: DeviceStatsScalarWhereWithAggregatesInput[]
    NOT?: DeviceStatsScalarWhereWithAggregatesInput | DeviceStatsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DeviceStats"> | number
    deviceId?: StringWithAggregatesFilter<"DeviceStats"> | string
    connectTime?: IntWithAggregatesFilter<"DeviceStats"> | number
    disconnectTime?: IntWithAggregatesFilter<"DeviceStats"> | number
    errorCount?: IntWithAggregatesFilter<"DeviceStats"> | number
    dataPointCount?: IntWithAggregatesFilter<"DeviceStats"> | number
    lastUpdate?: DateTimeWithAggregatesFilter<"DeviceStats"> | Date | string
    date?: StringWithAggregatesFilter<"DeviceStats"> | string
  }

  export type EdgeConfigCreateInput = {
    key: string
    value: string
    description?: string | null
    updatedAt?: Date | string
  }

  export type EdgeConfigUncheckedCreateInput = {
    id?: number
    key: string
    value: string
    description?: string | null
    updatedAt?: Date | string
  }

  export type EdgeConfigUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EdgeConfigUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EdgeConfigCreateManyInput = {
    id?: number
    key: string
    value: string
    description?: string | null
    updatedAt?: Date | string
  }

  export type EdgeConfigUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EdgeConfigUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceConnectionCreateInput = {
    deviceType: string
    deviceId: string
    host: string
    port?: number | null
    status?: string
    lastConnect?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceConnectionUncheckedCreateInput = {
    id?: number
    deviceType: string
    deviceId: string
    host: string
    port?: number | null
    status?: string
    lastConnect?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceConnectionUpdateInput = {
    deviceType?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    lastConnect?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceConnectionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    deviceType?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    lastConnect?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceConnectionCreateManyInput = {
    id?: number
    deviceType: string
    deviceId: string
    host: string
    port?: number | null
    status?: string
    lastConnect?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceConnectionUpdateManyMutationInput = {
    deviceType?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    lastConnect?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceConnectionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    deviceType?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    lastConnect?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataPointCreateInput = {
    tagName: string
    deviceId: string
    address: string
    dataType: string
    value: string
    quality?: string
    timestamp?: Date | string
    description?: string | null
    history?: DataHistoryCreateNestedManyWithoutDataPointInput
  }

  export type DataPointUncheckedCreateInput = {
    id?: number
    tagName: string
    deviceId: string
    address: string
    dataType: string
    value: string
    quality?: string
    timestamp?: Date | string
    description?: string | null
    history?: DataHistoryUncheckedCreateNestedManyWithoutDataPointInput
  }

  export type DataPointUpdateInput = {
    tagName?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    history?: DataHistoryUpdateManyWithoutDataPointNestedInput
  }

  export type DataPointUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tagName?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    history?: DataHistoryUncheckedUpdateManyWithoutDataPointNestedInput
  }

  export type DataPointCreateManyInput = {
    id?: number
    tagName: string
    deviceId: string
    address: string
    dataType: string
    value: string
    quality?: string
    timestamp?: Date | string
    description?: string | null
  }

  export type DataPointUpdateManyMutationInput = {
    tagName?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DataPointUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tagName?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DataHistoryCreateInput = {
    value: string
    quality?: string
    timestamp?: Date | string
    dataPoint: DataPointCreateNestedOneWithoutHistoryInput
  }

  export type DataHistoryUncheckedCreateInput = {
    id?: number
    pointId: number
    value: string
    quality?: string
    timestamp?: Date | string
  }

  export type DataHistoryUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    dataPoint?: DataPointUpdateOneRequiredWithoutHistoryNestedInput
  }

  export type DataHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pointId?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataHistoryCreateManyInput = {
    id?: number
    pointId: number
    value: string
    quality?: string
    timestamp?: Date | string
  }

  export type DataHistoryUpdateManyMutationInput = {
    value?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pointId?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalRecipeCreateInput = {
    name: string
    concreteGrade: string
    version?: string
    isActive?: boolean
    recipeData: string
    syncStatus?: string
    remoteId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: LocalBatchCreateNestedManyWithoutRecipeInput
  }

  export type LocalRecipeUncheckedCreateInput = {
    id?: number
    name: string
    concreteGrade: string
    version?: string
    isActive?: boolean
    recipeData: string
    syncStatus?: string
    remoteId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    batches?: LocalBatchUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type LocalRecipeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    concreteGrade?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    recipeData?: StringFieldUpdateOperationsInput | string
    syncStatus?: StringFieldUpdateOperationsInput | string
    remoteId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: LocalBatchUpdateManyWithoutRecipeNestedInput
  }

  export type LocalRecipeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    concreteGrade?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    recipeData?: StringFieldUpdateOperationsInput | string
    syncStatus?: StringFieldUpdateOperationsInput | string
    remoteId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: LocalBatchUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type LocalRecipeCreateManyInput = {
    id?: number
    name: string
    concreteGrade: string
    version?: string
    isActive?: boolean
    recipeData: string
    syncStatus?: string
    remoteId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocalRecipeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    concreteGrade?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    recipeData?: StringFieldUpdateOperationsInput | string
    syncStatus?: StringFieldUpdateOperationsInput | string
    remoteId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalRecipeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    concreteGrade?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    recipeData?: StringFieldUpdateOperationsInput | string
    syncStatus?: StringFieldUpdateOperationsInput | string
    remoteId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalBatchCreateInput = {
    batchNumber: string
    volume: number
    status?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    operatorName?: string | null
    syncStatus?: string
    remoteId?: number | null
    createdAt?: Date | string
    recipe: LocalRecipeCreateNestedOneWithoutBatchesInput
    batchingRecords?: LocalBatchingRecordCreateNestedManyWithoutBatchInput
  }

  export type LocalBatchUncheckedCreateInput = {
    id?: number
    batchNumber: string
    recipeId: number
    volume: number
    status?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    operatorName?: string | null
    syncStatus?: string
    remoteId?: number | null
    createdAt?: Date | string
    batchingRecords?: LocalBatchingRecordUncheckedCreateNestedManyWithoutBatchInput
  }

  export type LocalBatchUpdateInput = {
    batchNumber?: StringFieldUpdateOperationsInput | string
    volume?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operatorName?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: StringFieldUpdateOperationsInput | string
    remoteId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipe?: LocalRecipeUpdateOneRequiredWithoutBatchesNestedInput
    batchingRecords?: LocalBatchingRecordUpdateManyWithoutBatchNestedInput
  }

  export type LocalBatchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    batchNumber?: StringFieldUpdateOperationsInput | string
    recipeId?: IntFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operatorName?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: StringFieldUpdateOperationsInput | string
    remoteId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batchingRecords?: LocalBatchingRecordUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type LocalBatchCreateManyInput = {
    id?: number
    batchNumber: string
    recipeId: number
    volume: number
    status?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    operatorName?: string | null
    syncStatus?: string
    remoteId?: number | null
    createdAt?: Date | string
  }

  export type LocalBatchUpdateManyMutationInput = {
    batchNumber?: StringFieldUpdateOperationsInput | string
    volume?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operatorName?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: StringFieldUpdateOperationsInput | string
    remoteId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalBatchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    batchNumber?: StringFieldUpdateOperationsInput | string
    recipeId?: IntFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operatorName?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: StringFieldUpdateOperationsInput | string
    remoteId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalBatchingRecordCreateInput = {
    materialName: string
    targetWeight: number
    actualWeight: number
    deviation?: number | null
    toleranceCheck?: string
    timestamp?: Date | string
    batch: LocalBatchCreateNestedOneWithoutBatchingRecordsInput
  }

  export type LocalBatchingRecordUncheckedCreateInput = {
    id?: number
    batchId: number
    materialName: string
    targetWeight: number
    actualWeight: number
    deviation?: number | null
    toleranceCheck?: string
    timestamp?: Date | string
  }

  export type LocalBatchingRecordUpdateInput = {
    materialName?: StringFieldUpdateOperationsInput | string
    targetWeight?: FloatFieldUpdateOperationsInput | number
    actualWeight?: FloatFieldUpdateOperationsInput | number
    deviation?: NullableFloatFieldUpdateOperationsInput | number | null
    toleranceCheck?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: LocalBatchUpdateOneRequiredWithoutBatchingRecordsNestedInput
  }

  export type LocalBatchingRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    batchId?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    targetWeight?: FloatFieldUpdateOperationsInput | number
    actualWeight?: FloatFieldUpdateOperationsInput | number
    deviation?: NullableFloatFieldUpdateOperationsInput | number | null
    toleranceCheck?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalBatchingRecordCreateManyInput = {
    id?: number
    batchId: number
    materialName: string
    targetWeight: number
    actualWeight: number
    deviation?: number | null
    toleranceCheck?: string
    timestamp?: Date | string
  }

  export type LocalBatchingRecordUpdateManyMutationInput = {
    materialName?: StringFieldUpdateOperationsInput | string
    targetWeight?: FloatFieldUpdateOperationsInput | number
    actualWeight?: FloatFieldUpdateOperationsInput | number
    deviation?: NullableFloatFieldUpdateOperationsInput | number | null
    toleranceCheck?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalBatchingRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    batchId?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    targetWeight?: FloatFieldUpdateOperationsInput | number
    actualWeight?: FloatFieldUpdateOperationsInput | number
    deviation?: NullableFloatFieldUpdateOperationsInput | number | null
    toleranceCheck?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalAlarmCreateInput = {
    alarmType: string
    source: string
    message: string
    severity: string
    acknowledged?: boolean
    resolved?: boolean
    syncStatus?: string
    remoteId?: number | null
    timestamp?: Date | string
    resolvedAt?: Date | string | null
  }

  export type LocalAlarmUncheckedCreateInput = {
    id?: number
    alarmType: string
    source: string
    message: string
    severity: string
    acknowledged?: boolean
    resolved?: boolean
    syncStatus?: string
    remoteId?: number | null
    timestamp?: Date | string
    resolvedAt?: Date | string | null
  }

  export type LocalAlarmUpdateInput = {
    alarmType?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    resolved?: BoolFieldUpdateOperationsInput | boolean
    syncStatus?: StringFieldUpdateOperationsInput | string
    remoteId?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LocalAlarmUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    alarmType?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    resolved?: BoolFieldUpdateOperationsInput | boolean
    syncStatus?: StringFieldUpdateOperationsInput | string
    remoteId?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LocalAlarmCreateManyInput = {
    id?: number
    alarmType: string
    source: string
    message: string
    severity: string
    acknowledged?: boolean
    resolved?: boolean
    syncStatus?: string
    remoteId?: number | null
    timestamp?: Date | string
    resolvedAt?: Date | string | null
  }

  export type LocalAlarmUpdateManyMutationInput = {
    alarmType?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    resolved?: BoolFieldUpdateOperationsInput | boolean
    syncStatus?: StringFieldUpdateOperationsInput | string
    remoteId?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LocalAlarmUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    alarmType?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    resolved?: BoolFieldUpdateOperationsInput | boolean
    syncStatus?: StringFieldUpdateOperationsInput | string
    remoteId?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LocalLogCreateInput = {
    level: string
    module: string
    action: string
    message: string
    data?: string | null
    syncStatus?: string
    timestamp?: Date | string
  }

  export type LocalLogUncheckedCreateInput = {
    id?: number
    level: string
    module: string
    action: string
    message: string
    data?: string | null
    syncStatus?: string
    timestamp?: Date | string
  }

  export type LocalLogUpdateInput = {
    level?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalLogCreateManyInput = {
    id?: number
    level: string
    module: string
    action: string
    message: string
    data?: string | null
    syncStatus?: string
    timestamp?: Date | string
  }

  export type LocalLogUpdateManyMutationInput = {
    level?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncQueueCreateInput = {
    type: string
    data: string
    status?: string
    retryCount?: number
    lastError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SyncQueueUncheckedCreateInput = {
    id?: number
    type: string
    data: string
    status?: string
    retryCount?: number
    lastError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SyncQueueUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    retryCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncQueueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    retryCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncQueueCreateManyInput = {
    id?: number
    type: string
    data: string
    status?: string
    retryCount?: number
    lastError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SyncQueueUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    retryCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncQueueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    retryCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncStatusCreateInput = {
    type: string
    status: string
    lastSync?: Date | string | null
    lastError?: string | null
    syncCount?: number
    errorCount?: number
    updatedAt?: Date | string
  }

  export type SyncStatusUncheckedCreateInput = {
    id?: number
    type: string
    status: string
    lastSync?: Date | string | null
    lastError?: string | null
    syncCount?: number
    errorCount?: number
    updatedAt?: Date | string
  }

  export type SyncStatusUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    syncCount?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    syncCount?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncStatusCreateManyInput = {
    id?: number
    type: string
    status: string
    lastSync?: Date | string | null
    lastError?: string | null
    syncCount?: number
    errorCount?: number
    updatedAt?: Date | string
  }

  export type SyncStatusUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    syncCount?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SyncStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    syncCount?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipeCreateInput = {
    id?: string
    name: string
    cement: number
    water: number
    sand: number
    gravel: number
    additive: number
    mixingTime: number
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    productionTasks?: ProductionTaskCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateInput = {
    id?: string
    name: string
    cement: number
    water: number
    sand: number
    gravel: number
    additive: number
    mixingTime: number
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    productionTasks?: ProductionTaskUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cement?: FloatFieldUpdateOperationsInput | number
    water?: FloatFieldUpdateOperationsInput | number
    sand?: FloatFieldUpdateOperationsInput | number
    gravel?: FloatFieldUpdateOperationsInput | number
    additive?: FloatFieldUpdateOperationsInput | number
    mixingTime?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionTasks?: ProductionTaskUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cement?: FloatFieldUpdateOperationsInput | number
    water?: FloatFieldUpdateOperationsInput | number
    sand?: FloatFieldUpdateOperationsInput | number
    gravel?: FloatFieldUpdateOperationsInput | number
    additive?: FloatFieldUpdateOperationsInput | number
    mixingTime?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionTasks?: ProductionTaskUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeCreateManyInput = {
    id?: string
    name: string
    cement: number
    water: number
    sand: number
    gravel: number
    additive: number
    mixingTime: number
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecipeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cement?: FloatFieldUpdateOperationsInput | number
    water?: FloatFieldUpdateOperationsInput | number
    sand?: FloatFieldUpdateOperationsInput | number
    gravel?: FloatFieldUpdateOperationsInput | number
    additive?: FloatFieldUpdateOperationsInput | number
    mixingTime?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cement?: FloatFieldUpdateOperationsInput | number
    water?: FloatFieldUpdateOperationsInput | number
    sand?: FloatFieldUpdateOperationsInput | number
    gravel?: FloatFieldUpdateOperationsInput | number
    additive?: FloatFieldUpdateOperationsInput | number
    mixingTime?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionTaskCreateInput = {
    id?: string
    quantity: number
    priority?: number
    status?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
    recipe: RecipeCreateNestedOneWithoutProductionTasksInput
    productionRecords?: ProductionRecordCreateNestedManyWithoutTaskInput
  }

  export type ProductionTaskUncheckedCreateInput = {
    id?: string
    recipeId: string
    quantity: number
    priority?: number
    status?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
    productionRecords?: ProductionRecordUncheckedCreateNestedManyWithoutTaskInput
  }

  export type ProductionTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipe?: RecipeUpdateOneRequiredWithoutProductionTasksNestedInput
    productionRecords?: ProductionRecordUpdateManyWithoutTaskNestedInput
  }

  export type ProductionTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionRecords?: ProductionRecordUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type ProductionTaskCreateManyInput = {
    id?: string
    recipeId: string
    quantity: number
    priority?: number
    status?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
  }

  export type ProductionTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionRecordCreateInput = {
    id?: string
    recipeId: string
    quantity: number
    status: string
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    task: ProductionTaskCreateNestedOneWithoutProductionRecordsInput
  }

  export type ProductionRecordUncheckedCreateInput = {
    id?: string
    taskId: string
    recipeId: string
    quantity: number
    status: string
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
  }

  export type ProductionRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: ProductionTaskUpdateOneRequiredWithoutProductionRecordsNestedInput
  }

  export type ProductionRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionRecordCreateManyInput = {
    id?: string
    taskId: string
    recipeId: string
    quantity: number
    status: string
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
  }

  export type ProductionRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlarmCreateInput = {
    id?: string
    type: string
    source: string
    message: string
    severity: string
    status?: string
    data?: string | null
    acknowledgedAt?: Date | string | null
    acknowledgedBy?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    resolution?: string | null
    createdAt?: Date | string
  }

  export type AlarmUncheckedCreateInput = {
    id?: string
    type: string
    source: string
    message: string
    severity: string
    status?: string
    data?: string | null
    acknowledgedAt?: Date | string | null
    acknowledgedBy?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    resolution?: string | null
    createdAt?: Date | string
  }

  export type AlarmUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlarmUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlarmCreateManyInput = {
    id?: string
    type: string
    source: string
    message: string
    severity: string
    status?: string
    data?: string | null
    acknowledgedAt?: Date | string | null
    acknowledgedBy?: string | null
    resolvedAt?: Date | string | null
    resolvedBy?: string | null
    resolution?: string | null
    createdAt?: Date | string
  }

  export type AlarmUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlarmUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SafetyEventCreateInput = {
    id?: string
    type: string
    description: string
    severity: string
    data?: string | null
    createdAt?: Date | string
  }

  export type SafetyEventUncheckedCreateInput = {
    id?: string
    type: string
    description: string
    severity: string
    data?: string | null
    createdAt?: Date | string
  }

  export type SafetyEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SafetyEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SafetyEventCreateManyInput = {
    id?: string
    type: string
    description: string
    severity: string
    data?: string | null
    createdAt?: Date | string
  }

  export type SafetyEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SafetyEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SafetyRuleCreateInput = {
    id?: string
    name: string
    type: string
    condition: string
    threshold: number
    action: string
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SafetyRuleUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    condition: string
    threshold: number
    action: string
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SafetyRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    condition?: StringFieldUpdateOperationsInput | string
    threshold?: FloatFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SafetyRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    condition?: StringFieldUpdateOperationsInput | string
    threshold?: FloatFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SafetyRuleCreateManyInput = {
    id?: string
    name: string
    type: string
    condition: string
    threshold: number
    action: string
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SafetyRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    condition?: StringFieldUpdateOperationsInput | string
    threshold?: FloatFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SafetyRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    condition?: StringFieldUpdateOperationsInput | string
    threshold?: FloatFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemMetricsCreateInput = {
    id?: string
    type: string
    data: string
    timestamp?: Date | string
  }

  export type SystemMetricsUncheckedCreateInput = {
    id?: string
    type: string
    data: string
    timestamp?: Date | string
  }

  export type SystemMetricsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemMetricsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemMetricsCreateManyInput = {
    id?: string
    type: string
    data: string
    timestamp?: Date | string
  }

  export type SystemMetricsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemMetricsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentRuntimeCreateInput = {
    id?: string
    equipmentName: string
    runtime: number
    date: Date | string
    createdAt?: Date | string
  }

  export type EquipmentRuntimeUncheckedCreateInput = {
    id?: string
    equipmentName: string
    runtime: number
    date: Date | string
    createdAt?: Date | string
  }

  export type EquipmentRuntimeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentName?: StringFieldUpdateOperationsInput | string
    runtime?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentRuntimeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentName?: StringFieldUpdateOperationsInput | string
    runtime?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentRuntimeCreateManyInput = {
    id?: string
    equipmentName: string
    runtime: number
    date: Date | string
    createdAt?: Date | string
  }

  export type EquipmentRuntimeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentName?: StringFieldUpdateOperationsInput | string
    runtime?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentRuntimeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentName?: StringFieldUpdateOperationsInput | string
    runtime?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemStatusCreateInput = {
    cpuUsage: number
    memoryUsage: number
    diskUsage: number
    temperature?: number | null
    uptime: number
    timestamp?: Date | string
  }

  export type SystemStatusUncheckedCreateInput = {
    id?: number
    cpuUsage: number
    memoryUsage: number
    diskUsage: number
    temperature?: number | null
    uptime: number
    timestamp?: Date | string
  }

  export type SystemStatusUpdateInput = {
    cpuUsage?: FloatFieldUpdateOperationsInput | number
    memoryUsage?: FloatFieldUpdateOperationsInput | number
    diskUsage?: FloatFieldUpdateOperationsInput | number
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    uptime?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cpuUsage?: FloatFieldUpdateOperationsInput | number
    memoryUsage?: FloatFieldUpdateOperationsInput | number
    diskUsage?: FloatFieldUpdateOperationsInput | number
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    uptime?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemStatusCreateManyInput = {
    id?: number
    cpuUsage: number
    memoryUsage: number
    diskUsage: number
    temperature?: number | null
    uptime: number
    timestamp?: Date | string
  }

  export type SystemStatusUpdateManyMutationInput = {
    cpuUsage?: FloatFieldUpdateOperationsInput | number
    memoryUsage?: FloatFieldUpdateOperationsInput | number
    diskUsage?: FloatFieldUpdateOperationsInput | number
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    uptime?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cpuUsage?: FloatFieldUpdateOperationsInput | number
    memoryUsage?: FloatFieldUpdateOperationsInput | number
    diskUsage?: FloatFieldUpdateOperationsInput | number
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    uptime?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceStatsCreateInput = {
    deviceId: string
    connectTime?: number
    disconnectTime?: number
    errorCount?: number
    dataPointCount?: number
    lastUpdate?: Date | string
    date: string
  }

  export type DeviceStatsUncheckedCreateInput = {
    id?: number
    deviceId: string
    connectTime?: number
    disconnectTime?: number
    errorCount?: number
    dataPointCount?: number
    lastUpdate?: Date | string
    date: string
  }

  export type DeviceStatsUpdateInput = {
    deviceId?: StringFieldUpdateOperationsInput | string
    connectTime?: IntFieldUpdateOperationsInput | number
    disconnectTime?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    dataPointCount?: IntFieldUpdateOperationsInput | number
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceStatsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    deviceId?: StringFieldUpdateOperationsInput | string
    connectTime?: IntFieldUpdateOperationsInput | number
    disconnectTime?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    dataPointCount?: IntFieldUpdateOperationsInput | number
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceStatsCreateManyInput = {
    id?: number
    deviceId: string
    connectTime?: number
    disconnectTime?: number
    errorCount?: number
    dataPointCount?: number
    lastUpdate?: Date | string
    date: string
  }

  export type DeviceStatsUpdateManyMutationInput = {
    deviceId?: StringFieldUpdateOperationsInput | string
    connectTime?: IntFieldUpdateOperationsInput | number
    disconnectTime?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    dataPointCount?: IntFieldUpdateOperationsInput | number
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceStatsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    deviceId?: StringFieldUpdateOperationsInput | string
    connectTime?: IntFieldUpdateOperationsInput | number
    disconnectTime?: IntFieldUpdateOperationsInput | number
    errorCount?: IntFieldUpdateOperationsInput | number
    dataPointCount?: IntFieldUpdateOperationsInput | number
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type EdgeConfigCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
  }

  export type EdgeConfigAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EdgeConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
  }

  export type EdgeConfigMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
  }

  export type EdgeConfigSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DeviceConnectionCountOrderByAggregateInput = {
    id?: SortOrder
    deviceType?: SortOrder
    deviceId?: SortOrder
    host?: SortOrder
    port?: SortOrder
    status?: SortOrder
    lastConnect?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviceConnectionAvgOrderByAggregateInput = {
    id?: SortOrder
    port?: SortOrder
  }

  export type DeviceConnectionMaxOrderByAggregateInput = {
    id?: SortOrder
    deviceType?: SortOrder
    deviceId?: SortOrder
    host?: SortOrder
    port?: SortOrder
    status?: SortOrder
    lastConnect?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviceConnectionMinOrderByAggregateInput = {
    id?: SortOrder
    deviceType?: SortOrder
    deviceId?: SortOrder
    host?: SortOrder
    port?: SortOrder
    status?: SortOrder
    lastConnect?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviceConnectionSumOrderByAggregateInput = {
    id?: SortOrder
    port?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DataHistoryListRelationFilter = {
    every?: DataHistoryWhereInput
    some?: DataHistoryWhereInput
    none?: DataHistoryWhereInput
  }

  export type DataHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DataPointTagNameDeviceIdCompoundUniqueInput = {
    tagName: string
    deviceId: string
  }

  export type DataPointCountOrderByAggregateInput = {
    id?: SortOrder
    tagName?: SortOrder
    deviceId?: SortOrder
    address?: SortOrder
    dataType?: SortOrder
    value?: SortOrder
    quality?: SortOrder
    timestamp?: SortOrder
    description?: SortOrder
  }

  export type DataPointAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DataPointMaxOrderByAggregateInput = {
    id?: SortOrder
    tagName?: SortOrder
    deviceId?: SortOrder
    address?: SortOrder
    dataType?: SortOrder
    value?: SortOrder
    quality?: SortOrder
    timestamp?: SortOrder
    description?: SortOrder
  }

  export type DataPointMinOrderByAggregateInput = {
    id?: SortOrder
    tagName?: SortOrder
    deviceId?: SortOrder
    address?: SortOrder
    dataType?: SortOrder
    value?: SortOrder
    quality?: SortOrder
    timestamp?: SortOrder
    description?: SortOrder
  }

  export type DataPointSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DataPointRelationFilter = {
    is?: DataPointWhereInput
    isNot?: DataPointWhereInput
  }

  export type DataHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    pointId?: SortOrder
    value?: SortOrder
    quality?: SortOrder
    timestamp?: SortOrder
  }

  export type DataHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    pointId?: SortOrder
  }

  export type DataHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    pointId?: SortOrder
    value?: SortOrder
    quality?: SortOrder
    timestamp?: SortOrder
  }

  export type DataHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    pointId?: SortOrder
    value?: SortOrder
    quality?: SortOrder
    timestamp?: SortOrder
  }

  export type DataHistorySumOrderByAggregateInput = {
    id?: SortOrder
    pointId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type LocalBatchListRelationFilter = {
    every?: LocalBatchWhereInput
    some?: LocalBatchWhereInput
    none?: LocalBatchWhereInput
  }

  export type LocalBatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocalRecipeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    concreteGrade?: SortOrder
    version?: SortOrder
    isActive?: SortOrder
    recipeData?: SortOrder
    syncStatus?: SortOrder
    remoteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocalRecipeAvgOrderByAggregateInput = {
    id?: SortOrder
    remoteId?: SortOrder
  }

  export type LocalRecipeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    concreteGrade?: SortOrder
    version?: SortOrder
    isActive?: SortOrder
    recipeData?: SortOrder
    syncStatus?: SortOrder
    remoteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocalRecipeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    concreteGrade?: SortOrder
    version?: SortOrder
    isActive?: SortOrder
    recipeData?: SortOrder
    syncStatus?: SortOrder
    remoteId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocalRecipeSumOrderByAggregateInput = {
    id?: SortOrder
    remoteId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type LocalRecipeRelationFilter = {
    is?: LocalRecipeWhereInput
    isNot?: LocalRecipeWhereInput
  }

  export type LocalBatchingRecordListRelationFilter = {
    every?: LocalBatchingRecordWhereInput
    some?: LocalBatchingRecordWhereInput
    none?: LocalBatchingRecordWhereInput
  }

  export type LocalBatchingRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocalBatchCountOrderByAggregateInput = {
    id?: SortOrder
    batchNumber?: SortOrder
    recipeId?: SortOrder
    volume?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    operatorName?: SortOrder
    syncStatus?: SortOrder
    remoteId?: SortOrder
    createdAt?: SortOrder
  }

  export type LocalBatchAvgOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    volume?: SortOrder
    remoteId?: SortOrder
  }

  export type LocalBatchMaxOrderByAggregateInput = {
    id?: SortOrder
    batchNumber?: SortOrder
    recipeId?: SortOrder
    volume?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    operatorName?: SortOrder
    syncStatus?: SortOrder
    remoteId?: SortOrder
    createdAt?: SortOrder
  }

  export type LocalBatchMinOrderByAggregateInput = {
    id?: SortOrder
    batchNumber?: SortOrder
    recipeId?: SortOrder
    volume?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    operatorName?: SortOrder
    syncStatus?: SortOrder
    remoteId?: SortOrder
    createdAt?: SortOrder
  }

  export type LocalBatchSumOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    volume?: SortOrder
    remoteId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type LocalBatchRelationFilter = {
    is?: LocalBatchWhereInput
    isNot?: LocalBatchWhereInput
  }

  export type LocalBatchingRecordCountOrderByAggregateInput = {
    id?: SortOrder
    batchId?: SortOrder
    materialName?: SortOrder
    targetWeight?: SortOrder
    actualWeight?: SortOrder
    deviation?: SortOrder
    toleranceCheck?: SortOrder
    timestamp?: SortOrder
  }

  export type LocalBatchingRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    batchId?: SortOrder
    targetWeight?: SortOrder
    actualWeight?: SortOrder
    deviation?: SortOrder
  }

  export type LocalBatchingRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    batchId?: SortOrder
    materialName?: SortOrder
    targetWeight?: SortOrder
    actualWeight?: SortOrder
    deviation?: SortOrder
    toleranceCheck?: SortOrder
    timestamp?: SortOrder
  }

  export type LocalBatchingRecordMinOrderByAggregateInput = {
    id?: SortOrder
    batchId?: SortOrder
    materialName?: SortOrder
    targetWeight?: SortOrder
    actualWeight?: SortOrder
    deviation?: SortOrder
    toleranceCheck?: SortOrder
    timestamp?: SortOrder
  }

  export type LocalBatchingRecordSumOrderByAggregateInput = {
    id?: SortOrder
    batchId?: SortOrder
    targetWeight?: SortOrder
    actualWeight?: SortOrder
    deviation?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type LocalAlarmCountOrderByAggregateInput = {
    id?: SortOrder
    alarmType?: SortOrder
    source?: SortOrder
    message?: SortOrder
    severity?: SortOrder
    acknowledged?: SortOrder
    resolved?: SortOrder
    syncStatus?: SortOrder
    remoteId?: SortOrder
    timestamp?: SortOrder
    resolvedAt?: SortOrder
  }

  export type LocalAlarmAvgOrderByAggregateInput = {
    id?: SortOrder
    remoteId?: SortOrder
  }

  export type LocalAlarmMaxOrderByAggregateInput = {
    id?: SortOrder
    alarmType?: SortOrder
    source?: SortOrder
    message?: SortOrder
    severity?: SortOrder
    acknowledged?: SortOrder
    resolved?: SortOrder
    syncStatus?: SortOrder
    remoteId?: SortOrder
    timestamp?: SortOrder
    resolvedAt?: SortOrder
  }

  export type LocalAlarmMinOrderByAggregateInput = {
    id?: SortOrder
    alarmType?: SortOrder
    source?: SortOrder
    message?: SortOrder
    severity?: SortOrder
    acknowledged?: SortOrder
    resolved?: SortOrder
    syncStatus?: SortOrder
    remoteId?: SortOrder
    timestamp?: SortOrder
    resolvedAt?: SortOrder
  }

  export type LocalAlarmSumOrderByAggregateInput = {
    id?: SortOrder
    remoteId?: SortOrder
  }

  export type LocalLogCountOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    module?: SortOrder
    action?: SortOrder
    message?: SortOrder
    data?: SortOrder
    syncStatus?: SortOrder
    timestamp?: SortOrder
  }

  export type LocalLogAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LocalLogMaxOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    module?: SortOrder
    action?: SortOrder
    message?: SortOrder
    data?: SortOrder
    syncStatus?: SortOrder
    timestamp?: SortOrder
  }

  export type LocalLogMinOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    module?: SortOrder
    action?: SortOrder
    message?: SortOrder
    data?: SortOrder
    syncStatus?: SortOrder
    timestamp?: SortOrder
  }

  export type LocalLogSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SyncQueueCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrder
    status?: SortOrder
    retryCount?: SortOrder
    lastError?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SyncQueueAvgOrderByAggregateInput = {
    id?: SortOrder
    retryCount?: SortOrder
  }

  export type SyncQueueMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrder
    status?: SortOrder
    retryCount?: SortOrder
    lastError?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SyncQueueMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrder
    status?: SortOrder
    retryCount?: SortOrder
    lastError?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SyncQueueSumOrderByAggregateInput = {
    id?: SortOrder
    retryCount?: SortOrder
  }

  export type SyncStatusCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    lastSync?: SortOrder
    lastError?: SortOrder
    syncCount?: SortOrder
    errorCount?: SortOrder
    updatedAt?: SortOrder
  }

  export type SyncStatusAvgOrderByAggregateInput = {
    id?: SortOrder
    syncCount?: SortOrder
    errorCount?: SortOrder
  }

  export type SyncStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    lastSync?: SortOrder
    lastError?: SortOrder
    syncCount?: SortOrder
    errorCount?: SortOrder
    updatedAt?: SortOrder
  }

  export type SyncStatusMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    lastSync?: SortOrder
    lastError?: SortOrder
    syncCount?: SortOrder
    errorCount?: SortOrder
    updatedAt?: SortOrder
  }

  export type SyncStatusSumOrderByAggregateInput = {
    id?: SortOrder
    syncCount?: SortOrder
    errorCount?: SortOrder
  }

  export type ProductionTaskListRelationFilter = {
    every?: ProductionTaskWhereInput
    some?: ProductionTaskWhereInput
    none?: ProductionTaskWhereInput
  }

  export type ProductionTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cement?: SortOrder
    water?: SortOrder
    sand?: SortOrder
    gravel?: SortOrder
    additive?: SortOrder
    mixingTime?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecipeAvgOrderByAggregateInput = {
    cement?: SortOrder
    water?: SortOrder
    sand?: SortOrder
    gravel?: SortOrder
    additive?: SortOrder
    mixingTime?: SortOrder
  }

  export type RecipeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cement?: SortOrder
    water?: SortOrder
    sand?: SortOrder
    gravel?: SortOrder
    additive?: SortOrder
    mixingTime?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecipeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cement?: SortOrder
    water?: SortOrder
    sand?: SortOrder
    gravel?: SortOrder
    additive?: SortOrder
    mixingTime?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecipeSumOrderByAggregateInput = {
    cement?: SortOrder
    water?: SortOrder
    sand?: SortOrder
    gravel?: SortOrder
    additive?: SortOrder
    mixingTime?: SortOrder
  }

  export type RecipeRelationFilter = {
    is?: RecipeWhereInput
    isNot?: RecipeWhereInput
  }

  export type ProductionRecordListRelationFilter = {
    every?: ProductionRecordWhereInput
    some?: ProductionRecordWhereInput
    none?: ProductionRecordWhereInput
  }

  export type ProductionRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductionTaskCountOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    quantity?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductionTaskAvgOrderByAggregateInput = {
    quantity?: SortOrder
    priority?: SortOrder
  }

  export type ProductionTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    quantity?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductionTaskMinOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    quantity?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductionTaskSumOrderByAggregateInput = {
    quantity?: SortOrder
    priority?: SortOrder
  }

  export type ProductionTaskRelationFilter = {
    is?: ProductionTaskWhereInput
    isNot?: ProductionTaskWhereInput
  }

  export type ProductionRecordCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    recipeId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductionRecordAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type ProductionRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    recipeId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductionRecordMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    recipeId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductionRecordSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type AlarmCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    source?: SortOrder
    message?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    data?: SortOrder
    acknowledgedAt?: SortOrder
    acknowledgedBy?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    resolution?: SortOrder
    createdAt?: SortOrder
  }

  export type AlarmMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    source?: SortOrder
    message?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    data?: SortOrder
    acknowledgedAt?: SortOrder
    acknowledgedBy?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    resolution?: SortOrder
    createdAt?: SortOrder
  }

  export type AlarmMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    source?: SortOrder
    message?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    data?: SortOrder
    acknowledgedAt?: SortOrder
    acknowledgedBy?: SortOrder
    resolvedAt?: SortOrder
    resolvedBy?: SortOrder
    resolution?: SortOrder
    createdAt?: SortOrder
  }

  export type SafetyEventCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
  }

  export type SafetyEventMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
  }

  export type SafetyEventMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
  }

  export type SafetyRuleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    condition?: SortOrder
    threshold?: SortOrder
    action?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SafetyRuleAvgOrderByAggregateInput = {
    threshold?: SortOrder
  }

  export type SafetyRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    condition?: SortOrder
    threshold?: SortOrder
    action?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SafetyRuleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    condition?: SortOrder
    threshold?: SortOrder
    action?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SafetyRuleSumOrderByAggregateInput = {
    threshold?: SortOrder
  }

  export type SystemMetricsCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrder
    timestamp?: SortOrder
  }

  export type SystemMetricsMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrder
    timestamp?: SortOrder
  }

  export type SystemMetricsMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    data?: SortOrder
    timestamp?: SortOrder
  }

  export type EquipmentRuntimeEquipmentNameDateCompoundUniqueInput = {
    equipmentName: string
    date: Date | string
  }

  export type EquipmentRuntimeCountOrderByAggregateInput = {
    id?: SortOrder
    equipmentName?: SortOrder
    runtime?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
  }

  export type EquipmentRuntimeAvgOrderByAggregateInput = {
    runtime?: SortOrder
  }

  export type EquipmentRuntimeMaxOrderByAggregateInput = {
    id?: SortOrder
    equipmentName?: SortOrder
    runtime?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
  }

  export type EquipmentRuntimeMinOrderByAggregateInput = {
    id?: SortOrder
    equipmentName?: SortOrder
    runtime?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
  }

  export type EquipmentRuntimeSumOrderByAggregateInput = {
    runtime?: SortOrder
  }

  export type SystemStatusCountOrderByAggregateInput = {
    id?: SortOrder
    cpuUsage?: SortOrder
    memoryUsage?: SortOrder
    diskUsage?: SortOrder
    temperature?: SortOrder
    uptime?: SortOrder
    timestamp?: SortOrder
  }

  export type SystemStatusAvgOrderByAggregateInput = {
    id?: SortOrder
    cpuUsage?: SortOrder
    memoryUsage?: SortOrder
    diskUsage?: SortOrder
    temperature?: SortOrder
    uptime?: SortOrder
  }

  export type SystemStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    cpuUsage?: SortOrder
    memoryUsage?: SortOrder
    diskUsage?: SortOrder
    temperature?: SortOrder
    uptime?: SortOrder
    timestamp?: SortOrder
  }

  export type SystemStatusMinOrderByAggregateInput = {
    id?: SortOrder
    cpuUsage?: SortOrder
    memoryUsage?: SortOrder
    diskUsage?: SortOrder
    temperature?: SortOrder
    uptime?: SortOrder
    timestamp?: SortOrder
  }

  export type SystemStatusSumOrderByAggregateInput = {
    id?: SortOrder
    cpuUsage?: SortOrder
    memoryUsage?: SortOrder
    diskUsage?: SortOrder
    temperature?: SortOrder
    uptime?: SortOrder
  }

  export type DeviceStatsDeviceIdDateCompoundUniqueInput = {
    deviceId: string
    date: string
  }

  export type DeviceStatsCountOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    connectTime?: SortOrder
    disconnectTime?: SortOrder
    errorCount?: SortOrder
    dataPointCount?: SortOrder
    lastUpdate?: SortOrder
    date?: SortOrder
  }

  export type DeviceStatsAvgOrderByAggregateInput = {
    id?: SortOrder
    connectTime?: SortOrder
    disconnectTime?: SortOrder
    errorCount?: SortOrder
    dataPointCount?: SortOrder
  }

  export type DeviceStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    connectTime?: SortOrder
    disconnectTime?: SortOrder
    errorCount?: SortOrder
    dataPointCount?: SortOrder
    lastUpdate?: SortOrder
    date?: SortOrder
  }

  export type DeviceStatsMinOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    connectTime?: SortOrder
    disconnectTime?: SortOrder
    errorCount?: SortOrder
    dataPointCount?: SortOrder
    lastUpdate?: SortOrder
    date?: SortOrder
  }

  export type DeviceStatsSumOrderByAggregateInput = {
    id?: SortOrder
    connectTime?: SortOrder
    disconnectTime?: SortOrder
    errorCount?: SortOrder
    dataPointCount?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DataHistoryCreateNestedManyWithoutDataPointInput = {
    create?: XOR<DataHistoryCreateWithoutDataPointInput, DataHistoryUncheckedCreateWithoutDataPointInput> | DataHistoryCreateWithoutDataPointInput[] | DataHistoryUncheckedCreateWithoutDataPointInput[]
    connectOrCreate?: DataHistoryCreateOrConnectWithoutDataPointInput | DataHistoryCreateOrConnectWithoutDataPointInput[]
    createMany?: DataHistoryCreateManyDataPointInputEnvelope
    connect?: DataHistoryWhereUniqueInput | DataHistoryWhereUniqueInput[]
  }

  export type DataHistoryUncheckedCreateNestedManyWithoutDataPointInput = {
    create?: XOR<DataHistoryCreateWithoutDataPointInput, DataHistoryUncheckedCreateWithoutDataPointInput> | DataHistoryCreateWithoutDataPointInput[] | DataHistoryUncheckedCreateWithoutDataPointInput[]
    connectOrCreate?: DataHistoryCreateOrConnectWithoutDataPointInput | DataHistoryCreateOrConnectWithoutDataPointInput[]
    createMany?: DataHistoryCreateManyDataPointInputEnvelope
    connect?: DataHistoryWhereUniqueInput | DataHistoryWhereUniqueInput[]
  }

  export type DataHistoryUpdateManyWithoutDataPointNestedInput = {
    create?: XOR<DataHistoryCreateWithoutDataPointInput, DataHistoryUncheckedCreateWithoutDataPointInput> | DataHistoryCreateWithoutDataPointInput[] | DataHistoryUncheckedCreateWithoutDataPointInput[]
    connectOrCreate?: DataHistoryCreateOrConnectWithoutDataPointInput | DataHistoryCreateOrConnectWithoutDataPointInput[]
    upsert?: DataHistoryUpsertWithWhereUniqueWithoutDataPointInput | DataHistoryUpsertWithWhereUniqueWithoutDataPointInput[]
    createMany?: DataHistoryCreateManyDataPointInputEnvelope
    set?: DataHistoryWhereUniqueInput | DataHistoryWhereUniqueInput[]
    disconnect?: DataHistoryWhereUniqueInput | DataHistoryWhereUniqueInput[]
    delete?: DataHistoryWhereUniqueInput | DataHistoryWhereUniqueInput[]
    connect?: DataHistoryWhereUniqueInput | DataHistoryWhereUniqueInput[]
    update?: DataHistoryUpdateWithWhereUniqueWithoutDataPointInput | DataHistoryUpdateWithWhereUniqueWithoutDataPointInput[]
    updateMany?: DataHistoryUpdateManyWithWhereWithoutDataPointInput | DataHistoryUpdateManyWithWhereWithoutDataPointInput[]
    deleteMany?: DataHistoryScalarWhereInput | DataHistoryScalarWhereInput[]
  }

  export type DataHistoryUncheckedUpdateManyWithoutDataPointNestedInput = {
    create?: XOR<DataHistoryCreateWithoutDataPointInput, DataHistoryUncheckedCreateWithoutDataPointInput> | DataHistoryCreateWithoutDataPointInput[] | DataHistoryUncheckedCreateWithoutDataPointInput[]
    connectOrCreate?: DataHistoryCreateOrConnectWithoutDataPointInput | DataHistoryCreateOrConnectWithoutDataPointInput[]
    upsert?: DataHistoryUpsertWithWhereUniqueWithoutDataPointInput | DataHistoryUpsertWithWhereUniqueWithoutDataPointInput[]
    createMany?: DataHistoryCreateManyDataPointInputEnvelope
    set?: DataHistoryWhereUniqueInput | DataHistoryWhereUniqueInput[]
    disconnect?: DataHistoryWhereUniqueInput | DataHistoryWhereUniqueInput[]
    delete?: DataHistoryWhereUniqueInput | DataHistoryWhereUniqueInput[]
    connect?: DataHistoryWhereUniqueInput | DataHistoryWhereUniqueInput[]
    update?: DataHistoryUpdateWithWhereUniqueWithoutDataPointInput | DataHistoryUpdateWithWhereUniqueWithoutDataPointInput[]
    updateMany?: DataHistoryUpdateManyWithWhereWithoutDataPointInput | DataHistoryUpdateManyWithWhereWithoutDataPointInput[]
    deleteMany?: DataHistoryScalarWhereInput | DataHistoryScalarWhereInput[]
  }

  export type DataPointCreateNestedOneWithoutHistoryInput = {
    create?: XOR<DataPointCreateWithoutHistoryInput, DataPointUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: DataPointCreateOrConnectWithoutHistoryInput
    connect?: DataPointWhereUniqueInput
  }

  export type DataPointUpdateOneRequiredWithoutHistoryNestedInput = {
    create?: XOR<DataPointCreateWithoutHistoryInput, DataPointUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: DataPointCreateOrConnectWithoutHistoryInput
    upsert?: DataPointUpsertWithoutHistoryInput
    connect?: DataPointWhereUniqueInput
    update?: XOR<XOR<DataPointUpdateToOneWithWhereWithoutHistoryInput, DataPointUpdateWithoutHistoryInput>, DataPointUncheckedUpdateWithoutHistoryInput>
  }

  export type LocalBatchCreateNestedManyWithoutRecipeInput = {
    create?: XOR<LocalBatchCreateWithoutRecipeInput, LocalBatchUncheckedCreateWithoutRecipeInput> | LocalBatchCreateWithoutRecipeInput[] | LocalBatchUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: LocalBatchCreateOrConnectWithoutRecipeInput | LocalBatchCreateOrConnectWithoutRecipeInput[]
    createMany?: LocalBatchCreateManyRecipeInputEnvelope
    connect?: LocalBatchWhereUniqueInput | LocalBatchWhereUniqueInput[]
  }

  export type LocalBatchUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<LocalBatchCreateWithoutRecipeInput, LocalBatchUncheckedCreateWithoutRecipeInput> | LocalBatchCreateWithoutRecipeInput[] | LocalBatchUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: LocalBatchCreateOrConnectWithoutRecipeInput | LocalBatchCreateOrConnectWithoutRecipeInput[]
    createMany?: LocalBatchCreateManyRecipeInputEnvelope
    connect?: LocalBatchWhereUniqueInput | LocalBatchWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type LocalBatchUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<LocalBatchCreateWithoutRecipeInput, LocalBatchUncheckedCreateWithoutRecipeInput> | LocalBatchCreateWithoutRecipeInput[] | LocalBatchUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: LocalBatchCreateOrConnectWithoutRecipeInput | LocalBatchCreateOrConnectWithoutRecipeInput[]
    upsert?: LocalBatchUpsertWithWhereUniqueWithoutRecipeInput | LocalBatchUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: LocalBatchCreateManyRecipeInputEnvelope
    set?: LocalBatchWhereUniqueInput | LocalBatchWhereUniqueInput[]
    disconnect?: LocalBatchWhereUniqueInput | LocalBatchWhereUniqueInput[]
    delete?: LocalBatchWhereUniqueInput | LocalBatchWhereUniqueInput[]
    connect?: LocalBatchWhereUniqueInput | LocalBatchWhereUniqueInput[]
    update?: LocalBatchUpdateWithWhereUniqueWithoutRecipeInput | LocalBatchUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: LocalBatchUpdateManyWithWhereWithoutRecipeInput | LocalBatchUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: LocalBatchScalarWhereInput | LocalBatchScalarWhereInput[]
  }

  export type LocalBatchUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<LocalBatchCreateWithoutRecipeInput, LocalBatchUncheckedCreateWithoutRecipeInput> | LocalBatchCreateWithoutRecipeInput[] | LocalBatchUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: LocalBatchCreateOrConnectWithoutRecipeInput | LocalBatchCreateOrConnectWithoutRecipeInput[]
    upsert?: LocalBatchUpsertWithWhereUniqueWithoutRecipeInput | LocalBatchUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: LocalBatchCreateManyRecipeInputEnvelope
    set?: LocalBatchWhereUniqueInput | LocalBatchWhereUniqueInput[]
    disconnect?: LocalBatchWhereUniqueInput | LocalBatchWhereUniqueInput[]
    delete?: LocalBatchWhereUniqueInput | LocalBatchWhereUniqueInput[]
    connect?: LocalBatchWhereUniqueInput | LocalBatchWhereUniqueInput[]
    update?: LocalBatchUpdateWithWhereUniqueWithoutRecipeInput | LocalBatchUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: LocalBatchUpdateManyWithWhereWithoutRecipeInput | LocalBatchUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: LocalBatchScalarWhereInput | LocalBatchScalarWhereInput[]
  }

  export type LocalRecipeCreateNestedOneWithoutBatchesInput = {
    create?: XOR<LocalRecipeCreateWithoutBatchesInput, LocalRecipeUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: LocalRecipeCreateOrConnectWithoutBatchesInput
    connect?: LocalRecipeWhereUniqueInput
  }

  export type LocalBatchingRecordCreateNestedManyWithoutBatchInput = {
    create?: XOR<LocalBatchingRecordCreateWithoutBatchInput, LocalBatchingRecordUncheckedCreateWithoutBatchInput> | LocalBatchingRecordCreateWithoutBatchInput[] | LocalBatchingRecordUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: LocalBatchingRecordCreateOrConnectWithoutBatchInput | LocalBatchingRecordCreateOrConnectWithoutBatchInput[]
    createMany?: LocalBatchingRecordCreateManyBatchInputEnvelope
    connect?: LocalBatchingRecordWhereUniqueInput | LocalBatchingRecordWhereUniqueInput[]
  }

  export type LocalBatchingRecordUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<LocalBatchingRecordCreateWithoutBatchInput, LocalBatchingRecordUncheckedCreateWithoutBatchInput> | LocalBatchingRecordCreateWithoutBatchInput[] | LocalBatchingRecordUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: LocalBatchingRecordCreateOrConnectWithoutBatchInput | LocalBatchingRecordCreateOrConnectWithoutBatchInput[]
    createMany?: LocalBatchingRecordCreateManyBatchInputEnvelope
    connect?: LocalBatchingRecordWhereUniqueInput | LocalBatchingRecordWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LocalRecipeUpdateOneRequiredWithoutBatchesNestedInput = {
    create?: XOR<LocalRecipeCreateWithoutBatchesInput, LocalRecipeUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: LocalRecipeCreateOrConnectWithoutBatchesInput
    upsert?: LocalRecipeUpsertWithoutBatchesInput
    connect?: LocalRecipeWhereUniqueInput
    update?: XOR<XOR<LocalRecipeUpdateToOneWithWhereWithoutBatchesInput, LocalRecipeUpdateWithoutBatchesInput>, LocalRecipeUncheckedUpdateWithoutBatchesInput>
  }

  export type LocalBatchingRecordUpdateManyWithoutBatchNestedInput = {
    create?: XOR<LocalBatchingRecordCreateWithoutBatchInput, LocalBatchingRecordUncheckedCreateWithoutBatchInput> | LocalBatchingRecordCreateWithoutBatchInput[] | LocalBatchingRecordUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: LocalBatchingRecordCreateOrConnectWithoutBatchInput | LocalBatchingRecordCreateOrConnectWithoutBatchInput[]
    upsert?: LocalBatchingRecordUpsertWithWhereUniqueWithoutBatchInput | LocalBatchingRecordUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: LocalBatchingRecordCreateManyBatchInputEnvelope
    set?: LocalBatchingRecordWhereUniqueInput | LocalBatchingRecordWhereUniqueInput[]
    disconnect?: LocalBatchingRecordWhereUniqueInput | LocalBatchingRecordWhereUniqueInput[]
    delete?: LocalBatchingRecordWhereUniqueInput | LocalBatchingRecordWhereUniqueInput[]
    connect?: LocalBatchingRecordWhereUniqueInput | LocalBatchingRecordWhereUniqueInput[]
    update?: LocalBatchingRecordUpdateWithWhereUniqueWithoutBatchInput | LocalBatchingRecordUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: LocalBatchingRecordUpdateManyWithWhereWithoutBatchInput | LocalBatchingRecordUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: LocalBatchingRecordScalarWhereInput | LocalBatchingRecordScalarWhereInput[]
  }

  export type LocalBatchingRecordUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<LocalBatchingRecordCreateWithoutBatchInput, LocalBatchingRecordUncheckedCreateWithoutBatchInput> | LocalBatchingRecordCreateWithoutBatchInput[] | LocalBatchingRecordUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: LocalBatchingRecordCreateOrConnectWithoutBatchInput | LocalBatchingRecordCreateOrConnectWithoutBatchInput[]
    upsert?: LocalBatchingRecordUpsertWithWhereUniqueWithoutBatchInput | LocalBatchingRecordUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: LocalBatchingRecordCreateManyBatchInputEnvelope
    set?: LocalBatchingRecordWhereUniqueInput | LocalBatchingRecordWhereUniqueInput[]
    disconnect?: LocalBatchingRecordWhereUniqueInput | LocalBatchingRecordWhereUniqueInput[]
    delete?: LocalBatchingRecordWhereUniqueInput | LocalBatchingRecordWhereUniqueInput[]
    connect?: LocalBatchingRecordWhereUniqueInput | LocalBatchingRecordWhereUniqueInput[]
    update?: LocalBatchingRecordUpdateWithWhereUniqueWithoutBatchInput | LocalBatchingRecordUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: LocalBatchingRecordUpdateManyWithWhereWithoutBatchInput | LocalBatchingRecordUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: LocalBatchingRecordScalarWhereInput | LocalBatchingRecordScalarWhereInput[]
  }

  export type LocalBatchCreateNestedOneWithoutBatchingRecordsInput = {
    create?: XOR<LocalBatchCreateWithoutBatchingRecordsInput, LocalBatchUncheckedCreateWithoutBatchingRecordsInput>
    connectOrCreate?: LocalBatchCreateOrConnectWithoutBatchingRecordsInput
    connect?: LocalBatchWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LocalBatchUpdateOneRequiredWithoutBatchingRecordsNestedInput = {
    create?: XOR<LocalBatchCreateWithoutBatchingRecordsInput, LocalBatchUncheckedCreateWithoutBatchingRecordsInput>
    connectOrCreate?: LocalBatchCreateOrConnectWithoutBatchingRecordsInput
    upsert?: LocalBatchUpsertWithoutBatchingRecordsInput
    connect?: LocalBatchWhereUniqueInput
    update?: XOR<XOR<LocalBatchUpdateToOneWithWhereWithoutBatchingRecordsInput, LocalBatchUpdateWithoutBatchingRecordsInput>, LocalBatchUncheckedUpdateWithoutBatchingRecordsInput>
  }

  export type ProductionTaskCreateNestedManyWithoutRecipeInput = {
    create?: XOR<ProductionTaskCreateWithoutRecipeInput, ProductionTaskUncheckedCreateWithoutRecipeInput> | ProductionTaskCreateWithoutRecipeInput[] | ProductionTaskUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: ProductionTaskCreateOrConnectWithoutRecipeInput | ProductionTaskCreateOrConnectWithoutRecipeInput[]
    createMany?: ProductionTaskCreateManyRecipeInputEnvelope
    connect?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
  }

  export type ProductionTaskUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<ProductionTaskCreateWithoutRecipeInput, ProductionTaskUncheckedCreateWithoutRecipeInput> | ProductionTaskCreateWithoutRecipeInput[] | ProductionTaskUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: ProductionTaskCreateOrConnectWithoutRecipeInput | ProductionTaskCreateOrConnectWithoutRecipeInput[]
    createMany?: ProductionTaskCreateManyRecipeInputEnvelope
    connect?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
  }

  export type ProductionTaskUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<ProductionTaskCreateWithoutRecipeInput, ProductionTaskUncheckedCreateWithoutRecipeInput> | ProductionTaskCreateWithoutRecipeInput[] | ProductionTaskUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: ProductionTaskCreateOrConnectWithoutRecipeInput | ProductionTaskCreateOrConnectWithoutRecipeInput[]
    upsert?: ProductionTaskUpsertWithWhereUniqueWithoutRecipeInput | ProductionTaskUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: ProductionTaskCreateManyRecipeInputEnvelope
    set?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
    disconnect?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
    delete?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
    connect?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
    update?: ProductionTaskUpdateWithWhereUniqueWithoutRecipeInput | ProductionTaskUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: ProductionTaskUpdateManyWithWhereWithoutRecipeInput | ProductionTaskUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: ProductionTaskScalarWhereInput | ProductionTaskScalarWhereInput[]
  }

  export type ProductionTaskUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<ProductionTaskCreateWithoutRecipeInput, ProductionTaskUncheckedCreateWithoutRecipeInput> | ProductionTaskCreateWithoutRecipeInput[] | ProductionTaskUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: ProductionTaskCreateOrConnectWithoutRecipeInput | ProductionTaskCreateOrConnectWithoutRecipeInput[]
    upsert?: ProductionTaskUpsertWithWhereUniqueWithoutRecipeInput | ProductionTaskUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: ProductionTaskCreateManyRecipeInputEnvelope
    set?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
    disconnect?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
    delete?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
    connect?: ProductionTaskWhereUniqueInput | ProductionTaskWhereUniqueInput[]
    update?: ProductionTaskUpdateWithWhereUniqueWithoutRecipeInput | ProductionTaskUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: ProductionTaskUpdateManyWithWhereWithoutRecipeInput | ProductionTaskUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: ProductionTaskScalarWhereInput | ProductionTaskScalarWhereInput[]
  }

  export type RecipeCreateNestedOneWithoutProductionTasksInput = {
    create?: XOR<RecipeCreateWithoutProductionTasksInput, RecipeUncheckedCreateWithoutProductionTasksInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutProductionTasksInput
    connect?: RecipeWhereUniqueInput
  }

  export type ProductionRecordCreateNestedManyWithoutTaskInput = {
    create?: XOR<ProductionRecordCreateWithoutTaskInput, ProductionRecordUncheckedCreateWithoutTaskInput> | ProductionRecordCreateWithoutTaskInput[] | ProductionRecordUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: ProductionRecordCreateOrConnectWithoutTaskInput | ProductionRecordCreateOrConnectWithoutTaskInput[]
    createMany?: ProductionRecordCreateManyTaskInputEnvelope
    connect?: ProductionRecordWhereUniqueInput | ProductionRecordWhereUniqueInput[]
  }

  export type ProductionRecordUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<ProductionRecordCreateWithoutTaskInput, ProductionRecordUncheckedCreateWithoutTaskInput> | ProductionRecordCreateWithoutTaskInput[] | ProductionRecordUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: ProductionRecordCreateOrConnectWithoutTaskInput | ProductionRecordCreateOrConnectWithoutTaskInput[]
    createMany?: ProductionRecordCreateManyTaskInputEnvelope
    connect?: ProductionRecordWhereUniqueInput | ProductionRecordWhereUniqueInput[]
  }

  export type RecipeUpdateOneRequiredWithoutProductionTasksNestedInput = {
    create?: XOR<RecipeCreateWithoutProductionTasksInput, RecipeUncheckedCreateWithoutProductionTasksInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutProductionTasksInput
    upsert?: RecipeUpsertWithoutProductionTasksInput
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutProductionTasksInput, RecipeUpdateWithoutProductionTasksInput>, RecipeUncheckedUpdateWithoutProductionTasksInput>
  }

  export type ProductionRecordUpdateManyWithoutTaskNestedInput = {
    create?: XOR<ProductionRecordCreateWithoutTaskInput, ProductionRecordUncheckedCreateWithoutTaskInput> | ProductionRecordCreateWithoutTaskInput[] | ProductionRecordUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: ProductionRecordCreateOrConnectWithoutTaskInput | ProductionRecordCreateOrConnectWithoutTaskInput[]
    upsert?: ProductionRecordUpsertWithWhereUniqueWithoutTaskInput | ProductionRecordUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: ProductionRecordCreateManyTaskInputEnvelope
    set?: ProductionRecordWhereUniqueInput | ProductionRecordWhereUniqueInput[]
    disconnect?: ProductionRecordWhereUniqueInput | ProductionRecordWhereUniqueInput[]
    delete?: ProductionRecordWhereUniqueInput | ProductionRecordWhereUniqueInput[]
    connect?: ProductionRecordWhereUniqueInput | ProductionRecordWhereUniqueInput[]
    update?: ProductionRecordUpdateWithWhereUniqueWithoutTaskInput | ProductionRecordUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: ProductionRecordUpdateManyWithWhereWithoutTaskInput | ProductionRecordUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: ProductionRecordScalarWhereInput | ProductionRecordScalarWhereInput[]
  }

  export type ProductionRecordUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<ProductionRecordCreateWithoutTaskInput, ProductionRecordUncheckedCreateWithoutTaskInput> | ProductionRecordCreateWithoutTaskInput[] | ProductionRecordUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: ProductionRecordCreateOrConnectWithoutTaskInput | ProductionRecordCreateOrConnectWithoutTaskInput[]
    upsert?: ProductionRecordUpsertWithWhereUniqueWithoutTaskInput | ProductionRecordUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: ProductionRecordCreateManyTaskInputEnvelope
    set?: ProductionRecordWhereUniqueInput | ProductionRecordWhereUniqueInput[]
    disconnect?: ProductionRecordWhereUniqueInput | ProductionRecordWhereUniqueInput[]
    delete?: ProductionRecordWhereUniqueInput | ProductionRecordWhereUniqueInput[]
    connect?: ProductionRecordWhereUniqueInput | ProductionRecordWhereUniqueInput[]
    update?: ProductionRecordUpdateWithWhereUniqueWithoutTaskInput | ProductionRecordUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: ProductionRecordUpdateManyWithWhereWithoutTaskInput | ProductionRecordUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: ProductionRecordScalarWhereInput | ProductionRecordScalarWhereInput[]
  }

  export type ProductionTaskCreateNestedOneWithoutProductionRecordsInput = {
    create?: XOR<ProductionTaskCreateWithoutProductionRecordsInput, ProductionTaskUncheckedCreateWithoutProductionRecordsInput>
    connectOrCreate?: ProductionTaskCreateOrConnectWithoutProductionRecordsInput
    connect?: ProductionTaskWhereUniqueInput
  }

  export type ProductionTaskUpdateOneRequiredWithoutProductionRecordsNestedInput = {
    create?: XOR<ProductionTaskCreateWithoutProductionRecordsInput, ProductionTaskUncheckedCreateWithoutProductionRecordsInput>
    connectOrCreate?: ProductionTaskCreateOrConnectWithoutProductionRecordsInput
    upsert?: ProductionTaskUpsertWithoutProductionRecordsInput
    connect?: ProductionTaskWhereUniqueInput
    update?: XOR<XOR<ProductionTaskUpdateToOneWithWhereWithoutProductionRecordsInput, ProductionTaskUpdateWithoutProductionRecordsInput>, ProductionTaskUncheckedUpdateWithoutProductionRecordsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DataHistoryCreateWithoutDataPointInput = {
    value: string
    quality?: string
    timestamp?: Date | string
  }

  export type DataHistoryUncheckedCreateWithoutDataPointInput = {
    id?: number
    value: string
    quality?: string
    timestamp?: Date | string
  }

  export type DataHistoryCreateOrConnectWithoutDataPointInput = {
    where: DataHistoryWhereUniqueInput
    create: XOR<DataHistoryCreateWithoutDataPointInput, DataHistoryUncheckedCreateWithoutDataPointInput>
  }

  export type DataHistoryCreateManyDataPointInputEnvelope = {
    data: DataHistoryCreateManyDataPointInput | DataHistoryCreateManyDataPointInput[]
  }

  export type DataHistoryUpsertWithWhereUniqueWithoutDataPointInput = {
    where: DataHistoryWhereUniqueInput
    update: XOR<DataHistoryUpdateWithoutDataPointInput, DataHistoryUncheckedUpdateWithoutDataPointInput>
    create: XOR<DataHistoryCreateWithoutDataPointInput, DataHistoryUncheckedCreateWithoutDataPointInput>
  }

  export type DataHistoryUpdateWithWhereUniqueWithoutDataPointInput = {
    where: DataHistoryWhereUniqueInput
    data: XOR<DataHistoryUpdateWithoutDataPointInput, DataHistoryUncheckedUpdateWithoutDataPointInput>
  }

  export type DataHistoryUpdateManyWithWhereWithoutDataPointInput = {
    where: DataHistoryScalarWhereInput
    data: XOR<DataHistoryUpdateManyMutationInput, DataHistoryUncheckedUpdateManyWithoutDataPointInput>
  }

  export type DataHistoryScalarWhereInput = {
    AND?: DataHistoryScalarWhereInput | DataHistoryScalarWhereInput[]
    OR?: DataHistoryScalarWhereInput[]
    NOT?: DataHistoryScalarWhereInput | DataHistoryScalarWhereInput[]
    id?: IntFilter<"DataHistory"> | number
    pointId?: IntFilter<"DataHistory"> | number
    value?: StringFilter<"DataHistory"> | string
    quality?: StringFilter<"DataHistory"> | string
    timestamp?: DateTimeFilter<"DataHistory"> | Date | string
  }

  export type DataPointCreateWithoutHistoryInput = {
    tagName: string
    deviceId: string
    address: string
    dataType: string
    value: string
    quality?: string
    timestamp?: Date | string
    description?: string | null
  }

  export type DataPointUncheckedCreateWithoutHistoryInput = {
    id?: number
    tagName: string
    deviceId: string
    address: string
    dataType: string
    value: string
    quality?: string
    timestamp?: Date | string
    description?: string | null
  }

  export type DataPointCreateOrConnectWithoutHistoryInput = {
    where: DataPointWhereUniqueInput
    create: XOR<DataPointCreateWithoutHistoryInput, DataPointUncheckedCreateWithoutHistoryInput>
  }

  export type DataPointUpsertWithoutHistoryInput = {
    update: XOR<DataPointUpdateWithoutHistoryInput, DataPointUncheckedUpdateWithoutHistoryInput>
    create: XOR<DataPointCreateWithoutHistoryInput, DataPointUncheckedCreateWithoutHistoryInput>
    where?: DataPointWhereInput
  }

  export type DataPointUpdateToOneWithWhereWithoutHistoryInput = {
    where?: DataPointWhereInput
    data: XOR<DataPointUpdateWithoutHistoryInput, DataPointUncheckedUpdateWithoutHistoryInput>
  }

  export type DataPointUpdateWithoutHistoryInput = {
    tagName?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DataPointUncheckedUpdateWithoutHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    tagName?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    dataType?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LocalBatchCreateWithoutRecipeInput = {
    batchNumber: string
    volume: number
    status?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    operatorName?: string | null
    syncStatus?: string
    remoteId?: number | null
    createdAt?: Date | string
    batchingRecords?: LocalBatchingRecordCreateNestedManyWithoutBatchInput
  }

  export type LocalBatchUncheckedCreateWithoutRecipeInput = {
    id?: number
    batchNumber: string
    volume: number
    status?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    operatorName?: string | null
    syncStatus?: string
    remoteId?: number | null
    createdAt?: Date | string
    batchingRecords?: LocalBatchingRecordUncheckedCreateNestedManyWithoutBatchInput
  }

  export type LocalBatchCreateOrConnectWithoutRecipeInput = {
    where: LocalBatchWhereUniqueInput
    create: XOR<LocalBatchCreateWithoutRecipeInput, LocalBatchUncheckedCreateWithoutRecipeInput>
  }

  export type LocalBatchCreateManyRecipeInputEnvelope = {
    data: LocalBatchCreateManyRecipeInput | LocalBatchCreateManyRecipeInput[]
  }

  export type LocalBatchUpsertWithWhereUniqueWithoutRecipeInput = {
    where: LocalBatchWhereUniqueInput
    update: XOR<LocalBatchUpdateWithoutRecipeInput, LocalBatchUncheckedUpdateWithoutRecipeInput>
    create: XOR<LocalBatchCreateWithoutRecipeInput, LocalBatchUncheckedCreateWithoutRecipeInput>
  }

  export type LocalBatchUpdateWithWhereUniqueWithoutRecipeInput = {
    where: LocalBatchWhereUniqueInput
    data: XOR<LocalBatchUpdateWithoutRecipeInput, LocalBatchUncheckedUpdateWithoutRecipeInput>
  }

  export type LocalBatchUpdateManyWithWhereWithoutRecipeInput = {
    where: LocalBatchScalarWhereInput
    data: XOR<LocalBatchUpdateManyMutationInput, LocalBatchUncheckedUpdateManyWithoutRecipeInput>
  }

  export type LocalBatchScalarWhereInput = {
    AND?: LocalBatchScalarWhereInput | LocalBatchScalarWhereInput[]
    OR?: LocalBatchScalarWhereInput[]
    NOT?: LocalBatchScalarWhereInput | LocalBatchScalarWhereInput[]
    id?: IntFilter<"LocalBatch"> | number
    batchNumber?: StringFilter<"LocalBatch"> | string
    recipeId?: IntFilter<"LocalBatch"> | number
    volume?: FloatFilter<"LocalBatch"> | number
    status?: StringFilter<"LocalBatch"> | string
    startTime?: DateTimeNullableFilter<"LocalBatch"> | Date | string | null
    endTime?: DateTimeNullableFilter<"LocalBatch"> | Date | string | null
    operatorName?: StringNullableFilter<"LocalBatch"> | string | null
    syncStatus?: StringFilter<"LocalBatch"> | string
    remoteId?: IntNullableFilter<"LocalBatch"> | number | null
    createdAt?: DateTimeFilter<"LocalBatch"> | Date | string
  }

  export type LocalRecipeCreateWithoutBatchesInput = {
    name: string
    concreteGrade: string
    version?: string
    isActive?: boolean
    recipeData: string
    syncStatus?: string
    remoteId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocalRecipeUncheckedCreateWithoutBatchesInput = {
    id?: number
    name: string
    concreteGrade: string
    version?: string
    isActive?: boolean
    recipeData: string
    syncStatus?: string
    remoteId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocalRecipeCreateOrConnectWithoutBatchesInput = {
    where: LocalRecipeWhereUniqueInput
    create: XOR<LocalRecipeCreateWithoutBatchesInput, LocalRecipeUncheckedCreateWithoutBatchesInput>
  }

  export type LocalBatchingRecordCreateWithoutBatchInput = {
    materialName: string
    targetWeight: number
    actualWeight: number
    deviation?: number | null
    toleranceCheck?: string
    timestamp?: Date | string
  }

  export type LocalBatchingRecordUncheckedCreateWithoutBatchInput = {
    id?: number
    materialName: string
    targetWeight: number
    actualWeight: number
    deviation?: number | null
    toleranceCheck?: string
    timestamp?: Date | string
  }

  export type LocalBatchingRecordCreateOrConnectWithoutBatchInput = {
    where: LocalBatchingRecordWhereUniqueInput
    create: XOR<LocalBatchingRecordCreateWithoutBatchInput, LocalBatchingRecordUncheckedCreateWithoutBatchInput>
  }

  export type LocalBatchingRecordCreateManyBatchInputEnvelope = {
    data: LocalBatchingRecordCreateManyBatchInput | LocalBatchingRecordCreateManyBatchInput[]
  }

  export type LocalRecipeUpsertWithoutBatchesInput = {
    update: XOR<LocalRecipeUpdateWithoutBatchesInput, LocalRecipeUncheckedUpdateWithoutBatchesInput>
    create: XOR<LocalRecipeCreateWithoutBatchesInput, LocalRecipeUncheckedCreateWithoutBatchesInput>
    where?: LocalRecipeWhereInput
  }

  export type LocalRecipeUpdateToOneWithWhereWithoutBatchesInput = {
    where?: LocalRecipeWhereInput
    data: XOR<LocalRecipeUpdateWithoutBatchesInput, LocalRecipeUncheckedUpdateWithoutBatchesInput>
  }

  export type LocalRecipeUpdateWithoutBatchesInput = {
    name?: StringFieldUpdateOperationsInput | string
    concreteGrade?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    recipeData?: StringFieldUpdateOperationsInput | string
    syncStatus?: StringFieldUpdateOperationsInput | string
    remoteId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalRecipeUncheckedUpdateWithoutBatchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    concreteGrade?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    recipeData?: StringFieldUpdateOperationsInput | string
    syncStatus?: StringFieldUpdateOperationsInput | string
    remoteId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalBatchingRecordUpsertWithWhereUniqueWithoutBatchInput = {
    where: LocalBatchingRecordWhereUniqueInput
    update: XOR<LocalBatchingRecordUpdateWithoutBatchInput, LocalBatchingRecordUncheckedUpdateWithoutBatchInput>
    create: XOR<LocalBatchingRecordCreateWithoutBatchInput, LocalBatchingRecordUncheckedCreateWithoutBatchInput>
  }

  export type LocalBatchingRecordUpdateWithWhereUniqueWithoutBatchInput = {
    where: LocalBatchingRecordWhereUniqueInput
    data: XOR<LocalBatchingRecordUpdateWithoutBatchInput, LocalBatchingRecordUncheckedUpdateWithoutBatchInput>
  }

  export type LocalBatchingRecordUpdateManyWithWhereWithoutBatchInput = {
    where: LocalBatchingRecordScalarWhereInput
    data: XOR<LocalBatchingRecordUpdateManyMutationInput, LocalBatchingRecordUncheckedUpdateManyWithoutBatchInput>
  }

  export type LocalBatchingRecordScalarWhereInput = {
    AND?: LocalBatchingRecordScalarWhereInput | LocalBatchingRecordScalarWhereInput[]
    OR?: LocalBatchingRecordScalarWhereInput[]
    NOT?: LocalBatchingRecordScalarWhereInput | LocalBatchingRecordScalarWhereInput[]
    id?: IntFilter<"LocalBatchingRecord"> | number
    batchId?: IntFilter<"LocalBatchingRecord"> | number
    materialName?: StringFilter<"LocalBatchingRecord"> | string
    targetWeight?: FloatFilter<"LocalBatchingRecord"> | number
    actualWeight?: FloatFilter<"LocalBatchingRecord"> | number
    deviation?: FloatNullableFilter<"LocalBatchingRecord"> | number | null
    toleranceCheck?: StringFilter<"LocalBatchingRecord"> | string
    timestamp?: DateTimeFilter<"LocalBatchingRecord"> | Date | string
  }

  export type LocalBatchCreateWithoutBatchingRecordsInput = {
    batchNumber: string
    volume: number
    status?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    operatorName?: string | null
    syncStatus?: string
    remoteId?: number | null
    createdAt?: Date | string
    recipe: LocalRecipeCreateNestedOneWithoutBatchesInput
  }

  export type LocalBatchUncheckedCreateWithoutBatchingRecordsInput = {
    id?: number
    batchNumber: string
    recipeId: number
    volume: number
    status?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    operatorName?: string | null
    syncStatus?: string
    remoteId?: number | null
    createdAt?: Date | string
  }

  export type LocalBatchCreateOrConnectWithoutBatchingRecordsInput = {
    where: LocalBatchWhereUniqueInput
    create: XOR<LocalBatchCreateWithoutBatchingRecordsInput, LocalBatchUncheckedCreateWithoutBatchingRecordsInput>
  }

  export type LocalBatchUpsertWithoutBatchingRecordsInput = {
    update: XOR<LocalBatchUpdateWithoutBatchingRecordsInput, LocalBatchUncheckedUpdateWithoutBatchingRecordsInput>
    create: XOR<LocalBatchCreateWithoutBatchingRecordsInput, LocalBatchUncheckedCreateWithoutBatchingRecordsInput>
    where?: LocalBatchWhereInput
  }

  export type LocalBatchUpdateToOneWithWhereWithoutBatchingRecordsInput = {
    where?: LocalBatchWhereInput
    data: XOR<LocalBatchUpdateWithoutBatchingRecordsInput, LocalBatchUncheckedUpdateWithoutBatchingRecordsInput>
  }

  export type LocalBatchUpdateWithoutBatchingRecordsInput = {
    batchNumber?: StringFieldUpdateOperationsInput | string
    volume?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operatorName?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: StringFieldUpdateOperationsInput | string
    remoteId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipe?: LocalRecipeUpdateOneRequiredWithoutBatchesNestedInput
  }

  export type LocalBatchUncheckedUpdateWithoutBatchingRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    batchNumber?: StringFieldUpdateOperationsInput | string
    recipeId?: IntFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operatorName?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: StringFieldUpdateOperationsInput | string
    remoteId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionTaskCreateWithoutRecipeInput = {
    id?: string
    quantity: number
    priority?: number
    status?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
    productionRecords?: ProductionRecordCreateNestedManyWithoutTaskInput
  }

  export type ProductionTaskUncheckedCreateWithoutRecipeInput = {
    id?: string
    quantity: number
    priority?: number
    status?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
    productionRecords?: ProductionRecordUncheckedCreateNestedManyWithoutTaskInput
  }

  export type ProductionTaskCreateOrConnectWithoutRecipeInput = {
    where: ProductionTaskWhereUniqueInput
    create: XOR<ProductionTaskCreateWithoutRecipeInput, ProductionTaskUncheckedCreateWithoutRecipeInput>
  }

  export type ProductionTaskCreateManyRecipeInputEnvelope = {
    data: ProductionTaskCreateManyRecipeInput | ProductionTaskCreateManyRecipeInput[]
  }

  export type ProductionTaskUpsertWithWhereUniqueWithoutRecipeInput = {
    where: ProductionTaskWhereUniqueInput
    update: XOR<ProductionTaskUpdateWithoutRecipeInput, ProductionTaskUncheckedUpdateWithoutRecipeInput>
    create: XOR<ProductionTaskCreateWithoutRecipeInput, ProductionTaskUncheckedCreateWithoutRecipeInput>
  }

  export type ProductionTaskUpdateWithWhereUniqueWithoutRecipeInput = {
    where: ProductionTaskWhereUniqueInput
    data: XOR<ProductionTaskUpdateWithoutRecipeInput, ProductionTaskUncheckedUpdateWithoutRecipeInput>
  }

  export type ProductionTaskUpdateManyWithWhereWithoutRecipeInput = {
    where: ProductionTaskScalarWhereInput
    data: XOR<ProductionTaskUpdateManyMutationInput, ProductionTaskUncheckedUpdateManyWithoutRecipeInput>
  }

  export type ProductionTaskScalarWhereInput = {
    AND?: ProductionTaskScalarWhereInput | ProductionTaskScalarWhereInput[]
    OR?: ProductionTaskScalarWhereInput[]
    NOT?: ProductionTaskScalarWhereInput | ProductionTaskScalarWhereInput[]
    id?: StringFilter<"ProductionTask"> | string
    recipeId?: StringFilter<"ProductionTask"> | string
    quantity?: FloatFilter<"ProductionTask"> | number
    priority?: IntFilter<"ProductionTask"> | number
    status?: StringFilter<"ProductionTask"> | string
    startTime?: DateTimeNullableFilter<"ProductionTask"> | Date | string | null
    endTime?: DateTimeNullableFilter<"ProductionTask"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductionTask"> | Date | string
  }

  export type RecipeCreateWithoutProductionTasksInput = {
    id?: string
    name: string
    cement: number
    water: number
    sand: number
    gravel: number
    additive: number
    mixingTime: number
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecipeUncheckedCreateWithoutProductionTasksInput = {
    id?: string
    name: string
    cement: number
    water: number
    sand: number
    gravel: number
    additive: number
    mixingTime: number
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecipeCreateOrConnectWithoutProductionTasksInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutProductionTasksInput, RecipeUncheckedCreateWithoutProductionTasksInput>
  }

  export type ProductionRecordCreateWithoutTaskInput = {
    id?: string
    recipeId: string
    quantity: number
    status: string
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
  }

  export type ProductionRecordUncheckedCreateWithoutTaskInput = {
    id?: string
    recipeId: string
    quantity: number
    status: string
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
  }

  export type ProductionRecordCreateOrConnectWithoutTaskInput = {
    where: ProductionRecordWhereUniqueInput
    create: XOR<ProductionRecordCreateWithoutTaskInput, ProductionRecordUncheckedCreateWithoutTaskInput>
  }

  export type ProductionRecordCreateManyTaskInputEnvelope = {
    data: ProductionRecordCreateManyTaskInput | ProductionRecordCreateManyTaskInput[]
  }

  export type RecipeUpsertWithoutProductionTasksInput = {
    update: XOR<RecipeUpdateWithoutProductionTasksInput, RecipeUncheckedUpdateWithoutProductionTasksInput>
    create: XOR<RecipeCreateWithoutProductionTasksInput, RecipeUncheckedCreateWithoutProductionTasksInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutProductionTasksInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutProductionTasksInput, RecipeUncheckedUpdateWithoutProductionTasksInput>
  }

  export type RecipeUpdateWithoutProductionTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cement?: FloatFieldUpdateOperationsInput | number
    water?: FloatFieldUpdateOperationsInput | number
    sand?: FloatFieldUpdateOperationsInput | number
    gravel?: FloatFieldUpdateOperationsInput | number
    additive?: FloatFieldUpdateOperationsInput | number
    mixingTime?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipeUncheckedUpdateWithoutProductionTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cement?: FloatFieldUpdateOperationsInput | number
    water?: FloatFieldUpdateOperationsInput | number
    sand?: FloatFieldUpdateOperationsInput | number
    gravel?: FloatFieldUpdateOperationsInput | number
    additive?: FloatFieldUpdateOperationsInput | number
    mixingTime?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionRecordUpsertWithWhereUniqueWithoutTaskInput = {
    where: ProductionRecordWhereUniqueInput
    update: XOR<ProductionRecordUpdateWithoutTaskInput, ProductionRecordUncheckedUpdateWithoutTaskInput>
    create: XOR<ProductionRecordCreateWithoutTaskInput, ProductionRecordUncheckedCreateWithoutTaskInput>
  }

  export type ProductionRecordUpdateWithWhereUniqueWithoutTaskInput = {
    where: ProductionRecordWhereUniqueInput
    data: XOR<ProductionRecordUpdateWithoutTaskInput, ProductionRecordUncheckedUpdateWithoutTaskInput>
  }

  export type ProductionRecordUpdateManyWithWhereWithoutTaskInput = {
    where: ProductionRecordScalarWhereInput
    data: XOR<ProductionRecordUpdateManyMutationInput, ProductionRecordUncheckedUpdateManyWithoutTaskInput>
  }

  export type ProductionRecordScalarWhereInput = {
    AND?: ProductionRecordScalarWhereInput | ProductionRecordScalarWhereInput[]
    OR?: ProductionRecordScalarWhereInput[]
    NOT?: ProductionRecordScalarWhereInput | ProductionRecordScalarWhereInput[]
    id?: StringFilter<"ProductionRecord"> | string
    taskId?: StringFilter<"ProductionRecord"> | string
    recipeId?: StringFilter<"ProductionRecord"> | string
    quantity?: FloatFilter<"ProductionRecord"> | number
    status?: StringFilter<"ProductionRecord"> | string
    startTime?: DateTimeFilter<"ProductionRecord"> | Date | string
    endTime?: DateTimeFilter<"ProductionRecord"> | Date | string
    createdAt?: DateTimeFilter<"ProductionRecord"> | Date | string
  }

  export type ProductionTaskCreateWithoutProductionRecordsInput = {
    id?: string
    quantity: number
    priority?: number
    status?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
    recipe: RecipeCreateNestedOneWithoutProductionTasksInput
  }

  export type ProductionTaskUncheckedCreateWithoutProductionRecordsInput = {
    id?: string
    recipeId: string
    quantity: number
    priority?: number
    status?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
  }

  export type ProductionTaskCreateOrConnectWithoutProductionRecordsInput = {
    where: ProductionTaskWhereUniqueInput
    create: XOR<ProductionTaskCreateWithoutProductionRecordsInput, ProductionTaskUncheckedCreateWithoutProductionRecordsInput>
  }

  export type ProductionTaskUpsertWithoutProductionRecordsInput = {
    update: XOR<ProductionTaskUpdateWithoutProductionRecordsInput, ProductionTaskUncheckedUpdateWithoutProductionRecordsInput>
    create: XOR<ProductionTaskCreateWithoutProductionRecordsInput, ProductionTaskUncheckedCreateWithoutProductionRecordsInput>
    where?: ProductionTaskWhereInput
  }

  export type ProductionTaskUpdateToOneWithWhereWithoutProductionRecordsInput = {
    where?: ProductionTaskWhereInput
    data: XOR<ProductionTaskUpdateWithoutProductionRecordsInput, ProductionTaskUncheckedUpdateWithoutProductionRecordsInput>
  }

  export type ProductionTaskUpdateWithoutProductionRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipe?: RecipeUpdateOneRequiredWithoutProductionTasksNestedInput
  }

  export type ProductionTaskUncheckedUpdateWithoutProductionRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataHistoryCreateManyDataPointInput = {
    id?: number
    value: string
    quality?: string
    timestamp?: Date | string
  }

  export type DataHistoryUpdateWithoutDataPointInput = {
    value?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataHistoryUncheckedUpdateWithoutDataPointInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataHistoryUncheckedUpdateManyWithoutDataPointInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    quality?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalBatchCreateManyRecipeInput = {
    id?: number
    batchNumber: string
    volume: number
    status?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    operatorName?: string | null
    syncStatus?: string
    remoteId?: number | null
    createdAt?: Date | string
  }

  export type LocalBatchUpdateWithoutRecipeInput = {
    batchNumber?: StringFieldUpdateOperationsInput | string
    volume?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operatorName?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: StringFieldUpdateOperationsInput | string
    remoteId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batchingRecords?: LocalBatchingRecordUpdateManyWithoutBatchNestedInput
  }

  export type LocalBatchUncheckedUpdateWithoutRecipeInput = {
    id?: IntFieldUpdateOperationsInput | number
    batchNumber?: StringFieldUpdateOperationsInput | string
    volume?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operatorName?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: StringFieldUpdateOperationsInput | string
    remoteId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batchingRecords?: LocalBatchingRecordUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type LocalBatchUncheckedUpdateManyWithoutRecipeInput = {
    id?: IntFieldUpdateOperationsInput | number
    batchNumber?: StringFieldUpdateOperationsInput | string
    volume?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    operatorName?: NullableStringFieldUpdateOperationsInput | string | null
    syncStatus?: StringFieldUpdateOperationsInput | string
    remoteId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalBatchingRecordCreateManyBatchInput = {
    id?: number
    materialName: string
    targetWeight: number
    actualWeight: number
    deviation?: number | null
    toleranceCheck?: string
    timestamp?: Date | string
  }

  export type LocalBatchingRecordUpdateWithoutBatchInput = {
    materialName?: StringFieldUpdateOperationsInput | string
    targetWeight?: FloatFieldUpdateOperationsInput | number
    actualWeight?: FloatFieldUpdateOperationsInput | number
    deviation?: NullableFloatFieldUpdateOperationsInput | number | null
    toleranceCheck?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalBatchingRecordUncheckedUpdateWithoutBatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    targetWeight?: FloatFieldUpdateOperationsInput | number
    actualWeight?: FloatFieldUpdateOperationsInput | number
    deviation?: NullableFloatFieldUpdateOperationsInput | number | null
    toleranceCheck?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalBatchingRecordUncheckedUpdateManyWithoutBatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    materialName?: StringFieldUpdateOperationsInput | string
    targetWeight?: FloatFieldUpdateOperationsInput | number
    actualWeight?: FloatFieldUpdateOperationsInput | number
    deviation?: NullableFloatFieldUpdateOperationsInput | number | null
    toleranceCheck?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionTaskCreateManyRecipeInput = {
    id?: string
    quantity: number
    priority?: number
    status?: string
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
  }

  export type ProductionTaskUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionRecords?: ProductionRecordUpdateManyWithoutTaskNestedInput
  }

  export type ProductionTaskUncheckedUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productionRecords?: ProductionRecordUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type ProductionTaskUncheckedUpdateManyWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    priority?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionRecordCreateManyTaskInput = {
    id?: string
    recipeId: string
    quantity: number
    status: string
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
  }

  export type ProductionRecordUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionRecordUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductionRecordUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use DataPointCountOutputTypeDefaultArgs instead
     */
    export type DataPointCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DataPointCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocalRecipeCountOutputTypeDefaultArgs instead
     */
    export type LocalRecipeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocalRecipeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocalBatchCountOutputTypeDefaultArgs instead
     */
    export type LocalBatchCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocalBatchCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeCountOutputTypeDefaultArgs instead
     */
    export type RecipeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductionTaskCountOutputTypeDefaultArgs instead
     */
    export type ProductionTaskCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductionTaskCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EdgeConfigDefaultArgs instead
     */
    export type EdgeConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EdgeConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeviceConnectionDefaultArgs instead
     */
    export type DeviceConnectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeviceConnectionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DataPointDefaultArgs instead
     */
    export type DataPointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DataPointDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DataHistoryDefaultArgs instead
     */
    export type DataHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DataHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocalRecipeDefaultArgs instead
     */
    export type LocalRecipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocalRecipeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocalBatchDefaultArgs instead
     */
    export type LocalBatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocalBatchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocalBatchingRecordDefaultArgs instead
     */
    export type LocalBatchingRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocalBatchingRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocalAlarmDefaultArgs instead
     */
    export type LocalAlarmArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocalAlarmDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocalLogDefaultArgs instead
     */
    export type LocalLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocalLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SyncQueueDefaultArgs instead
     */
    export type SyncQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SyncQueueDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SyncStatusDefaultArgs instead
     */
    export type SyncStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SyncStatusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeDefaultArgs instead
     */
    export type RecipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductionTaskDefaultArgs instead
     */
    export type ProductionTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductionTaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductionRecordDefaultArgs instead
     */
    export type ProductionRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductionRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlarmDefaultArgs instead
     */
    export type AlarmArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlarmDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SafetyEventDefaultArgs instead
     */
    export type SafetyEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SafetyEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SafetyRuleDefaultArgs instead
     */
    export type SafetyRuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SafetyRuleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemMetricsDefaultArgs instead
     */
    export type SystemMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemMetricsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EquipmentRuntimeDefaultArgs instead
     */
    export type EquipmentRuntimeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EquipmentRuntimeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemStatusDefaultArgs instead
     */
    export type SystemStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemStatusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeviceStatsDefaultArgs instead
     */
    export type DeviceStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeviceStatsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}